<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SABR METRICS LAB | Ultimate Calculator Edition</title>
    <!-- Chart.js for Radar Chart -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* --- Design Tokens --- */
        :root {
            --c-bg: #f8fafc;
            --c-surface: #ffffff;
            --c-text-primary: #1e293b;
            --c-text-secondary: #64748b;
            --c-border: #e2e8f0;
            
            /* Category Colors & Accents */
            --cat-bat: #0ea5e9; --bg-bat: #f0f9ff; /* Sky Blue */
            --cat-pit: #f43f5e; --bg-pit: #fff1f2; /* Rose */
            --cat-fld: #d97706; --bg-fld: #fffbeb; /* Amber */
            --cat-tot: #10b981; --bg-tot: #ecfdf5; /* Emerald */
            --cat-std: #6366f1; --bg-std: #eef2ff; /* Indigo */
            --data-source-color: #4b5563;
            --ai-color: #8b5cf6;
            
            --shadow-card: 0 6px 15px -3px rgba(0, 0, 0, 0.08), 0 3px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-hover: 0 12px 25px -5px rgba(0, 0, 0, 0.15), 0 5px 10px -5px rgba(0, 0, 0, 0.08);
            --shadow-float: 0 20px 50px -10px rgba(0, 0, 0, 0.2);

            --font-sans: "Inter", "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            --font-mono: "JetBrains Mono", "Fira Code", Consolas, monospace;
            --font-serif: "Times New Roman", Times, serif; /* For Formulas */
        }

        /* --- Dark Mode Overrides --- */
        body.dark-mode {
            --c-bg: #0f172a;
            --c-surface: #1e293b;
            --c-text-primary: #f1f5f9;
            --c-text-secondary: #94a3b8;
            --c-border: #334155;
            
            --bg-bat: rgba(14, 165, 233, 0.15);
            --bg-pit: rgba(244, 63, 94, 0.15);
            --bg-fld: rgba(245, 158, 11, 0.15);
            --bg-tot: rgba(16, 185, 129, 0.15);
            --bg-std: rgba(99, 102, 241, 0.15);
            
            --shadow-card: 0 6px 15px -3px rgba(0, 0, 0, 0.4), 0 3px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-hover: 0 12px 25px -5px rgba(0, 0, 0, 0.6);
        }

        body {
            background-color: var(--c-bg);
            color: var(--c-text-primary);
            font-family: var(--font-sans);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            overflow-y: scroll;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- Header --- */
        header {
            background: var(--c-surface);
            padding: 4rem 2rem;
            text-align: center;
            position: relative;
            border-bottom: 1px solid var(--c-border);
            background-image: radial-gradient(var(--c-border) 1px, transparent 1px);
            background-size: 20px 20px;
            transition: background-color 0.3s;
        }

        .brand {
            font-size: 3.5rem;
            font-weight: 900;
            letter-spacing: -0.05em;
            margin: 0;
            color: var(--c-text-primary);
            background: linear-gradient(135deg, var(--c-text-primary) 0%, var(--c-text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .brand span { color: var(--cat-bat); -webkit-text-fill-color: var(--cat-bat); }
        
        .subtitle {
            color: var(--c-text-secondary);
            margin-top: 1rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        /* --- Sticky Controls --- */
        .controls-area {
            position: sticky;
            top: 0;
            background: var(--c-surface);
            opacity: 0.98;
            backdrop-filter: blur(12px);
            z-index: 100;
            border-bottom: 1px solid var(--c-border);
            padding: 1rem 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .search-wrapper {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0 0 1rem;
            padding: 0 2rem;
            position: relative;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .search-input {
            flex: 1;
            padding: 16px 24px 16px 50px;
            border-radius: 16px;
            border: 1px solid var(--c-border);
            background: var(--c-bg);
            font-size: 1rem;
            color: var(--c-text-primary);
            box-sizing: border-box;
            transition: all 0.2s;
            outline: none;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
        }
        .search-input:focus {
            background: var(--c-surface);
            border-color: var(--cat-bat);
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1);
        }
        /* 検索アイコンの修正 */
        .search-icon {
            position: absolute;
            left: 45px; top: 50%; 
            transform: translateY(-50%);
            color: var(--c-text-secondary);
            pointer-events: none;
            width: 20px; /* 明示的にサイズを指定 */
            height: 20px; /* 明示的にサイズを指定 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .search-icon svg { stroke-width: 2.5; width: 20px; height: 20px; } /* SVG自体のサイズも保証 */

        .theme-toggle {
            background: var(--c-bg);
            border: 1px solid var(--c-border);
            color: var(--c-text-primary);
            width: 54px;
            height: 54px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .theme-toggle:hover {
            border-color: var(--c-text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .theme-toggle svg { width: 24px; height: 24px; stroke-width: 2.5; }

        .filter-scroll {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        .filter-scroll::-webkit-scrollbar { height: 0; }

        .filter-chip {
            background: var(--c-surface);
            border: 1:px solid var(--c-border);
            color: var(--c-text-secondary);
            padding: 8px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 700;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex; align-items: center; gap: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.02);
        }
        .filter-chip:hover {
            background: var(--c-bg); color: var(--c-text-primary); transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .filter-chip.active {
            background: var(--c-text-primary); color: var(--c-surface);
            border-color: var(--c-text-primary); box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            transform: none;
        }

        /* --- Grid --- */
        .grid-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        .metric-card {
            background: var(--c-surface);
            border-radius: 20px;
            border: 1px solid var(--c-border);
            padding: 32px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex; flex-direction: column;
            position: relative; overflow: hidden;
            box-shadow: var(--shadow-card);
        }
        .metric-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-hover);
            border-color: var(--cat-bat);
        }
        
        .cat-bat:hover { border-color: var(--cat-bat); }
        .cat-pit:hover { border-color: var(--cat-pit); }
        .cat-fld:hover { border-color: var(--cat-fld); }
        .cat-tot:hover { border-color: var(--cat-tot); }
        .cat-std:hover { border-color: var(--cat-std); }

        .card-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;
        }
        .card-tag {
            font-size: 0.7rem; font-weight: 800; padding: 6px 12px; border-radius: 8px;
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .cat-bat .card-tag { background: var(--bg-bat); color: var(--cat-bat); }
        .cat-pit .card-tag { background: var(--bg-pit); color: var(--cat-pit); }
        .cat-fld .card-tag { background: var(--bg-fld); color: var(--cat-fld); }
        .cat-tot .card-tag { background: var(--bg-tot); color: var(--cat-tot); }
        .cat-std .card-tag { background: var(--bg-std); color: var(--cat-std); }
        
        /* 絵文字をSVGアイコンに置き換え */
        .calc-icon {
            opacity: 0.3; transition: 0.2s;
        }
        .calc-icon svg { width: 20px; height: 20px; stroke-width: 2.5; }
        .metric-card:hover .calc-icon { opacity: 1; transform: scale(1.1); }
        .calc-icon.ai svg { color: var(--ai-color); opacity: 0.8; }

        .metric-title {
            font-size: 2.2rem;
            font-weight: 800;
            margin: 0;
            line-height: 1;
            color: var(--c-text-primary);
            letter-spacing: -0.03em;
        }
        .metric-full {
            font-size: 0.85rem;
            color: var(--c-text-secondary);
            font-weight: 600;
            margin: 6px 0 20px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }
        .metric-desc {
            font-size: 0.95rem;
            color: var(--c-text-secondary);
            margin: 0;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* --- Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.show { opacity: 1; }

        .modal-panel {
            background: var(--c-surface);
            width: 95%;
            max-width: 850px;
            max-height: 92vh;
            border-radius: 24px;
            padding: 0;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-float);
            transform: scale(0.95) translateY(20px); 
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--c-border);
        }
        .modal-overlay.show .modal-panel { transform: scale(1) translateY(0); }

        .modal-header {
            padding: 32px 40px;
            background: var(--c-bg);
            border-bottom: 1px solid var(--c-border);
            position: relative;
        }
        .modal-body {
            padding: 40px;
            overflow-y: auto;
            color: var(--c-text-primary);
        }

        .m-cat {
            font-size: 0.8rem;
            font-weight: 800;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }
        .m-title {
            font-size: 3.5rem;
            font-weight: 900;
            margin: 0;
            line-height: 1;
            letter-spacing: -0.03em;
            color: var(--c-text-primary);
        }
        .m-full {
            font-size: 1.1rem;
            color: var(--c-text-secondary);
            margin-top: 5px;
            font-weight: 500;
        }

        .close-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: var(--c-surface);
            border: 1px solid var(--c-border);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.5rem;
            color: var(--c-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .close-btn:hover { background: var(--c-bg); color: var(--c-text-primary); transform: rotate(90deg); }

        .section-label {
            font-size: 0.8rem;
            font-weight: 800;
            color: var(--c-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 3rem 0 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        /* 句点を削除 */
        .section-label::before { content:''; color: var(--cat-bat); }
        .section-label::after { content:''; flex:1; height:1px; background: var(--c-border); }
        .section-label.has-hash::before { content:'#'; }

        /* --- Formula Box --- */
        .formula-box {
            background: #1e293b; /* Always dark for formula */
            border: 1px solid #334155;
            padding: 30px;
            border-radius: 16px;
            font-family: var(--font-serif);
            font-size: 1.3rem;
            font-style: italic;
            color: #e2e8f0;
            overflow-x: auto;
            text-align: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }
        .formula-var {
            color: #38bdf8;
            font-weight: bold;
            margin: 0 2px;
            font-family: var(--font-sans);
            font-style: normal;
        }
        .formula-op { color: #94a3b8; margin: 0 5px; }

        /* --- Calculator Section --- */
        .calc-container {
            background: var(--c-bg);
            border: 1px solid var(--c-border);
            border-radius: 16px;
            padding: 30px;
            margin-top: 10px;
            position: relative; /* For ocr button positioning */
        }
        .calc-container.ai-mode {
            background: rgba(139, 92, 46, 0.05);
            border-color: var(--ai-color);
        }
        .calc-container.ai-mode .calc-title span { color: var(--ai-color); }
        .calc-container.ai-mode .calc-btn { background: var(--ai-color); }
        .calc-container.ai-mode .calc-btn:hover { background: #7c3aed; opacity: 0.9; }
        .calc-container.ai-mode .calc-res-value { color: var(--ai-color); }

        .calc-title {
            font-size: 1rem;
            font-weight: 800;
            color: var(--cat-bat);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .calc-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .calc-group { display: flex; flex-direction: column; gap: 5px; }
        .calc-label { font-size: 0.7rem; font-weight: 700; color: var(--c-text-secondary); text-transform: uppercase; }
        .calc-field, .calc-select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-mono);
            text-align: right;
            font-size: 1rem;
            background: var(--c-surface);
            color: var(--c-text-primary);
        }
        .calc-select { text-align: left; font-family: var(--font-sans); cursor: pointer; }
        .calc-field:focus, .calc-select:focus { outline: none; border-color: var(--cat-bat); box-shadow: 0 0 0 2px rgba(14,165,233,0.2); }

        /* Preset Styles */
        .preset-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
            background: rgba(0,0,0,0.03);
            padding: 12px;
            border-radius: 12px;
            flex-wrap: wrap;
            border: 1px solid var(--c-border);
        }
        .preset-label { width: 100%; font-size: 0.75rem; font-weight: 700; color: var(--c-text-secondary); margin-bottom: 4px; }
        .preset-select {
            flex: 1;
            min-width: 140px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-sans);
            font-size: 0.9rem;
        }
        .preset-input {
            flex: 1;
            min-width: 140px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-sans);
            font-size: 0.9rem;
        }
        .preset-btn {
            padding: 8px 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            color: white;
            transition: 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .btn-load { background: var(--c-text-secondary); }
        .btn-load:hover { background: var(--c-text-primary); }
        .btn-save { background: var(--cat-bat); }
        .btn-save:hover { opacity: 0.9; }
        .btn-del { background: #ef4444; color: white; }
        .btn-del:hover { opacity: 0.9; }
        .preset-btn svg { width: 16px; height: 16px; stroke-width: 2.5; }

        /* --- Advanced Settings Style --- */
        .advanced-details {
            grid-column: 1 / -1;
            margin-top: 10px;
            border: 1px solid var(--c-border);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0,0,0,0.02);
        }
        .advanced-summary {
            padding: 12px 15px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--c-text-secondary);
            background: rgba(255,255,255,0.5);
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .advanced-summary::before {
            content: ' '; /* 絵文字削除 */
            font-size: 1rem;
        }
        .advanced-summary:hover {
            background: var(--c-surface);
            color: var(--cat-bat);
        }
        .advanced-content {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            border-top: 1px solid var(--c-border);
        }
        .advanced-details[open] .advanced-summary {
            border-bottom: 1px solid transparent;
        }
        .advanced-summary .icon-gear {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
            color: var(--c-text-secondary);
        }
        .advanced-summary:hover .icon-gear { color: var(--cat-bat); }


        .warning-msg {
            grid-column: 1 / -1;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            color: #b45309;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            animation: fadeIn 0.3s ease;
        }
        .warning-msg::before {
            content: '⚠️';
            font-size: 1.2rem;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        .calc-result-area {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px dashed var(--c-border);
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }
        .calc-res-label { font-size: 0.9rem; color: var(--c-text-secondary); font-weight: 600; }
        .calc-res-label span { font-size: 0.7em; background: var(--ai-color); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 5px; vertical-align: middle; }
        .calc-res-value { font-size: 2.5rem; font-weight: 900; color: var(--cat-bat); font-family: var(--font-mono); line-height: 1; }
        .calc-btn {
            background: var(--cat-bat);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 50px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .calc-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .calc-btn svg { width: 18px; height: 18px; stroke-width: 2.5; }

        .criteria-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .criteria-table th { text-align: left; color: var(--c-text-secondary); width: 120px; padding: 12px 0; border-bottom: 1px solid var(--c-border); }
        .criteria-table td { padding: 12px 0; border-bottom: 1px solid var(--c-border); color: var(--c-text-primary); font-weight: 600; }

        .related-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .rel-chip {
            background: var(--c-bg);
            padding: 8px 20px;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--c-text-secondary);
            cursor: pointer;
            border: 1px solid transparent;
            transition: 0.2s;
        }
        .rel-chip:hover { background: var(--c-text-primary); color: var(--c-surface); }

        .no-result {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px;
            color: var(--c-text-secondary);
        }
        
        /* --- Smart Parser Style --- */
        .parser-area {
            margin-bottom: 20px;
            background: var(--c-surface);
            border: 1px dashed var(--cat-bat);
            padding: 15px;
            border-radius: 12px;
        }
        .parser-textarea {
            width: 100%;
            height: 120px;
            border: 1px solid var(--c-border);
            border-radius: 8px;
            padding: 15px;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            box-sizing: border-box;
            resize: vertical;
            background: #f8fafc;
            transition: all 0.2s;
        }
        .parser-textarea:focus {
            background: #ffffff;
            border-color: var(--cat-bat);
            outline: none;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }
        .parser-btn {
            background: var(--c-text-primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            width: 100%;
            transition: all 0.3s;
            margin-top: 10px;
        }
        .parser-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .parser-btn.analyzing { background: var(--cat-bat); cursor: wait; animation: pulse 1.5s infinite; }
        .parser-btn svg { width: 18px; height: 18px; stroke-width: 2.5; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* --- Chart Container --- */
        .chart-wrapper {
            max-width: 400px;
            margin: 20px auto;
            position: relative;
        }
        
        /* Helper for formula formatting */
        .var { color: #38bdf8; font-family: var(--font-sans); font-weight: 600; font-style: normal; margin: 0 2px; }

        @media (max-width: 700px) {
            .brand { font-size: 2.5rem; }
            .m-title { font-size: 2.5rem; }
            .grid-container { grid-template-columns: 1fr; padding: 40px 1rem;}
            .modal-panel { width: 100%; height: 100%; border-radius: 0; }
            .search-wrapper { padding: 0 1rem; }
        }

    </style>
</head>
<body>
    <!-- Utility Functions (Simplified for single file) -->
    <script>
        // Icon Definitions (Lucide Icons for a clean look)
        const icons = {
            search: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>`,
            sun: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`,
            moon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`,
            barChart: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bar-chart"><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></svg>`,
            calculator: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calculator"><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="10" y2="18"/><line x1="8" x2="8" y1="10" y2="18"/><line x1="12" x2="12" y1="10" y2="18"/><line x1="8" x2="16" y1="14" y2="14"/></svg>`,
            gear: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2H2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 2 2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 2 2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-2-2v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-2-2V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`,
            sparkle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles"><path d="m12 3-1.83 2.66-2.67 1.84 2.67 1.84L12 13l1.83-2.66 2.67-1.84-2.67-1.84L12 3z"/><path d="m20.2 16.2-1.22 1.8-1.78 1.22 1.78 1.22 1.22 1.8 1.22-1.8 1.78-1.22-1.78-1.22-1.22-1.8z"/><path d="m4.64 10.36-1.15 1.68-1.57 1.08 1.57 1.08 1.15 1.68 1.15-1.68 1.57-1.08-1.57-1.08-1.15-1.68z"/></svg>`,
            loader: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>`,
            trash: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 3h6"/></svg>`,
            save: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-save"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>`,
            clipboard: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clipboard-copy"><rect width="8" height="4" x="8" y="2"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="M15 22v-3a3 3 0 0 0-3-3l-2.5 2.5"/><path d="M8 13l2.5 2.5"/></svg>`
        };
    </script>
    
    <header>
        <h1 class="brand">SABR<span>METRICS</span> LAB</h1>
        <p class="subtitle">Comprehensive Baseball Analytics Dictionary & Calculator</p>
    </header>

    <div class="controls-area">
        <div class="search-wrapper">
            <!-- 修正: アイコンの挿入をJavaScriptで行うため、中身を空に -->
            <span class="search-icon" id="searchIcon"></span> 
            <input type="text" class="search-input" id="searchInput" placeholder="指標名、意味、計算式で検索" oninput="handleSearch()">
            <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle" title="Dark Mode">
                <!-- 修正: 初期アイコンの挿入をJavaScriptで行うため、中身を空に -->
            </button>
        </div>
        
        <!-- Batch Calc Buttons -->
        <div style="display:flex; justify-content:center; gap:10px; margin-bottom:15px;">
            <button class="preset-btn btn-save" onclick="openBatchCalc('bat')" style="font-size:0.9rem; padding:10px 20px;">野手一括計算</button>
            <button class="preset-btn btn-del" onclick="openBatchCalc('pit')" style="font-size:0.9rem; padding:10px 20px; background:#f43f5e;">投手一括計算</button>
        </div>

        <div class="filter-scroll">
            <div class="filter-chip active" onclick="filterCategory('all')" data-cat="all">ALL</div>
            <div class="filter-chip" onclick="filterCategory('std')" data-cat="std">基本</div>
            <div class="filter-chip" onclick="filterCategory('bat')" data-cat="bat">打撃</div>
            <div class="filter-chip" onclick="filterCategory('pit')" data-cat="pit">投球</div>
            <div class="filter-chip" onclick="filterCategory('fld')" data-cat="fld">守備走塁</div>
            <div class="filter-chip" onclick="filterCategory('tot')" data-cat="tot">総合</div>
        </div>
    </div>

    <div class="grid-container" id="grid">
        <!-- Generated -->
    </div>

    <div class="modal-overlay" id="modal" onclick="closeModalOutside(event)">
        <div class="modal-panel">
            <div class="modal-header" id="modal-header">
                <button class="close-btn" onclick="closeModal()">×</button>
                <div id="modal-title-area"></div>
            </div>
            <div class="modal-body" id="modal-body-content"></div>
        </div>
    </div>

<script>
    // --- Data Helper ---
    const formatVar = (text) => `<span class="var">${text}</span>`;

    // --- Constants (Default Values) ---
    const DEFAULTS = {
        // リーグ全体の統計（デフォルト値は概算）
        LG_PA: 28500,
        LG_RUNS: 2800,
        LG_HITS: 6900,
        LG_2B: 1150,
        LG_3B: 120,
        LG_HR: 485, 
        LG_BB: 2300,
        // リーグ総数詳細
        LG_AB: 28750, // 打数
        LG_HBP: 300,  // 死球
        LG_SF: 190,   // 犠飛
        LG_SH: 550    // 犠打
    };
    
    // --- 統一された詳細設定の定義 (11項目) ---
    const ADVANCED_LEAGUE_INPUTS = [
        {id:'lg_pa', label:'リーグ総打席', type:'number', advanced:true, default: DEFAULTS.LG_PA},
        {id:'lg_runs', label:'リーグ総得点', type:'number', advanced:true, default: DEFAULTS.LG_RUNS},
        {id:'lg_ab', label:'リーグ総打数', type:'number', advanced:true, default: DEFAULTS.LG_AB}, 
        {id:'lg_hits', label:'リーグ総安打', type:'number', advanced:true, default: DEFAULTS.LG_HITS},
        {id:'lg_2b', label:'リーグ総二塁打', type:'number', advanced:true, default: DEFAULTS.LG_2B},
        {id:'lg_3b', label:'リーグ総三塁打', type:'number', advanced:true, default: DEFAULTS.LG_3B},
        {id:'lg_hr', label:'リーグ総本塁打', type:'number', advanced:true, default: DEFAULTS.LG_HR},
        {id:'lg_bb', label:'リーグ総四球', type:'number', advanced:true, default: DEFAULTS.LG_BB},
        {id:'lg_hbp', label:'リーグ総死球', type:'number', advanced:true, default: DEFAULTS.LG_HBP},
        {id:'lg_sf', label:'リーグ総犠飛', type:'number', advanced:true, default: DEFAULTS.LG_SF},
        {id:'lg_sh', label:'リーグ総犠打', type:'number', advanced:true, default: DEFAULTS.LG_SH}
    ];

    // Park Factors
    const PARK_FACTORS = {
        'avg':      {name: '平均',     pf: 1.00},
        'jingu':    {name: '明治神宮', pf: 1.19},
        'yoko':     {name: '横浜',     pf: 1.04},
        'mazda':    {name: 'マツダ',   pf: 0.99},
        'tokyo':    {name: '東京ドーム', pf: 0.97},
        'koshien':  {name: '甲子園',   pf: 0.92},
        'nagoya':   {name: 'バンテリン', pf: 0.86},
        'escon':    {name: 'エスコン', pf: 1.06},
        'zozo':     {name: 'ZOZOマリン', pf: 1.06},
        'paypay':   {name: 'PayPay',   pf: 1.05},
        'belluna':  {name: 'ベルーナ', pf: 0.97},
        'kyocera':  {name: '京セラ',   pf: 0.95},
        'rakuten':  {name: '楽天モバイル', pf: 0.94}
    };

    // --- Helper to calculate Derived Constants ---
    function calcDerived(d) {
        // 基本入力値
        const lg_hr = d.lg_hr || DEFAULTS.LG_HR;
        const lg_bb = d.lg_bb || DEFAULTS.LG_BB;
        // 詳細パラメータ
        const lg_ab = d.lg_ab || DEFAULTS.LG_AB;
        const lg_hbp = d.lg_hbp || DEFAULTS.LG_HBP;
        const lg_sf = d.lg_sf || DEFAULTS.LG_SF;
        const lg_sh = d.lg_sh || DEFAULTS.LG_SH;
        
        // その他のリーグ統計
        const lg_pa = d.lg_pa || DEFAULTS.LG_PA;
        const lg_runs = d.lg_runs || DEFAULTS.LG_RUNS;
        const lg_hits = d.lg_hits || DEFAULTS.LG_HITS;
        const lg_2b = d.lg_2b || DEFAULTS.LG_2B;
        const lg_3b = d.lg_3b || DEFAULTS.LG_3B;

        // --- リーグ詳細データの計算 ---
        const lg_ibb = lg_bb * 0.03; 
        const lg_roe = Math.max(0, lg_pa - (lg_ab + lg_bb + lg_hbp + lg_sf + lg_sh));
        const lg_1b = lg_hits - lg_2b - lg_3b - lg_hr;
        const lg_obp = (lg_hits + lg_bb + lg_hbp) / (lg_ab + lg_bb + lg_hbp + lg_sf);

        // 推定: リーグ三振数 (PAの約18%)
        const lg_so = lg_pa * 0.18;
        
        // 推定: リーグ打球数 (Batted Balls)
        // Batted Balls = PA - BB - HBP - SO
        const lg_batted = lg_pa - lg_bb - lg_hbp - lg_so;
        
        // 推定: リーグ外野フライ数 (ユーザー指定: FB% 45%, GB% 45%, LD% 10%)
        const lg_fb_est = lg_batted * 0.45;

        // --- wOBA計算 (基準係数: wOBA Scale=1.28想定) ---
        const woba_denom = lg_ab + lg_bb - lg_ibb + lg_hbp + lg_sf;
        
        const woba_num_std = 
            0.692 * (lg_bb - lg_ibb) +
            0.73  * lg_hbp +
            0.966 * lg_roe +
            0.865 * lg_1b +
            1.334 * lg_2b +
            1.725 * lg_3b +
            2.065 * lg_hr;
            
        const lg_woba_std = woba_denom > 0 ? woba_num_std / woba_denom : 0;

        // --- 係数補正比率 (Fitting Ratio) ---
        const fitting_ratio = (lg_woba_std > 0 && lg_obp > 0) ? (lg_obp / lg_woba_std) : 1.0;
        const lg_woba = lg_woba_std * fitting_ratio;

        // --- wOBA Scale ---
        const woba_scale = 1.28 * fitting_ratio;

        // --- その他パラメータ ---
        const lg_r_pa = lg_runs / lg_pa;
        const est_lg_ip = lg_pa / 4.25;
        const rpw = 20 * (lg_runs / est_lg_ip);
        const rep_per_pa = 0.12 * (lg_woba / woba_scale);
        
        const lg_tra = (lg_runs / est_lg_ip) * 9 * 0.92;

        // --- xFIP定数 & 比率の計算 ---
        
        // 比率 = 本塁打 ÷ 外野フライ
        const lg_xfip_ratio = lg_hr / lg_fb_est;
        
        // リーグ失点率 (RA9)
        const lg_ra9 = (lg_runs / est_lg_ip) * 9;
        
        // リーグ防御率 (ERA) 推定 (RA9の約92%)
        const lg_era_est = lg_ra9 * 0.92;
        
        // xFIPのリーグ成分
        const lg_xfip_component = (13 * lg_xfip_ratio * lg_fb_est + 3 * (lg_bb - lg_ibb + lg_hbp) - 2 * lg_so) / est_lg_ip;
        
        // 定数 = リーグ防御率 - リーグxFIP成分
        const xfip_constant = lg_era_est - lg_xfip_component;

        // --- tRA定数の計算 (新規追加) ---
        // リーグ打球内訳の推定
        // インプレー打球 (BIP) = PA - BB - HBP - SO - HR
        let lg_bip = lg_pa - lg_bb - lg_hbp - lg_so - lg_hr;
        if (lg_bip < 0) lg_bip = 0;

        // 平均的な分布率 (GB:45%, LD:21%, FB系:34%)
        const lg_gb = lg_bip * 0.45;
        const lg_ld = lg_bip * 0.21;
        const lg_fb_system = lg_bip * 0.34;
        const lg_pu = lg_fb_system * 0.10; // 内野フライ (FB系の10%)
        const lg_fb = lg_fb_system - lg_pu; // 純粋な外野フライ

        // リーグtRA成分 (定数なしのtRA)
        const lg_tra_num = 
            0.297 * lg_bb + 
            0.327 * lg_hbp - 
            0.108 * lg_so + 
            1.401 * lg_hr + 
            0.036 * lg_gb - 
            0.124 * lg_pu + 
            0.132 * lg_fb + 
            0.289 * lg_ld;

        const lg_tra_denom = 
            lg_so + 
            0.745 * lg_gb + 
            0.304 * lg_ld + 
            0.994 * lg_pu + 
            0.675 * lg_fb;
        
        let tra_constant = 0;
        if (lg_tra_denom > 0) {
            const lg_tra_raw = (lg_tra_num / lg_tra_denom) * 27;
            // 定数 = リーグ失点率(RA9) - リーグtRA
            tra_constant = lg_ra9 - lg_tra_raw;
        }

        return { 
            lg_r_pa, rpw, rep_per_pa, lg_woba, lg_tra, woba_scale, fitting_ratio, 
            xfip_constant, lg_xfip_ratio, lg_fb_est, tra_constant, lg_ra9, lg_era_est
        };
    }

    // --- 新規追加: 打球内訳の推定ロジック ---
    function estimateBattedBalls(d) {
        // 既に実数がある場合は計算しない（再計算防止）
        // NOTE: dにはリーグ平均値が含まれるため、再計算防止はここでは行わない方が良い
        // if (d.est_done) return d; 
        
        // リーグ総本塁打を使用
        const lg_hr = d.lg_hr || DEFAULTS.LG_HR;

        // 1. 打者数(BF)の確保
        let bf = d.bf;
        if (!bf) {
            // BFがなければ投球回から推定 (IP x 4.20 程度が平均的)
            bf = d.ip * 4.20; 
        }

        // 2. 三振、四死球
        const so = d.so || (d.ip * 0.8); // 仮置き
        const bb = d.bb || (d.ip * 0.3);
        const hbp = d.hbp || 0;
        const hr = d.hr || 0; // 被本塁打 (SIERA, tRAの計算に必要)

        // 3. インプレー打球数 (BIP) の推定
        // BIP = 打者 - 三振 - 四球 - 死球 - 被本塁打
        let bip = bf - so - bb - hbp - hr;
        if (bip < 0) bip = 0;

        // 4. ゴロ率 (GB%) の取得
        // セレクトボックスの値(文字列)を数値化。デフォルトは平均の45%
        let gb_pct_val = 45; 
        if (d.gb_type) {
            gb_pct_val = parseFloat(d.gb_type);
        }

        const gb_rate = gb_pct_val / 100;
        const ld_rate = 0.21; // Line Driveは投手によらず約21%で一定とするのが一般的
        
        // 残りがフライ系 (FB + PU)
        let fb_system_rate = 1.0 - gb_rate - ld_rate;
        if (fb_system_rate < 0) fb_system_rate = 0;

        // 内野フライ率 (IFFB% / FB_total)
        // フライ全体のうち約10%が内野フライと仮定
        const iffb_rate = 0.10; 

        // 実数計算 (BIPをベースに分配)
        const gb = bip * gb_rate;
        const ld = bip * ld_rate;
        const fb_total = bip * fb_system_rate;
        const pu = fb_total * iffb_rate;     // 内野フライ
        const fb = fb_total - pu;            // 純粋な外野フライ (HRは含まない)

        // データオブジェクトに注入
        d.gb = gb;
        d.ld = ld;
        d.fb = fb;
        d.pu = pu;
        d.bf = bf; // 推定したBFも保存
        d.hr = hr; // 被本塁打も計算用に注入
        d.est_done = true; // フラグ

        return d;
    }

    // --- Helper: 詳細スタッツの計算 (Calculate Details from Inputs) ---
    function estimateDetails(d) {
        // IBBは入力がないため概算 (四球の約4%)
        const ibb = d.bb * 0.04;

        // ROE (失策出塁) の計算
        // ROE = 打席 - (打数 + 四球 + 死球 + 犠飛 + 犠打)
        const roe = Math.max(0, d.pa - (d.ab + d.bb + d.hbp + d.sf + d.sh));

        // 単打 (S)
        // Note: d.h must be defined. Assuming it is 0 if undefined.
        const h = d.h || 0;
        const d_val = d.d || 0;
        const t = d.t || 0;
        const hr = d.hr || 0;
        const s = h - d_val - t - hr;

        return { ibb, roe, s };
    }

    // --- Terms Database (説明文を常体に統一) ---
    const terms = [
        /* ---------------- 総合 (Total) ---------------- */
        {
            id: "war", category: "tot", title: "WAR (野手)", full: "Wins Above Replacement (Batter)",
            short: "打撃、走塁、守備を総合的に評価して野手の貢献度を表す指標",
            desc: "代替可能な控え選手（リプレイスメント・レベルの選手）が出場する場合に比べ、どれだけ勝利数を増やしたかによって計算される。<br>wOBA係数はリーグ環境（wOBA Scale）に合わせて自動補正される",
            formula: `(wRAA + UZR + BaseRunning + ポジション補正 + 代替水準補正) ÷ RPW`,
            criteria: "2.0: レギュラー / 5.0: スター / 8.0: MVP",
            related: ["wraa", "uzr", "woba", "rpw"],
            aiMode: true,
            inputs: [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},
                {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'},
                
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'pos', label:'守備位置', type:'select', options:{'dh':'DH', '1b':'一塁', 'lf':'左翼', 'rf':'右翼', '3b':'三塁', '2b':'二塁', 'cf':'中堅', 'ss':'遊撃', 'c':'捕手'}},
                {id:'def', label:'守備評価', type:'select', options:{'0':'平均的 (0)', '5':'上手い (+5)', '10':'名手 (+10)', '15':'神 (+15)', '-5':'苦手 (-5)', '-10':'下手 (-10)'}},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio; // 補正係数

                // 1. Calculate wOBA (Coefficients scaled by fitting_ratio)
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;

                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * est.s +
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;

                const woba_val = woba_denom > 0 ? woba_num / woba_denom : 0;
                
                // 2. wRAA
                const raw_wRAA = ((woba_val - C.lg_woba) / C.woba_scale) * d.pa;

                // 3. Park Adj
                const pf = PARK_FACTORS[d.stadium].pf;
                const home_ratio = 0.5;
                const pf_coef = (home_ratio * pf) + ((1 - home_ratio) * (6 - pf) / 5);
                const parkAdj = (1 - pf_coef) * C.lg_r_pa * d.pa;
                
                const battingRuns = raw_wRAA + parkAdj;
                
                // 4. Pos Adj
                const posVals = {'dh':-15.1, '1b':-14.1, 'lf':-12.0, 'rf':-5.0, '3b':-4.8, '2b':3.4, 'cf':4.2, 'ss':10.3, 'c':18.1};
                const posAdj = (posVals[d.pos] || 0) * (d.pa / 600);
                
                // 5. UZR & BaseRunning
                const uzr = parseFloat(d.def) || 0;
                const baseRunning = (d.sb * 0.2) - (d.cs * 0.4);
                
                // 6. Replacement Level
                const repRuns = C.rep_per_pa * d.pa;
                
                // 7. Calc WAR
                const totalRuns = battingRuns + uzr + baseRunning + posAdj + repRuns;
                return (totalRuns / C.rpw).toFixed(1);
            }
        },
        {
            id: "wrc_plus", category: "bat", title: "wRC+", full: "weighted Runs Created Plus",
            short: "打撃の傑出度を評価する指標",
            desc: "打席あたりの得点創出の多さを、平均的な打者を100とした場合のパーセンテージで評価する指標",
            formula: `(((wRAA/打席 + R/PA) + (R/PA - PF補正係数×R/PA)) ÷ R/PA) × 100`,
            criteria: "100: 平均 / 160: MVP候補 / 200: 歴史的",
            related: ["woba", "wraa"],
            aiMode: true,
            inputs: [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},

                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio;
                const pf = PARK_FACTORS[d.stadium].pf;
                
                // wOBA
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;
                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * est.s +
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;
                const woba_val = woba_denom > 0 ? woba_num / woba_denom : 0;
                
                // wRAA
                const raw_wraa = ((woba_val - C.lg_woba) / C.woba_scale) * d.pa;
                
                // Park Adj
                const home_ratio = 0.5;
                const pf_coef = (home_ratio * pf) + ((1 - home_ratio) * (6 - pf) / 5);
                const parkAdj = (1 - pf_coef) * C.lg_r_pa * d.pa;

                // wRC+ Calc
                const wrc_plus_val = (((raw_wraa + parkAdj) / d.pa) + C.lg_r_pa) / C.lg_r_pa * 100;
                
                return wrc_plus_val.toFixed(0);
            }
        },
        {
            id: "pit_war", category: "tot", title: "WAR (投手)", full: "Wins Above Replacement (Pitcher)",
            short: "投球を総合的に評価して投手の貢献度を表す指標",
            desc: "代替可能な控え選手に比べ、どれだけ勝利数を増やしたかによって計算される。<br>SPRAR (先発としての貢献) と RPRAR (救援としての貢献) を足し合わせ、RPWで割って算出する",
            formula: `(SPRAR + RPRAR) ÷ RPW`,
            criteria: "2.0: ローテ投手 / 4.0: エース",
            related: ["fip", "tra", "rsaa", "rpw"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hr', label:'被本塁打'},
                {id:'role', label:'役割', type:'select', options:{'sp':'先発', 'rp':'救援'}},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);

                // 1. FIP Calculation (Standard Constant approx 3.10)
                const fip = (13 * d.hr + 3 * d.bb - 2 * d.so) / d.ip + 3.10; // Simple FIP constant is approx 3.10

                // 2. League Parameters
                // C.lg_ra9 is calculated inside calcDerived using the new comprehensive inputs
                const lg_ra9 = C.lg_ra9;

                // 3. Park Adjustment
                const pf = PARK_FACTORS[d.stadium].pf;
                // Park Adjusted League RA9
                const lg_ra9_park = lg_ra9 * pf;

                // 4. Runs Above Average (RAA) based on FIP
                // RAA = (League RA - Pitcher FIP) * IP / 9
                const raa = (lg_ra9_park - fip) * (d.ip / 9);

                // 5. Replacement Level Adjustment
                // SP: +0.38 runs/9, RP: +0.47 runs/9 (approx)
                const rep_bonus = d.role === 'sp' ? 0.38 : 0.47;
                const rep_runs = rep_bonus * (d.ip / 9);

                // 6. RAR (Runs Above Replacement) -> SPRAR or RPRAR
                const rar = raa + rep_runs;
                
                // Since inputs only allow one role, SPRAR+RPRAR is just RAR
                return (rar / C.rpw).toFixed(1);
            }
        },
        {
            id: "rpw", category: "tot", title: "RPW", full: "Runs Per Win",
            short: "勝利を1つ増やすのに必要な得点数",
            desc: "「1勝の重み」を得点換算したもの。デフォルトでは8.5に設定されている",
            formula: `20 × (リーグ総得点 ÷ リーグ総投球回)`,
            criteria: "8.5 ～ 10.0",
            related: ["war", "pythag"],
            inputs: [
                {id:'lg_runs', label:'リーグ総得点'},
                {id:'lg_pa', label:'リーグ総打席'}
                // IPはPAから推定されるため、ここではPAを使用
            ],
            calc: (d) => {
                const est_lg_ip = d.lg_pa / 4.25; // Estimate IP from PA
                return (20 * (d.lg_runs / est_lg_ip)).toFixed(2);
            }
        },
        {
            id: "wpa", category: "tot", title: "WPA", full: "Win Probability Added",
            short: "勝利確率をどれだけ変動させたかを示す",
            desc: "状況（点差、イニング、走者、アウト）ごとの勝利確率を、プレイ前後でどれだけ増やしたかによって評価する。勝負強さを測るのに最適で、サヨナラホームランなどは非常に高い値になる",
            formula: `プレイ後の勝利確率 - プレイ前の勝利確率`,
            criteria: "状況に依存",
            related: ["re24"]
        },
        {
            id: "re24", category: "tot", title: "RE24", full: "Run Expectancy 24",
            short: "状況別の「得点期待値」の増減を示す",
            desc: "24種類の状況（無死一塁など）における得点期待値をどれだけ改善させたかを測る。打点などより文脈を正確に反映する",
            formula: `プレイ後期待値 - プレイ前期待値 + 得点`,
            criteria: "0: 平均",
            related: ["wpa"]
        },
        {
            id: "pythag", category: "tot", title: "Pythagenpat", full: "Pythagorean Expectation",
            short: "得失点から予測される「本来あるべき勝率」",
            desc: "実際の勝率がこれより高いと「運が良い」または「接戦に強い（監督の采配が良い）」とされる。未来の勝率予測に役立つとして重視される",
            formula: `${formatVar('得点')}^x ÷ (${formatVar('得点')}^x + ${formatVar('失点')}^x) <br><small style="font-size:0.7em; color:#94a3b8;">x = (得点+失点)^0.287</small>`,
            criteria: "実際の勝率との乖離を確認",
            inputs: [
                {id:'rs', label:'得点'}, {id:'ra', label:'失点'}
            ],
            calc: (d) => {
                const x = Math.pow((d.rs + d.ra), 0.287);
                return (Math.pow(d.rs, x) / (Math.pow(d.rs, x) + Math.pow(d.ra, x))).toFixed(3);
            }
        },
        {
            id: "pf", category: "tot", title: "PF", full: "Park Factor",
            short: "球場の特性（打者有利/投手有利）を表す数値",
            desc: "1.00が平均。1.00より大きければ打者有利、小さければ投手有利とされる。セイバーメトリクスでは、選手の成績を比較する際にこのPF補正をかけることが常識となっている",
            formula: `(本拠地での本塁打 + 被本塁打) ÷ (敵地での本塁打 + 被本塁打)`,
            criteria: "1.00: 中立 / 1.20: ヒッターズパーク",
            related: ["wrc_plus"]
        },

        /* ---------------- 打撃 (Batting) ---------------- */
        {
            id: "avg", category: "std", title: "AVG", full: "Batting Average",
            short: "打率",
            formula: `${formatVar('安打')} ÷ ${formatVar('打数')}`,
            criteria: ".250: 平均 / .300: 優秀",
            inputs: [{id:'h', label:'安打'}, {id:'ab', label:'打数'}],
            calc: (d) => (d.h / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "obp", category: "std", title: "OBP", full: "On Base Percentage",
            short: "出塁率",
            desc: "打率よりも得点との相関が高いため、セイバーメトリクスでは打率より重視される。四死球を選べる打者は価値が高いと評価される",
            formula: `(${formatVar('安打')} + ${formatVar('四球')} + ${formatVar('死球')}) ÷ (${formatVar('打数')} + ${formatVar('四球')} + ${formatVar('死球')} + ${formatVar('犠飛')})`,
            criteria: ".320: 平均 / .400: 優秀",
            related: ["ops", "isod"],
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}],
            calc: (d) => ((d.h+d.bb+d.hbp)/(d.ab+d.bb+d.hbp+d.sf)).toFixed(3).replace(/^0/,'')
        },
        {
            id: "slg", category: "std", title: "SLG", full: "Slugging Percentage",
            short: "長打率",
            desc: "打率のような名前だが「1打数あたりの期待塁打数」を表す。単打=1、本塁打=4として計算する",
            formula: `${formatVar('塁打')} ÷ ${formatVar('打数')}`,
            criteria: ".400: 平均 / .500: パワーヒッター",
            related: ["ops", "iso"],
            inputs: [{id:'tb', label:'塁打'}, {id:'ab', label:'打数'}],
            calc: (d) => (d.tb / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "ops", category: "std", title: "OPS", full: "On-base Plus Slugging",
            short: "出塁率 + 長打率",
            desc: "計算が簡単でありながら、チームの得点数と非常に高い相関を持つ指標。現在では公式記録としても採用されることが多い",
            formula: `${formatVar('出塁率')} + ${formatVar('長打率')}`,
            criteria: ".730: 平均 / .800: 優秀 / 1.000: 最強",
            related: ["woba", "xr"],
            inputs: [
                {id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, 
                {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}, {id:'tb', label:'塁打'}
            ],
            calc: (d) => {
                const obp = (d.h+d.bb+d.hbp)/(d.ab+d.bb+d.hbp+d.sf);
                const slg = d.tb / d.ab;
                return (obp + slg).toFixed(3).replace(/^0/,'');
            }
        },
        {
            id: "woba", category: "bat", title: "wOBA", full: "weighted On-Base Average",
            short: "各イベントを得点価値で重み付けした「真の出塁率」",
            desc: "OPSの欠点（出塁率を過小評価している点）を修正し、各イベント（単打、本塁打、四球など）が得点にどれだけ貢献したかを係数化して計算する。係数は年度ごとに変動する",
            formula: `(0.69×${formatVar('四球')} + 0.72×${formatVar('死球')} + 0.89×${formatVar('単打')} + 1.27×${formatVar('二塁打')} + 1.62×${formatVar('三塁打')} + 2.10×${formatVar('本塁打')}) ÷ ${formatVar('打席')}`,
            criteria: ".320: 平均 / .400: MVP級",
            related: ["ops", "wrc_plus"],
            inputs: [
                {id:'pa', label:'打席'}, {id:'ab', label:'打数'},
                {id:'s', label:'単打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},

                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio;
                
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;
                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * d.s + 
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;
                    
                return woba_denom > 0 ? (woba_num / woba_denom).toFixed(3).replace(/^0/,'') : "---";
            }
        },
        {
            id: "wraa", category: "bat", title: "wRAA", full: "weighted Runs Above Average",
            short: "平均的な打者より「何点」多く取ったかを示す",
            desc: "積み上げ指標。出場数が多く、かつ打撃成績が良いほど数値が高くなる。WARの打撃構成要素として使われる。<br>式中の<strong>wOBAScale（約1.24）</strong>は、wOBAを出塁率のスケール（.320前後が平均）に合わせるために掛けられていた係数を、得点単位に戻すために割るもの",
            formula: `(${formatVar('wOBA')} - リーグ平均wOBA) ÷ wOBAScale × ${formatVar('打席')}`,
            criteria: "0: 平均 / +20: 一流",
            related: ["war", "woba"]
        },
        {
            id: "iso", category: "bat", title: "ISO", full: "Isolated Power",
            short: "打率を除いた純粋な長打力",
            desc: "長打率から打率を引いて算出する。単打を無視し、二塁打以上を打つ能力のみを評価する",
            formula: `${formatVar('長打率')} - ${formatVar('打率')}`,
            criteria: ".140: 平均 / .250: 強打者",
            inputs: [
                {id:'slg', label:'長打率', default: 0.400}, 
                {id:'avg', label:'打率', default: 0.250}
            ],
            calc: (d) => (d.slg - d.avg).toFixed(3).replace(/^0/,'')
        },
        {
            id: "babip", category: "bat", title: "BABIP", full: "Batting Average on Balls In Play",
            short: "インプレー打球のヒット率（運の指標）",
            desc: "本塁打以外のフェアゾーンに飛んだ打球がヒットになった割合。極端に高い/低い場合は「運」や「守備」の影響が強く、翌年は平均（約.300）に近づく傾向がある",
            formula: `(${formatVar('安打')}-${formatVar('本塁打')}) ÷ (${formatVar('打数')}-${formatVar('三振')}-${formatVar('本塁打')}+${formatVar('犠飛')})`,
            criteria: ".300前後が基準",
            inputs: [{id:'h', label:'安打'}, {id:'hr', label:'本塁打'}, {id:'ab', label:'打数'}, {id:'so', label:'三振'}, {id:'sf', label:'犠飛'}],
            calc: (d) => ((d.h - d.hr) / (d.ab - d.so - d.hr + d.sf)).toFixed(3).replace(/^0/,'')
        },
        {
            id: "bb_k", category: "bat", title: "BB/K", full: "Walk to Strikeout Ratio",
            short: "三振1つに対する四球の数",
            desc: "選球眼とコンタクト能力のバランスを示す。1.0を超えれば非常に優秀な打者とされる",
            formula: `${formatVar('四球')} ÷ ${formatVar('三振')}`,
            criteria: "0.4: 平均 / 1.0以上: 優秀",
            inputs: [{id:'bb', label:'四球'}, {id:'so', label:'三振'}],
            calc: (d) => (d.bb / d.so).toFixed(2)
        },
        {
            id: "k_pct", category: "bat", title: "K%", full: "Strikeout Percentage",
            short: "打席に占める三振の割合",
            desc: "三振が少ないほどコンタクト能力が高いとされるが、現代野球では長打とのトレードオフとしてある程度許容される傾向がある",
            formula: `${formatVar('三振')} ÷ ${formatVar('打席')}`,
            criteria: "20%: 平均 / 10%以下: コンタクト巧者",
            inputs: [{id:'so', label:'三振'}, {id:'pa', label:'打席'}],
            calc: (d) => ((d.so / d.pa) * 100).toFixed(1) + '%'
        },
        {
            id: "bb_pct", category: "bat", title: "BB%", full: "Walk Percentage",
            short: "打席に占める四球の割合",
            desc: "選球眼の良さを示す。打率が低くてもBB%が高い選手は出塁能力が高く、チームへの貢献度は大きいとされる",
            formula: `${formatVar('四球')} ÷ ${formatVar('打席')}`,
            criteria: "8%: 平均 / 10%以上: 選球眼が良い",
            inputs: [{id:'bb', label:'四球'}, {id:'pa', label:'打席'}],
            calc: (d) => ((d.bb / d.pa) * 100).toFixed(1) + '%'
        },
        {
            id: "rc", category: "bat", title: "RC", full: "Runs Created",
            short: "打者が創出した総得点数",
            desc: "ビル・ジェームズが考案した古典的な指標。安打や四球などの出塁能力と、長打力を掛け合わせて得点能力を推定する",
            formula: `(出塁能力A × 進塁能力B) ÷ (打席C)`,
            criteria: "積み上げ型指標",
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'tb', label:'塁打'}, {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}],
            calc: (d) => {
                // Basic RC Formula
                const a = d.h + d.bb;
                const b = d.tb;
                const c = d.ab + d.bb;
                return ((a * b) / c).toFixed(1);
            }
        },
        {
            id: "rc27", category: "bat", title: "RC27", full: "Runs Created per 27 Outs",
            short: "この打者9人で打線を組んだ時の1試合予想得点",
            desc: "RCを27アウト（1試合分）に換算したもの。打者の得点能力を直感的に理解しやすい",
            formula: `RC ÷ (${formatVar('打数')}-${formatVar('安打')}+${formatVar('盗塁死')}+${formatVar('併殺')}+${formatVar('犠打')}+${formatVar('犠飛')}) × 27`,
            criteria: "4.5点: 平均",
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'tb', label:'塁打'}, {id:'ab', label:'打数'}],
            calc: (d) => {
                const rc = ((d.h + d.bb) * d.tb) / (d.ab + d.bb);
                const outs = d.ab - d.h; 
                return (rc / outs * 27).toFixed(2);
            }
        },
        {
            id: "xr", category: "bat", title: "XR", full: "Extrapolated Runs",
            short: "各プレーに得点価値係数を掛けて算出する得点力",
            desc: "RCと似ているが、より各イベント（単打0.5点、本塁打1.44点など）の得点貢献を線形的に足し合わせて評価する、日本で人気の指標",
            formula: `0.5×${formatVar('単打')} + 0.72×${formatVar('二塁打')} + 1.44×${formatVar('HR')} + 0.34×(${formatVar('四球')}+${formatVar('死球')})...`,
            criteria: "RC27と同様に評価可能",
            related: ["rc27"],
            inputs: [{id:'s', label:'単打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, {id:'bb', label:'四死球'}],
            calc: (d) => (0.5*d.s + 0.72*d.d + 1.04*d.t + 1.44*d.hr + 0.34*d.bb).toFixed(1)
        },
        {
            id: "ab_hr", category: "bat", title: "AB/HR", full: "At Bats per Home Run",
            short: "HR1本打つのにかかる打数",
            formula: `${formatVar('打数')} ÷ ${formatVar('本塁打')}`,
            criteria: "20.0以下: 本塁打打者",
            inputs: [{id:'ab', label:'打数'}, {id:'hr', label:'本塁打'}],
            calc: (d) => (d.ab / d.hr).toFixed(1)
        },
        {
            id: "pa_bb", category: "bat", title: "PA/BB", full: "Plate Appearances per Walk",
            short: "四球を1つ選ぶのにかかる打席数",
            formula: `${formatVar('打席')} ÷ ${formatVar('四球')}`,
            inputs: [{id:'pa', label:'打席'}, {id:'bb', label:'四球'}],
            calc: (d) => (d.pa / d.bb).toFixed(1)
        },
        {
            id: "isod", category: "bat", title: "IsoD", full: "Isolated Discipline",
            short: "四死球による出塁能力",
            desc: "出塁率から打率を引いて算出する。選球眼の良さを示す",
            formula: `${formatVar('出塁率')} - ${formatVar('打率')}`,
            criteria: "0.06: 平均 / 0.10: 選球眼良",
            inputs: [{id:'obp', label:'出塁率'}, {id:'avg', label:'打率'}],
            calc: (d) => (d.obp - d.avg).toFixed(3).replace(/^0/,'')
        },
        {
            id: "gpa", category: "bat", title: "GPA", full: "Gross Production Average",
            short: "OPSより打率に近い感覚で評価できる指標",
            desc: "OPSは出塁率を過小評価する傾向があるため、出塁率に1.8倍の重みをかけてバランスを取り、さらに打率のようなスケールに変換したもの",
            formula: `(1.8 × ${formatVar('出塁率')} + ${formatVar('長打率')}) ÷ 4`,
            criteria: ".250: 平均",
            inputs: [{id:'obp', label:'出塁率'}, {id:'slg', label:'長打率'}],
            calc: (d) => ((1.8 * d.obp + d.slg) / 4).toFixed(3).replace(/^0/,'')
        },
        {
            id: "seca", category: "bat", title: "SecA", full: "Secondary Average",
            short: "打率以外の要素（四球、長打、盗塁）での貢献度",
            desc: "ビル・ジェームズ考案。「打率」に含まれない攻撃力を測る",
            formula: `(${formatVar('塁打')}-${formatVar('安打')} + ${formatVar('四球')} + ${formatVar('盗塁')} - ${formatVar('盗塁死')}) ÷ ${formatVar('打数')}`,
            criteria: ".250: 平均 / .400: 超優秀",
            inputs: [{id:'tb', label:'塁打'}, {id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}, {id:'ab', label:'打数'}],
            calc: (d) => ((d.tb - d.h + d.bb + d.sb - d.cs) / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "noi", category: "bat", title: "NOI", full: "New Offensive Index",
            short: "出塁率＋長打率÷3",
            desc: "OPSの簡易修正版。出塁率の価値を長打率の3倍と見積もって計算する。日本独自の指標",
            formula: `(${formatVar('出塁率')} + ${formatVar('長打率')} ÷ 3) × 1000`,
            criteria: "450: 平均 / 550: 優秀",
            inputs: [{id:'obp', label:'出塁率'}, {id:'slg', label:'長打率'}],
            calc: (d) => ((d.obp + d.slg / 3) * 1000).toFixed(0)
        },
        
        /* ---------------- 投球 (Pitching) ---------------- */
        {
            id: "era", category: "std", title: "ERA", full: "Earned Run Average",
            short: "防御率",
            formula: `${formatVar('自責点')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "3.00: 平均",
            inputs: [{id:'er', label:'自責点'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.er * 9 / d.ip).toFixed(2)
        },
        {
            id: "whip", category: "std", title: "WHIP", full: "Walks plus Hits per Inning Pitched",
            short: "1回あたりに出したランナーの数",
            formula: `(${formatVar('被安打')} + ${formatVar('与四球')}) ÷ ${formatVar('投球回')}`,
            criteria: "1.30: 平均 / 1.00未満: エース",
            inputs: [{id:'h', label:'被安打'}, {id:'bb', label:'与四球'}, {id:'ip', label:'投球回'}],
            calc: (d) => ((d.h + d.bb) / d.ip).toFixed(2)
        },
        {
            id: "fip", category: "pit", title: "FIP", full: "Fielding Independent Pitching",
            short: "守備の影響を除外した「真の防御率」",
            desc: "投手の責任である三振・四球・被本塁打のみで評価する。防御率よりも将来の成績予測に役立つ",
            formula: `(13×${formatVar('本塁打')} + 3×(${formatVar('四球')}+${formatVar('死球')}) - 2×${formatVar('三振')}) ÷ ${formatVar('投球回')} + 3.10`,
            criteria: "防御率スケール",
            inputs: [{id:'hr', label:'被本塁打'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'so', label:'奪三振'}, {id:'ip', label:'投球回'}],
            calc: (d) => ((13*d.hr + 3*(d.bb+d.hbp) - 2*d.so)/d.ip + 3.10).toFixed(2)
        },
        {
            id: "xfip", category: "pit", title: "xFIP", full: "Expected FIP",
            short: "被本塁打の代わりに「フライボール数」を用いたFIPの進化版",
            desc: "HR/FB（フライに対する本塁打の割合）をリーグ平均値に置き換えて計算する。被本塁打の運要素を排除し、より純粋な実力を測る。<br>※選択された打球傾向（ゴロ率）からフライ数を自動推定して計算する",
            formula: `(13 × (FB × LgHR/LgFB) + 3 × (BB - IBB + HBP) - 2 × SO) ÷ IP + 定数`,
            criteria: "防御率スケール",
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'},
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // 打球内訳を推定
                estimateBattedBalls(d);
                
                const C = calcDerived(d);
                const est_ibb = d.bb * 0.04;
                
                // d.fb は estimateBattedBalls で生成されている
                const term1 = 13 * C.lg_xfip_ratio * d.fb;
                const term2 = 3 * (d.bb - est_ibb + d.hbp);
                const term3 = 2 * d.so;
                
                // xFIP = (13 * lg_xfip_ratio * FB + 3 * (BB - IBB + HBP) - 2 * SO) / IP + xfip_constant
                const val = (term1 + term2 - term3) / d.ip + C.xfip_constant;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "siera", category: "pit", title: "SIERA", full: "Skill-Interactive Earned Run Average",
            short: "打球の質や三振・四球を考慮した、FIPより精度の高い指標",
            desc: "投球の「質」を最も正確に反映するとされる指標。ゴロ率や三振、四球のバランスから算出される。<br>※選択された打球傾向から打球内訳（ゴロ・フライ等）を自動推定して計算する",
            // formula: `6.145 - 16.99(SO/PA) + 11.43(BB/PA) - 1.86((GB-FB-PU)/PA) + ...`,
            formula: `6.145 - 16.99(SO/PA) + 11.43(BB/PA) - 1.86((GB-FB-PU)/PA) + 7.65((SO/PA)²) - 6.66(((GB-FB-PU)/PA)²) + 10.13(SO/PA)((GB-FB-PU)/PA) - 5.20(BB/PA)((GB-FB-PU)/PA)`,
            criteria: "失点率スケール (3.00: 優秀)",
            related: ["fip", "xfip", "tra"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, 
                {id:'hr', label:'被本塁打'}, // 必須項目に変更
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                {id:'bf', label:'打者数'}, // 必須項目に変更
                
                // --- 統一された詳細設定の追加 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // 打球内訳を推定
                estimateBattedBalls(d);

                const pa = d.bf;
                // ゼロ除算防止 (打者数(bf)が0の場合は計算不可)
                if (!pa || pa === 0) return "---";

                // SIERA計算 (Updated Formula)
                // SIERA = 6.145 – 16.986*(SO/PA) + 11.434*(BB/PA) – 1.858*((GB-FB-PU)/PA) 
                //       + 7.653*((SO/PA)^2) - 6.664*(((GB-FB-PU)/PA)^2)
                //       + 10.130*(SO/PA)*((GB-FB-PU)/PA) – 5.195*(BB/PA)*((GB-FB-PU)/PA)
                
                const A = d.so / pa;
                const B = d.bb / pa;
                const C_val = (d.gb - d.fb - d.pu) / pa;
                
                const val = 6.145 
                    - 16.986 * A 
                    + 11.434 * B 
                    - 1.858 * C_val 
                    + 7.653 * (A * A) 
                    - 6.664 * (C_val * C_val) 
                    + 10.130 * A * C_val 
                    - 5.195 * B * C_val;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "tra", category: "pit", title: "tRA", full: "True Runs Allowed",
            short: "打球の種類（ゴロ・フライなど）も考慮した指標",
            desc: "FIPを発展させ、各打球種別（ライナー、ゴロ、フライ）の期待失点値を割り当てて算出する指標。<br>※打球傾向から打球数を推定して計算する",
            formula: `( (0.297×BB + 0.327×HBP - 0.108×SO + 1.401×HR + 0.036×GB - 0.124×PU + 0.132×FB + 0.289×LD) ÷ (SO + 0.745×GB + 0.304×LD + 0.994×PU + 0.675×FB) × 27 ) + 定数`,
            criteria: "失点率スケール",
            related: ["fip"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'hr', label:'被HR'},
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                estimateBattedBalls(d);
                const C = calcDerived(d);
                
                // tRA計算 (Updated Formula)
                const numerator = 
                    0.297 * d.bb + 
                    0.327 * d.hbp - 
                    0.108 * d.so + 
                    1.401 * d.hr + 
                    0.036 * d.gb - 
                    0.124 * d.pu + 
                    0.132 * d.fb + 
                    0.289 * d.ld;
                    
                const denominator = 
                    d.so + 
                    0.745 * d.gb + 
                    0.304 * d.ld + 
                    0.994 * d.pu + 
                    0.675 * d.fb;
                
                if (denominator === 0) return "---";

                // tRA Raw (Base value)
                const tra_raw = (numerator / denominator) * 27;
                
                // 定数加算 (リーグRA9に合わせる補正)
                const val = tra_raw + C.tra_constant;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "k_9", category: "pit", title: "K/9", full: "Strikeouts per 9",
            short: "奪三振率",
            formula: `${formatVar('奪三振')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "7.0: 平均 / 9.0: ドクターK",
            inputs: [{id:'so', label:'奪三振'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.so * 9 / d.ip).toFixed(2)
        },
        {
            id: "bb_9", category: "pit", title: "BB/9", full: "Walks per 9",
            short: "与四球率",
            formula: `${formatVar('与四球')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "3.0: 平均 / 2.0以下: 制球良",
            inputs: [{id:'bb', label:'与四球'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.bb * 9 / d.ip).toFixed(2)
        },
        {
            id: "k_pct_pit", category: "pit", title: "K%", full: "Strikeout Percentage (Pitcher)",
            short: "対戦打者に占める奪三振の割合",
            desc: "奪三振率(K/9)よりも投球回数に依存せず、投手の支配力を正確に表す指標",
            formula: `${formatVar('奪三振')} ÷ ${formatVar('打者数')}`,
            criteria: "20%: 平均 / 30%: 優秀",
            inputs: [{id:'so', label:'奪三振'}, {id:'bf', label:'打者数'}],
            calc: (d) => ((d.so / d.bf) * 100).toFixed(1) + '%'
        },
        {
            id: "bb_pct_pit", category: "pit", title: "BB%", full: "Walk Percentage (Pitcher)",
            short: "対戦打者に占める与四球の割合",
            desc: "与四球率(BB/9)よりも投球回数に依存せず、制球力を正確に表す指標",
            formula: `${formatVar('与四球')} ÷ ${formatVar('打者数')}`,
            criteria: "8%: 平均 / 5%以下: 優秀",
            inputs: [{id:'bb', label:'与四球'}, {id:'bf', label:'打者数'}],
            calc: (d) => ((d.bb / d.bf) * 100).toFixed(1) + '%'
        },
        {
            id: "k_bb_pit", category: "pit", title: "K/BB", full: "K-to-BB Ratio",
            short: "奪三振と与四球の比率",
            desc: "投手の完成度・安定感を示す重要指標。3.5を超えると非常に優秀とされる",
            formula: `${formatVar('奪三振')} ÷ ${formatVar('与四球')}`,
            criteria: "2.5: 平均 / 4.0: 非常に優秀",
            inputs: [{id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}],
            calc: (d) => (d.so / d.bb).toFixed(2)
        },
        {
            id: "gb_pct", category: "pit", title: "GB%", full: "Ground Ball Percentage (Est)",
            short: "打球傾向設定に基づく推定ゴロ率",
            desc: "選択された打球傾向設定から算出されたゴロ率を表示する",
            formula: `推定値`,
            criteria: "45%: 平均 / 50%超: ゴロP",
            aiMode: true,
            inputs: [
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }}
            ],
            calc: (d) => d.gb_type ? d.gb_type + '%' : "45%"
        },
        {
            id: "fb_pct", category: "pit", title: "FB%", full: "Fly Ball Percentage (Est)",
            short: "打球傾向設定に基づく推定フライ率",
            desc: "選択された打球傾向設定から算出されたフライ率（内野フライ含む）を表示する",
            formula: `推定値`,
            criteria: "35%: 平均",
            aiMode: true,
            inputs: [
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }}
            ],
            calc: (d) => {
                const gb = parseFloat(d.gb_type || 45);
                // LD 21%固定と仮定した場合の残り
                const fb = 100 - gb - 21;
                return fb + '%';
            }
        },

        /* ---------------- 守備 (Fielding) ---------------- */
        {
            id: "uzr", category: "fld", title: "UZR", full: "Ultimate Zone Rating",
            short: "守備による失点防止量（平均比）",
            desc: "1.02などで採用される守備指標のスタンダード。グラウンドをゾーンに分割し、打球ごとの処理難易度に応じて貢献度を算出する",
            formula: "加点方式",
            criteria: "0: 平均 / +15: ゴールドグラブ",
            // 入力された守備評価(def)をそのまま返す簡易実装
            inputs: [{id:'def', label:'守備評価'}], 
            calc: (d) => d.def ? parseFloat(d.def).toFixed(1) : "---"
        },
        {
            id: "der", category: "fld", title: "DER", full: "Defensive Efficiency Ratio",
            short: "本塁打以外のインプレー打球をアウトにした割合",
            desc: "チーム全体の守備力を測る指標。BABIPの逆数に近い概念",
            formula: `1 - ((${formatVar('被安打')} - ${formatVar('被HR')}) ÷ (${formatVar('打者')} - ${formatVar('三振')} - ${formatVar('四球')} - ${formatVar('死球')} - ${formatVar('被HR')}))`,
            criteria: ".700前後が平均",
            inputs: [{id:'h', label:'被安打'}, {id:'hr', label:'被HR'}, {id:'bf', label:'打者数'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}],
            calc: (d) => (1 - ((d.h - d.hr) / (d.bf - d.so - d.bb - d.hbp - d.hr))).toFixed(3).replace(/^0/,'')
        },
        {
            id: "drs", category: "fld", title: "DRS", full: "Defensive Runs Saved",
            short: "UZRと並ぶ守備指標の決定版",
            desc: "UZRと同様のコンセプトだが、測定方法が異なる。MLBではUZRと共にゴールドグラブ賞の選考基準となる",
            formula: "加点方式",
            criteria: "+15以上: 最高レベル"
        },
        {
            id: "rf", category: "fld", title: "RF", full: "Range Factor",
            short: "1試合あたりに関与したアウトの数",
            desc: "守備範囲の広さを示すとされる指標だが、投手の奪三振能力などに影響を受けるため、UZRなどより精度は低い",
            formula: `(${formatVar('刺殺')}+${formatVar('補殺')}) ÷ ${formatVar('守備回')} × 9`,
            inputs: [{id:'po', label:'刺殺'}, {id:'a', label:'補殺'}, {id:'inn', label:'守備回'}],
            calc: (d) => ((d.po + d.a) / d.inn * 9).toFixed(2)
        },
        {
            id: "fp", category: "fld", title: "FP%", full: "Fielding Percentage",
            short: "守備率",
            desc: "失策をしなかった割合。守備範囲の広さは考慮されないため、現代のセイバーメトリクスでは重要視されない",
            formula: `(${formatVar('刺殺')}+${formatVar('補殺')}) ÷ (${formatVar('刺殺')}+${formatVar('補殺')}+${formatVar('失策')})`,
            inputs: [{id:'po', label:'刺殺'}, {id:'a', label:'補殺'}, {id:'e', label:'失策'}],
            calc: (d) => ((d.po + d.a)/(d.po + d.a + d.e)).toFixed(3).replace(/^0/,'')
        },

        /* ---------------- 走塁 (Running) ---------------- */
        {
            id: "wsb", category: "fld", title: "wSB", full: "weighted Stolen Base Runs",
            short: "盗塁による得点貢献",
            desc: "盗塁成功によるプラスと、盗塁死によるマイナス（成功よりペナルティが大きい）を合算したもの",
            formula: `0.2×${formatVar('盗塁')} - 0.4×${formatVar('盗塁死')}`,
            desc: "係数は概算値。盗塁死のマイナスは成功のプラスより大きいとされる",
            inputs: [{id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}],
            calc: (d) => (0.2*d.sb - 0.4*d.cs).toFixed(1)
        },
        {
            id: "sb_pct", category: "fld", title: "SB%", full: "Stolen Base Percentage",
            short: "盗塁成功率",
            formula: `${formatVar('盗塁')} ÷ (${formatVar('盗塁')} + ${formatVar('盗塁死')})`,
            criteria: "70%以上が損益分岐点",
            inputs: [{id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}],
            calc: (d) => ((d.sb / (d.sb + d.cs)) * 100).toFixed(1) + '%'
        },

        /* ---------------- その他 ---------------- */
        {
            id: "p_ip", category: "pit", title: "P/IP", full: "Pitches per Inning",
            short: "1イニングあたりの投球数",
            formula: `${formatVar('投球数')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "15球以下: 省エネ",
            inputs: [{id:'np', label:'球数'}, {id:'ip', label:'投球回'}],
            calc: (d) => d.np > 0 ? (d.np / d.ip).toFixed(1) : "---"
        },
        {
            id: "rsaa", category: "pit", title: "RSAA", full: "Runs Saved Above Average",
            short: "平均的な投手に比べて、どれだけ失点を防いだかを示す",
            desc: "防御率と投球回を基に算出する積み上げ系指標。WARの投球版の簡易計算に使われることがある",
            formula: `(リーグ平均防御率 - ${formatVar('防御率')}) × ${formatVar('投球回')} ÷ 9`,
            criteria: "プラスなら平均以上",
            inputs: [
                {id:'er', label:'自責点'}, 
                {id:'ip', label:'投球回'},
                // リーグ平均防御率の代わりに、詳細設定から推定できるようにする
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // ERAを計算 (入力がない場合は自責点から計算)
                const my_era = d.er ? (d.er * 9 / d.ip) : 0;
                
                // リーグ平均防御率を詳細設定から推定
                const C = calcDerived(d);
                const lg_era = C.lg_era_est;
                
                return ((lg_era - my_era) * d.ip / 9).toFixed(1);
            }
        }
    ];
    // --- End Terms Database ---


    // --- Application Logic ---
    const grid = document.getElementById('grid');
    const modal = document.getElementById('modal');
    const modalTitleArea = document.getElementById('modal-title-area');
    const modalBodyContent = document.getElementById('modal-body-content');
    const searchInput = document.getElementById('searchInput');
    const filterChips = document.querySelectorAll('.filter-chip');
    const themeToggleBtn = document.getElementById('themeToggle');
    // 追加: 検索アイコンの要素
    const searchIconEl = document.getElementById('searchIcon');
    
    let currentFilter = 'all';
    let currentSearch = '';
    let currentTermId = null; 

    // Dark Mode Toggle Function
    function toggleTheme() {
        document.body.classList.toggle('dark-mode');
        // 修正: アイコンを動的に更新
        if (document.body.classList.contains('dark-mode')) {
            themeToggleBtn.innerHTML = icons.sun;
            themeToggleBtn.title = "Light Mode";
            localStorage.setItem('theme', 'dark');
        } else {
            themeToggleBtn.innerHTML = icons.moon;
            themeToggleBtn.title = "Dark Mode";
            localStorage.setItem('theme', 'light');
        }
    }
    
    // Initial theme check & icon setup
    (function() {
        // 1. 検索アイコンの設定
        if (searchIconEl) {
            searchIconEl.innerHTML = icons.search;
        }

        // 2. テーマ設定とアイコンの設定
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode');
            themeToggleBtn.innerHTML = icons.sun;
            themeToggleBtn.title = "Light Mode";
        } else {
             themeToggleBtn.innerHTML = icons.moon;
             themeToggleBtn.title = "Dark Mode";
        }
    })();


    function render() {
        grid.innerHTML = '';
        
        const filtered = terms.filter(term => {
            const catMatch = currentFilter === 'all' || term.category === currentFilter;
            const searchLower = currentSearch.toLowerCase();
            const searchMatch = !currentSearch || 
                term.title.toLowerCase().includes(searchLower) || 
                term.full.toLowerCase().includes(searchLower) ||
                term.short.includes(currentSearch) ||
                (term.desc && term.desc.includes(currentSearch));
            return catMatch && searchMatch;
        });

        if(filtered.length === 0) {
            grid.innerHTML = '<div class="no-result">一致する用語が見つかりませんでした。</div>';
            return;
        }

        filtered.forEach(term => {
            const el = document.createElement('div');
            el.className = `metric-card cat-${term.category}`;
            el.onclick = () => openModal(term.id);
            
            let catLabel = getCatLabel(term.category);
            
            // アイコンをSVGに置き換え
            let iconSvg = icons.calculator;
            if(term.aiMode) {
                iconSvg = icons.barChart;
            }
            const hasCalc = term.inputs ? `<span class="calc-icon ${term.aiMode ? 'ai' : ''}" title="${term.aiMode ? '推定' : '計算可能'}">${iconSvg}</span>` : '';
            
            el.innerHTML = `
                <div class="card-header">
                    <span class="card-tag">${catLabel}</span>
                    ${hasCalc}
                </div>
                <h3 class="metric-title">${term.title}</h3>
                <div class="metric-full">${term.full}</div>
                <p class="metric-desc">${term.short}</p>
            `;
            grid.appendChild(el);
        });
    }

    function getCatLabel(cat) {
        switch(cat){
            case 'bat': return "Batting";
            case 'pit': return "Pitching";
            case 'fld': return "Fielding";
            case 'tot': return "Overall";
            case 'std': return "Basic";
            default: return "";
        }
    }
    
    function getCatColor(cat) {
        switch(cat){
            case 'bat': return "#0ea5e9";
            case 'pit': return "#f43f5e";
            case 'fld': return "#d97706";
            case 'tot': return "#10b981";
            case 'std': return "#6366f1";
            default: return "#64748b";
        }
    }

    function handleSearch() {
        currentSearch = searchInput.value;
        render();
    }

    function filterCategory(cat) {
        currentFilter = cat;
        filterChips.forEach(chip => {
            if(chip.dataset.cat === cat) chip.classList.add('active');
            else chip.classList.remove('active');
        });
        render();
    }

    function createInputHtml(inp) {
        if(inp.type === 'select') {
            const opts = Object.keys(inp.options).map(k => `<option value="${k}">${inp.options[k]}</option>`).join('');
            return `
                <div class="calc-group">
                    <label class="calc-label">${inp.label}</label>
                    <select class="calc-select" id="calc-${inp.id}">
                        ${opts}
                    </select>
                </div>
            `;
        } else {
            // Handle default value if present
            // 修正: デフォルト値が0の場合はvalue属性に入れない（空欄にしてプレースホルダーを表示）
            let val = '';
            if (inp.default !== undefined) {
                val = inp.default === 0 ? '' : inp.default;
            }
            
            const advClass = inp.advanced ? 'advanced-input' : '';
            return `
                <div class="calc-group">
                    <label class="calc-label">${inp.label}</label>
                    <input type="number" class="calc-field ${advClass}" id="calc-${inp.id}" placeholder="0" value="${val}" ${inp.advanced ? 'oninput="checkAdvancedChanges()"' : ''}>
                </div>
            `;
        }
    }

    function openModal(id) {
        currentTermId = id; // Set current term ID
        const term = terms.find(t => t.id === id);
        if(!term) return;

        // Build Related HTML
        let relatedHtml = '';
        if(term.related && term.related.length > 0) {
            term.related.forEach(rid => {
                const rTerm = terms.find(t => t.id === rid);
                if(rTerm) {
                    relatedHtml += `<div class="rel-chip" onclick="event.stopPropagation(); openModal('${rid}')">${rTerm.title}</div>`;
                }
            });
        }

        // Build Calculator HTML if inputs exist
        let calcHtml = '';
        if(term.inputs && term.calc) {
            const basicInputs = [];
            const advancedInputs = [];

            term.inputs.forEach(inp => {
                if (inp.advanced) {
                    advancedInputs.push(inp);
                } else {
                    basicInputs.push(inp);
                }
            });

            const basicInputsHtml = basicInputs.map(inp => createInputHtml(inp)).join('');
            
            let advancedSectionHtml = '';
            if (advancedInputs.length > 0) {
                const advInputsHtml = advancedInputs.map(inp => createInputHtml(inp)).join('');
                advancedSectionHtml = `
                    <details class="advanced-details">
                        <summary class="advanced-summary">
                            <span class="icon-gear">${icons.gear}</span>
                            詳細設定 (リーグ平均値など)
                        </summary>
                        <div class="advanced-content">
                            ${advInputsHtml}
                        </div>
                        <div id="warning-box" class="warning-msg" style="display:none;">
                            詳細設定を変更すると精度が落ちる可能性があります
                        </div>
                    </details>
                `;
            }

            const aiClass = term.aiMode ? 'ai-mode' : '';
            const aiIcon = term.aiMode ? icons.barChart : icons.calculator;
            const aiText = term.aiMode ? '推定を実行' : 'CALCULATE';
            const titleText = term.aiMode ? 'ESTIMATOR' : 'SIMULATOR';
            const calcBtnIcon = term.aiMode ? icons.barChart : icons.calculator;
            const delIcon = icons.trash;
            const saveIcon = icons.save;

            // 見出しの句点を削除
            calcHtml = `
                <div class="section-label has-hash">LABORATORY / ${aiText}</div>
                <div class="calc-container ${aiClass}" id="calc-container">
                    <div class="calc-title">
                        <div><span>${aiIcon}</span> ${term.title} ${titleText}</div>
                    </div>
                    
                    <!-- Preset Controls -->
                    <div class="preset-bar">
                        <div class="preset-label">${saveIcon} 成績プリセット (自動入力)</div>
                        <select class="preset-select" id="preset-select">
                            <option value="">保存データを選択...</option>
                        </select>
                        <button type="button" class="preset-btn btn-load" onclick="loadPreset()">読込</button>
                        <button type="button" class="preset-btn btn-del" onclick="removePreset()" title="削除">${delIcon}</button>
                        <div style="flex-basis: 100%; height: 0; margin: 0;"></div> <!-- Line break for visual -->
                        <input type="text" class="preset-input" id="preset-name" placeholder="新規保存名 (例: 2024山田)">
                        <button type="button" class="preset-btn btn-save" onclick="savePreset()">保存</button>
                    </div>

                    <div class="calc-inputs">
                        ${basicInputsHtml}
                        ${advancedSectionHtml}
                    </div>
                    <button class="calc-btn" onclick="calculateMetric('${term.id}')">
                        ${calcBtnIcon} ${aiText}
                    </button>
                    <div class="calc-result-area">
                        <div class="calc-res-label">RESULT ${term.aiMode ? '<span>推定値</span>' : ''}:</div>
                        <div class="calc-res-value" id="calc-result">---</div>
                    </div>
                </div>
            `;
        }

        const catLabel = getCatLabel(term.category);
        const catColor = getCatColor(term.category);

        // Header
        modalTitleArea.innerHTML = `
            <div class="m-cat" style="color:${catColor}">${catLabel}</div>
            <h2 class="m-title">${term.title}</h2>
            <div class="m-full">${term.full}</div>
        `;

        // Body
        modalBodyContent.innerHTML = `
            <p style="font-size:1.2rem; font-weight:700; line-height:1.6; color:var(--c-text-primary);">${term.short}</p>
            ${term.desc ? `<p style="color:var(--c-text-secondary); line-height:1.8;">${term.desc}</p>` : ''}

            <div class="section-label has-hash">計算式 / FORMULA</div>
            <div class="formula-box">${term.formula}</div>

            ${calcHtml}

            <div class="section-label has-hash">評価基準 / CRITERIA</div>
            <table class="criteria-table">
                <tr><th>目安</th><td>${term.criteria || '---'}</td></tr>
            </table>

            <div class="section-label has-hash">関連指標 / RELATED</div>
            <div class="related-grid">${relatedHtml || '<span style="color:#94a3b8; font-size:0.9rem">なし</span>'}</div>
        `;

        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });

        // Initialize Preset List
        updatePresetList();
    }

    // Logic to check advanced inputs
    window.checkAdvancedChanges = function() {
        const warningBox = document.getElementById('warning-box');
        if (!warningBox) return;

        const advInputs = document.querySelectorAll('.advanced-input');
        let isChanged = false;

        advInputs.forEach(input => {
            const key = input.id.replace('calc-', '').toUpperCase();
            const defVal = DEFAULTS[key];
            if (defVal !== undefined && parseFloat(input.value) !== defVal) {
                isChanged = true;
            }
        });

        warningBox.style.display = isChanged ? 'flex' : 'none';
    }

    // Calculation Function
    window.calculateMetric = function(id) {
        const term = terms.find(t => t.id === id);
        if(!term || !term.inputs) return;

        const data = {};
        let allFilled = true;
        
        term.inputs.forEach(inp => {
            const el = document.getElementById(`calc-${inp.id}`);
            const val = el.value;
            
            // 必須入力のチェック (select以外でadvanced:trueが設定されていないもの)
            const isBasicRequired = inp.type !== 'select' && !inp.advanced;
            if (isBasicRequired && val === '') {
                allFilled = false;
            }
            
            if(inp.type === 'select') {
                data[inp.id] = val;
            } else {
                data[inp.id] = parseFloat(val) || 0;
            }
        });

        if(!allFilled && !confirm("未入力の必須項目は0として計算しますか？")) return;

        const result = term.calc(data);
        
        const resDiv = document.getElementById('calc-result');
        resDiv.style.opacity = 0;
        resDiv.style.transform = "translateY(10px)";
        setTimeout(() => {
            resDiv.innerHTML = result;
            resDiv.style.transition = "all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)";
            resDiv.style.opacity = 1;
            resDiv.style.transform = "translateY(0)";
        }, 50);
    }

    function closeModal() {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }

    function closeModalOutside(e) {
        if (e.target === modal) closeModal();
    }

    /* --- Batch Calculator Logic --- */
    function openBatchCalc(mode) {
        const isBat = mode === 'bat';
        const title = isBat ? "野手指標 一括計算" : "投手指標 一括計算";
        const catColor = isBat ? getCatColor('bat') : getCatColor('pit');
        
        // Define input fields for batch mode
        let fields = [];
        if (isBat) {
            fields = [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'},
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'so', label:'三振'},
                {id:'sf', label:'犠飛'}, {id:'sh', label:'犠打'},
                {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'pos', label:'守備位置', type:'select', options:{'dh':'DH', '1b':'一塁', 'lf':'左翼', 'rf':'右翼', '3b':'三塁', '2b':'二塁', 'cf':'中堅', 'ss':'遊撃', 'c':'捕手'}},
                {id:'def', label:'守備評価', type:'select', options:{'0':'平均的 (0)', '5':'上手い (+5)', '10':'名手 (+10)', '15':'神 (+15)', '-5':'苦手 (-5)', '-10':'下手 (-10)'}}
            ];
        } else {
            fields = [
                {id:'ip', label:'投球回'}, {id:'r', label:'失点'},
                {id:'h', label:'被安打'}, {id:'hr', label:'被本塁打'}, 
                {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'},
                {id:'so', label:'奪三振'}, {id:'bf', label:'打者数'}, // 追加: K%, BB%用
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'role', label:'役割', type:'select', options:{'sp':'先発', 'rp':'救援'}}
            ];
        }

        // Generate HTML
        const inputsHtml = fields.map(inp => createInputHtml(inp)).join('');
        
        // Generate Advanced Settings (Unified)
        const advInputsHtml = ADVANCED_LEAGUE_INPUTS.map(inp => createInputHtml(inp)).join('');

        // Smart Parser HTML (Text Only AI)
        const parserHtml = `
            <div class="parser-area" style="border-color:${catColor}">
                <div style="font-size:0.8rem; font-weight:700; color:var(--c-text-secondary); margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                    <span>${icons.sparkle} AIテキスト解析 (AI ANALYZER)</span>
                    <span style="font-size:0.7em; background:#e2e8f0; padding:2px 6px; border-radius:4px;">TEXT MODE</span>
                </div>
                <textarea class="parser-textarea" id="smart-text" placeholder="ここにWebサイトの成績表などをコピー＆ペーストしてください...&#13;&#10;（例：打率.300 試合143 本塁打20...）"></textarea>
                
                <button class="parser-btn" id="parser-btn" onclick="parseSmartContent('${mode}')" style="background:${catColor}">
                    <span>${icons.sparkle}</span> AIでテキストを解析して入力
                </button>
                <div id="parser-msg" style="font-size:0.85rem; color:var(--c-text-secondary); margin-top:10px; text-align:center; display:none; line-height:1.5;"></div>
            </div>
        `;

        const saveIcon = icons.save;
        const delIcon = icons.trash;
        const gearIcon = icons.gear;

        const html = `
            <div class="section-label has-hash">INPUT DATA / データ入力</div>
            <div class="calc-container" style="border-color:${catColor}">
                
                ${parserHtml}

                <!-- Preset Controls -->
                <div class="preset-bar">
                    <div class="preset-label">${saveIcon} 成績プリセット (自動入力)</div>
                    <select class="preset-select" id="preset-select">
                        <option value="">保存データを選択...</option>
                    </select>
                    <button type="button" class="preset-btn btn-load" onclick="loadPreset()">読込</button>
                    <button type="button" class="preset-btn btn-del" onclick="removePreset()" title="削除">${delIcon}</button>
                    <div style="flex-basis: 100%; height: 0; margin: 0;"></div> <!-- Line break for visual -->
                    <input type="text" class="preset-input" id="preset-name" placeholder="新規保存名 (例: 2024山田)">
                    <button type="button" class="preset-btn btn-save" onclick="savePreset()">保存</button>
                </div>

                <div class="calc-inputs">
                    ${inputsHtml}
                    <details class="advanced-details">
                        <summary class="advanced-summary">
                            <span class="icon-gear">${gearIcon}</span>
                            詳細設定 (リーグ平均値など)
                        </summary>
                        <div class="advanced-content">
                            ${advInputsHtml}
                        </div>
                    </details>
                </div>
                <button class="calc-btn" style="background:${catColor}" onclick="runBatchCalc('${mode}')">
                    ${icons.barChart} 一括計算実行 (CALCULATE ALL)
                </button>
            </div>
            <div id="batch-results-area" style="margin-top:30px;"></div>
        `;

        modalTitleArea.innerHTML = `
            <div class="m-cat" style="color:${catColor}">BATCH CALCULATOR</div>
            <h2 class="m-title">${title}</h2>
        `;
        modalBodyContent.innerHTML = html;
        
        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
        
        updatePresetList();
    }

    // --- Smart Text Parser Logic ---
    window.parseSmartContent = function(mode) {
        const textInput = document.getElementById('smart-text');
        const btn = document.getElementById('parser-btn');
        const msg = document.getElementById('parser-msg');

        const text = textInput.value.trim();

        if (!text) {
            // alert("テキストを入力してください"); // 警告をカスタムメッセージに変更
            msg.style.display = 'block';
            msg.innerHTML = `<div style="color:#ef4444;">❌ テキストを入力してください。</div>`;
            return;
        }

        // AI分析演出
        btn.innerHTML = `${icons.loader} テキスト構造を解析中...`;
        btn.classList.add('analyzing');
        msg.style.display = 'none';

        setTimeout(() => {
            // 解析実行
            btn.innerHTML = `${icons.sparkle} AIでテキストを解析して入力`;
            btn.classList.remove('analyzing');
            
            runParser(text, mode);
            
        }, 800); // 演出用のウェイト
    };

    function runParser(text, mode) {
        const msg = document.getElementById('parser-msg');
        
        // AI Analysis Logic (Advanced Regex Pattern Matching)
        // Added synonyms for better matching
        const mapBat = {
            '打席': 'pa', '打数': 'ab', '安打': 'h', '二塁打': 'd', '三塁打': 't', '本塁打': 'hr', '本': 'hr', 'HR': 'hr',
            '四球': 'bb', '死球': 'hbp', '三振': 'so', '犠飛': 'sf', '犠打': 'sh', '盗塁': 'sb', '盗塁死': 'cs', '併殺': 'gidp'
        };
        const mapPit = {
            // 修正: WHIPの"IP"に反応しないように (?<!WH) を追加
            '回': 'ip', '投球回': 'ip', 'IP': 'ip', 
            '失点': 'r', '自責': 'er', '被安打': 'h', '被本塁打': 'hr', '被本': 'hr',
            // 修正: 無四球の"四球"に反応しないように (?<!無) を追加
            '与四球': 'bb', '四球': 'bb', 
            '与死球': 'hbp', '死球': 'hbp', '奪三振': 'so', '三振': 'so', '打者': 'bf'
        };

        const map = mode === 'bat' ? mapBat : mapPit;
        let count = 0;
        let extractedInfo = [];

        for (const [key, id] of Object.entries(map)) {
            // Regex: Label followed by space/colon/tab, then number
            const regex = new RegExp(`${key}[:\\s　]*([0-9]+(?:\\.[0-9]+)?)`, 'g');
            let match;
            // Need to handle regex.exec(text) iteration correctly if text contains multiple matches for one key (e.g., '四球 20 四球 30')
            // For simplicity, we use matchAll and take the last match.
            const matches = [...text.matchAll(regex)];
            if(matches.length > 0) {
                match = matches[matches.length - 1]; // Take the last match
            }

            if(match) {
                const val = parseFloat(match[1]);
                const el = document.getElementById(`calc-${id}`);
                if(el) {
                    el.value = val;
                    el.style.backgroundColor = "#dcfce7"; // Success Color
                    setTimeout(()=>el.style.backgroundColor="", 2000);
                    count++;
                    if(extractedInfo.length < 6) extractedInfo.push(key);
                }
            }
        }

        msg.style.display = 'block';
        if (count > 0) {
            msg.innerHTML = `
                <div style="color:var(--cat-tot); font-weight:bold;">
                    ${icons.sparkle} 解析完了: ${count} 項目を抽出しました
                </div>
                <div style="font-size:0.8em; color:var(--c-text-secondary);">
                    検出: ${extractedInfo.join(', ')}${extractedInfo.length>=6 ? '...' : ''}
                </div>
            `;
        } else {
            msg.innerHTML = `
                <div style="color:#ef4444;">
                    ❌ データが見つかりませんでした。<br>
                    「打率.300 本塁打20」のように項目名と数字が含まれるテキストを貼り付けてください。
                </div>
            `;
        }
    }

    let radarChartInstance = null;

    function runBatchCalc(mode) {
        const isBat = mode === 'bat';
        const data = {};
        
        // Collect all inputs
        const inputs = document.querySelectorAll('.calc-field, .calc-select');
        inputs.forEach(el => {
            const id = el.id.replace('calc-', '');
            if(el.tagName === 'SELECT') {
                data[id] = el.value;
            } else {
                data[id] = parseFloat(el.value) || 0;
            }
        });
        
        // 必須のリーグ平均値をデータオブジェクトに注入 (calcDerivedの依存関係を解決するため)
        ADVANCED_LEAGUE_INPUTS.forEach(inp => {
            const id = inp.id;
            const el = document.getElementById(`calc-${id}`);
            data[id] = parseFloat(el.value) || inp.default || 0;
        });

        // Calculate Indicators
        let results = [];
        
        // ユーザー指定の指標IDリストを更新 (ISO, xFIPを追加)
        const targetIds = isBat ? 
            ['war', 'wrc_plus', 'woba', 'iso', 'babip', 'k_pct', 'bb_pct', 'wsb'] : 
            ['pit_war', 'fip', 'xfip', 'siera', 'k_pct_pit', 'bb_pct_pit'];

        terms.forEach(term => {
            if (targetIds.includes(term.id) && term.calc) {
                try {
                    // ISO, wsb, wrc_plusが正しく計算されるよう、必要な入力を事前に準備
                    if (isBat) {
                        if (term.id === 'iso') {
                            // ISOを計算するために必要なSLG, AVGを計算
                            const tb = (data.h - (data.d+data.t+data.hr) + 2*data.d + 3*data.t + 4*data.hr) || 0;
                            const slg = data.ab > 0 ? tb / data.ab : 0;
                            const avg = data.ab > 0 ? data.h / data.ab : 0;
                            data.slg = slg;
                            data.avg = avg;
                        } else if (term.id === 'k_pct' || term.id === 'bb_pct') {
                            // K%とBB%の計算にはPAが必要
                            if (data.pa === 0) return;
                        }
                    }

                    const res = term.calc(data);
                    if (res !== "---" && res !== "NaN" && res !== "Infinity") {
                        results.push({
                            title: term.title,
                            full: term.full,
                            value: res,
                            criteria: term.criteria,
                            cat: term.category,
                            id: term.id
                        });
                    }
                } catch(e) {
                    console.error(`Error calculating ${term.id}:`, e);
                }
            }
        });

        // --- Radar Chart Logic ---
        let radarHtml = '';
        if (results.length > 0) {
            radarHtml = `
                <div class="chart-wrapper">
                    <canvas id="radarChart"></canvas>
                </div>
                <div style="font-size:0.75rem; color:var(--c-text-secondary); text-align:center; margin-bottom:20px; line-height:1.5;">
                    <strong>【レーダーチャート評価項目】</strong><br>
                    ${mode === 'bat' 
                        ? '総合攻撃力(wRC+) / パワー(ISO) / 走力(wSB) / 選球眼(BB%) / 守備(UZR)' 
                        : '球威(K%) / 制球(BB%) / 将来性(xFIP) / 真の実力(SIERA) / ゴロ率(GB%)'}
                </div>
            `;
        }

        // Render Table
        if (results.length === 0) {
            document.getElementById('batch-results-area').innerHTML = '<div class="no-result">計算可能な指標がありませんでした。</div>';
            return;
        }

        let tableHtml = `
            <div class="section-label has-hash">ANALYSIS RESULTS / 分析結果</div>
            ${radarHtml}
            <table class="criteria-table" style="margin-top:20px;">
                <thead>
                    <tr style="background:var(--c-bg);">
                        <th style="padding-left:10px;">指標 (METRIC)</th>
                        <th style="text-align:right; padding-right:20px;">値 (VALUE)</th>
                        <th>基準 (CRITERIA)</th>
                    </tr>
                </thead>
                <tbody>
        `;

        results.forEach(r => {
            const catColor = getCatColor(r.cat);
            tableHtml += `
                <tr>
                    <td style="padding-left:10px;">
                        <span style="color:${catColor}; font-weight:900;">${r.title}</span>
                        <div style="font-size:0.75rem; color:var(--c-text-secondary);">${r.full}</div>
                    </td>
                    <td style="text-align:right; padding-right:20px; font-family:var(--font-mono); font-size:1.5rem; font-weight:700; color:var(--c-text-primary);">
                        ${r.value}
                    </td>
                    <td style="font-size:0.85rem; color:var(--c-text-secondary);">
                        ${r.criteria || '-'}
                    </td>
                </tr>
            `;
        });

        tableHtml += `</tbody></table>`;
        
        // 📋をSVGに置き換え
        tableHtml += `
            <button class="calc-btn" style="margin-top:20px; background:var(--c-text-secondary);" onclick="copyBatchResults()">
                ${icons.clipboard} 結果をコピー (COPY TEXT)
            </button>
        `;

        const resArea = document.getElementById('batch-results-area');
        resArea.innerHTML = tableHtml;
        resArea.scrollIntoView({behavior: 'smooth'});

        // --- Render Chart ---
        if (radarChartInstance) {
            radarChartInstance.destroy();
        }
        
        const ctx = document.getElementById('radarChart');
        if (ctx) {
            // Calculate Scores (0-100)
            let scores = [];
            let labels = [];
            
            // Helper function to calculate raw metric values needed for the chart, even if they weren't in the table.
            const calculateMetricValue = (id, inputData) => {
                const term = terms.find(t => t.id === id);
                if (term && term.calc) {
                    try {
                        const val = term.calc(inputData);
                        return parseFloat(val) || 0;
                    } catch(e) {
                        return 0; // Return 0 if calculation fails
                    }
                }
                return 0;
            };

            if (isBat) {
                // Batting Scores
                // 1. wRC+ (Overall Offense): 40(min) - 180(max) -> 100 is avg
                const wrc = calculateMetricValue('wrc_plus', data);
                const scoreWrc = Math.min(100, Math.max(0, (wrc - 40) / 140 * 100));
                
                // 2. ISO (Power): .050 - .350
                const tb = (data.h - (data.d+data.t+data.hr) + 2*data.d + 3*data.t + 4*data.hr) || 0;
                const slg = data.ab > 0 ? tb / data.ab : 0;
                const avg = data.ab > 0 ? data.h / data.ab : 0;
                const iso = slg - avg;
                const scoreIso = Math.min(100, Math.max(0, (iso - 0.050) / 0.300 * 100));
                
                // 3. wSB (Speed/Running): -5 - +10
                const wsb = calculateMetricValue('wsb', data);
                const scoreWsb = Math.min(100, Math.max(0, (wsb - (-5)) / 15 * 100));
                
                // 4. BB% (Eye): 3% - 18%
                const bb_pct = data.pa > 0 ? data.bb / data.pa : 0;
                const scoreBb = Math.min(100, Math.max(0, (bb_pct - 0.03) / 0.15 * 100));
                
                // 5. UZR (Defense): -15 - +15
                const uzr = parseFloat(data.def) || 0;
                const scoreUzr = Math.min(100, Math.max(0, (uzr - (-15)) / 30 * 100));

                labels = ['wRC+', 'ISO', 'wSB', 'BB%', 'UZR'];
                scores = [scoreWrc, scoreIso, scoreWsb, scoreBb, scoreUzr];

            } else {
                // Pitching Scores
                // 1. K% (Stuff): 10% - 35%
                const k_pct = data.bf > 0 ? data.so / data.bf : 0;
                const scoreK = Math.min(100, Math.max(0, (k_pct - 0.10) / 0.25 * 100));
                
                // 2. BB% (Control): 15% - 2% (Reverse)
                const bb_pct = data.bf > 0 ? data.bb / data.bf : 0.10;
                const scoreBb = Math.min(100, Math.max(0, (0.15 - bb_pct) / 0.13 * 100));
                
                // 3. xFIP (Expected Performance): 6.00 - 2.00 (Reverse)
                const xfip = calculateMetricValue('xfip', data); // Recalculate xFIP using input data
                const scoreXfip = Math.min(100, Math.max(0, (6.00 - xfip) / 4.00 * 100));
                
                // 4. SIERA (True Skill): 6.00 - 2.00 (Reverse)
                const siera = calculateMetricValue('siera', data); // Recalculate SIERA using input data
                const scoreSiera = Math.min(100, Math.max(0, (6.00 - siera) / 4.00 * 100));
                
                // 5. GB% (Groundball): 30% - 60%
                const gb_pct = parseFloat(data.gb_type || 45) / 100;
                const scoreGb = Math.min(100, Math.max(0, (gb_pct - 0.30) / 0.30 * 100));

                labels = ['K%', 'BB%', 'xFIP', 'SIERA', 'GB%'];
                scores = [scoreK, scoreBb, scoreXfip, scoreSiera, scoreGb];
            }

            radarChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Score',
                        data: scores,
                        backgroundColor: isBat ? 'rgba(14, 165, 233, 0.2)' : 'rgba(244, 63, 94, 0.2)',
                        borderColor: isBat ? '#0ea5e9' : '#f43f5e',
                        pointBackgroundColor: '#fff',
                        pointBorderColor: isBat ? '#0ea5e9' : '#f43f5e',
                        borderWidth: 2
                    }]
                },
                options: {
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            ticks: { display: false }, // Hide numbers
                            pointLabels: {
                                font: { size: 14, weight: '800', family: 'var(--font-mono)' },
                                color: document.body.classList.contains('dark-mode') ? '#94a3b8' : '#475569'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(51, 65, 85, 0.5)' : 'rgba(203, 213, 225, 0.5)'
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
    }

    function copyBatchResults() {
        const rows = document.querySelectorAll('#batch-results-area tr');
        let text = "【SABR METRICS LAB Calculation Results】\n";
        rows.forEach((row, i) => {
            if(i===0) return; // skip header
            const cols = row.querySelectorAll('td');
            if(cols.length > 0) {
                const metric = cols[0].querySelector('span').innerText;
                const value = cols[1].innerText.trim();
                text += `${metric}: ${value}\n`;
            }
        });

        // Fallback approach for iframe/sandbox environments
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        textArea.style.opacity = "0";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if(successful) {
                alert("クリップボードにコピーしました！");
            } else {
                alert("コピーに失敗しました。");
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            alert("コピーに失敗しました。");
        }

        document.body.removeChild(textArea);
    }

    /* --- Preset Logic (LocalStorage) --- */
    const STORAGE_KEY = 'sabr_metrics_presets';

    function getPresets() {
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Failed to parse presets", e);
            return {};
        }
    }

    function savePresets(presets) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(presets));
    }

    function updatePresetList() {
        const select = document.getElementById('preset-select');
        if (!select) return;

        const presets = getPresets();
        select.innerHTML = '<option value="">保存データを選択...</option>';
        
        Object.keys(presets).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        });
    }

    window.savePreset = function() {
        const nameInput = document.getElementById('preset-name');
        const name = nameInput.value.trim();
        
        if (!name) {
            alert('保存名を入力してください');
            return;
        }

        // Collect current input values
        const inputs = document.querySelectorAll('.calc-field, .calc-select');
        const data = {};
        let hasData = false;

        inputs.forEach(input => {
            // Strip "calc-" prefix from ID
            const key = input.id.replace('calc-', '');
            if (input.value) {
                data[key] = input.value;
                hasData = true;
            }
        });

        if (!hasData) {
            alert('保存するデータがありません');
            return;
        }

        const presets = getPresets();
        if (presets[name] && !confirm(`"${name}" は既に存在します。上書きしますか？`)) {
            return;
        }

        presets[name] = data;
        savePresets(presets);
        
        updatePresetList();
        document.getElementById('preset-select').value = name;
        nameInput.value = ''; // clear input
        alert(`"${name}" を保存しました`);
    }

    window.loadPreset = function() {
        const select = document.getElementById('preset-select');
        const name = select.value;
        
        if (!name) return;

        const presets = getPresets();
        const data = presets[name];
        
        if (data) {
            let count = 0;
            Object.keys(data).forEach(key => {
                const el = document.getElementById(`calc-${key}`);
                if (el) {
                    el.value = data[key];
                    // Visual feedback
                    el.style.backgroundColor = "#f0fdf4";
                    setTimeout(() => el.style.backgroundColor = "", 1000);
                    count++;
                }
            });
            
            // Trigger advanced check if any advanced inputs were loaded
            if (window.checkAdvancedChanges) window.checkAdvancedChanges();
        }
    }

    window.removePreset = function() {
        const select = document.getElementById('preset-select');
        const name = select.value;
        
        if (!name) return;

        // "Are you sure?" confirmation removed for easier deletion
        const presets = getPresets();
        if (presets[name]) {
            delete presets[name];
            savePresets(presets);
            updatePresetList();
            select.value = ""; // Reset selection
            alert(`"${name}" を削除しました`);
        }
    }

    // Initial Render
    render();

</script>
</body>
</html>
