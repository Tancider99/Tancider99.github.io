<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SABR METRICS LAB | Ultimate Calculator Edition</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">
    <link rel="icon" href="Copilot_20251122_185005.png" type="image/png">
    <link rel="apple-touch-icon" href="Copilot_20251122_185005.png">
    <!-- Chart.js for Radar Chart -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M4CEZGS8HY"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-M4CEZGS8HY');
    </script>
    <style>
        /* --- Design Tokens --- */
        :root {
            --c-bg: #f8fafc;
            --c-surface: #ffffff;
            --c-text-primary: #1e293b;
            --c-text-secondary: #64748b;
            --c-border: #e2e8f0;
            
            /* Category Colors & Accents */
            --cat-bat: #0ea5e9; --bg-bat: #f0f9ff; /* Sky Blue */
            --cat-pit: #f43f5e; --bg-pit: #fff1f2; /* Rose */
            --cat-fld: #d97706; --bg-fld: #fffbeb; /* Amber */
            --cat-tot: #10b981; --bg-tot: #ecfdf5; /* Emerald */
            --cat-std: #6366f1; --bg-std: #eef2ff; /* Indigo */
            --data-source-color: #4b5563;
            --ai-color: #8b5cf6;
            
            --shadow-card: 0 6px 15px -3px rgba(0, 0, 0, 0.08), 0 3px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-hover: 0 12px 25px -5px rgba(0, 0, 0, 0.15), 0 5px 10px -5px rgba(0, 0, 0, 0.08);
            --shadow-float: 0 20px 50px -10px rgba(0, 0, 0, 0.2);

            --font-sans: "Inter", "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            --font-mono: "JetBrains Mono", "Fira Code", Consolas, monospace;
            --font-serif: "Times New Roman", Times, serif; /* For Formulas */
        }

        /* --- Dark Mode Overrides --- */
        body.dark-mode {
            --c-bg: #0f172a;
            --c-surface: #1e293b;
            --c-text-primary: #f1f5f9;
            --c-text-secondary: #94a3b8;
            --c-border: #334155;
            
            --bg-bat: rgba(14, 165, 233, 0.15);
            --bg-pit: rgba(244, 63, 94, 0.15);
            --bg-fld: rgba(245, 158, 11, 0.15);
            --bg-tot: rgba(16, 185, 129, 0.15);
            --bg-std: rgba(99, 102, 241, 0.15);
            
            --shadow-card: 0 6px 15px -3px rgba(0, 0, 0, 0.4), 0 3px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-hover: 0 12px 25px -5px rgba(0, 0, 0, 0.6);
        }

        body {
            background-color: var(--c-bg);
            color: var(--c-text-primary);
            font-family: var(--font-sans);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            overflow-y: scroll;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- Header --- */
        header {
            background: var(--c-surface);
            padding: 4rem 2rem;
            text-align: center;
            position: relative;
            border-bottom: 1px solid var(--c-border);
            background-image: radial-gradient(var(--c-border) 1px, transparent 1px);
            background-size: 20px 20px;
            transition: background-color 0.3s;
        }

        .brand {
            font-size: 3.5rem;
            font-weight: 900;
            letter-spacing: -0.05em;
            margin: 0;
            color: var(--c-text-primary);
            background: linear-gradient(135deg, var(--c-text-primary) 0%, var(--c-text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .brand span { color: var(--cat-bat); -webkit-text-fill-color: var(--cat-bat); }
        
        .subtitle {
            color: var(--c-text-secondary);
            margin-top: 1rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        /* --- Sticky Controls --- */
        .controls-area {
            position: sticky;
            top: 0;
            background: var(--c-surface);
            opacity: 0.98;
            backdrop-filter: blur(12px);
            z-index: 100;
            border-bottom: 1px solid var(--c-border);
            padding: 1rem 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .search-wrapper {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0 0 1rem;
            padding: 0 2rem;
            position: relative;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .search-input {
            flex: 1;
            padding: 16px 24px 16px 50px;
            border-radius: 16px;
            border: 1px solid var(--c-border);
            background: var(--c-bg);
            font-size: 1rem;
            color: var(--c-text-primary);
            box-sizing: border-box;
            transition: all 0.2s;
            outline: none;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
        }
        .search-input:focus {
            background: var(--c-surface);
            border-color: var(--cat-bat);
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1);
        }
        /* 検索アイコンの修正 */
        .search-icon {
            position: absolute;
            left: 45px; top: 50%; 
            transform: translateY(-50%);
            color: var(--c-text-secondary);
            pointer-events: none;
            width: 20px; /* 明示的にサイズを指定 */
            height: 20px; /* 明示的にサイズを指定 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .search-icon svg { stroke-width: 2.5; width: 20px; height: 20px; } /* SVG自体のサイズも保証 */

        .theme-toggle {
            background: var(--c-bg);
            border: 1px solid var(--c-border);
            color: var(--c-text-primary);
            width: 54px;
            height: 54px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .theme-toggle:hover {
            border-color: var(--c-text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .theme-toggle svg { width: 24px; height: 24px; stroke-width: 2.5; }

        .filter-scroll {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        .filter-scroll::-webkit-scrollbar { height: 0; }

        .filter-chip {
            background: var(--c-surface);
            border: 1:px solid var(--c-border);
            color: var(--c-text-secondary);
            padding: 8px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 700;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex; align-items: center; gap: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.02);
        }
        .filter-chip:hover {
            background: var(--c-bg); color: var(--c-text-primary); transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .filter-chip.active {
            background: var(--c-text-primary); color: var(--c-surface);
            border-color: var(--c-text-primary); box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            transform: none;
        }

        /* --- Grid --- */
        .grid-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        .metric-card {
            background: var(--c-surface);
            border-radius: 20px;
            border: 1px solid var(--c-border);
            padding: 32px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex; flex-direction: column;
            position: relative; overflow: hidden;
            box-shadow: var(--shadow-card);
        }
        .metric-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-hover);
            border-color: var(--cat-bat);
        }
        
        .cat-bat:hover { border-color: var(--cat-bat); }
        .cat-pit:hover { border-color: var(--cat-pit); }
        .cat-fld:hover { border-color: var(--cat-fld); }
        .cat-tot:hover { border-color: var(--cat-tot); }
        .cat-std:hover { border-color: var(--cat-std); }

        .card-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;
        }
        .card-tag {
            font-size: 0.7rem; font-weight: 800; padding: 6px 12px; border-radius: 8px;
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .cat-bat .card-tag { background: var(--bg-bat); color: var(--cat-bat); }
        .cat-pit .card-tag { background: var(--bg-pit); color: var(--cat-pit); }
        .cat-fld .card-tag { background: var(--bg-fld); color: var(--cat-fld); }
        .cat-tot .card-tag { background: var(--bg-tot); color: var(--cat-tot); }
        .cat-std .card-tag { background: var(--bg-std); color: var(--cat-std); }
        
        /* 絵文字をSVGアイコンに置き換え */
        .calc-icon {
            opacity: 0.3; transition: 0.2s;
        }
        .calc-icon svg { width: 20px; height: 20px; stroke-width: 2.5; }
        .metric-card:hover .calc-icon { opacity: 1; transform: scale(1.1); }
        .calc-icon.ai svg { color: var(--ai-color); opacity: 0.8; }

        .metric-title {
            font-size: 2.2rem;
            font-weight: 800;
            margin: 0;
            line-height: 1;
            color: var(--c-text-primary);
            letter-spacing: -0.03em;
        }
        .metric-full {
            font-size: 0.85rem;
            color: var(--c-text-secondary);
            font-weight: 600;
            margin: 6px 0 20px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }
        .metric-desc {
            font-size: 0.95rem;
            color: var(--c-text-secondary);
            margin: 0;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* --- Footer --- */
        .footer-area {
            max-width: 1200px;
            margin: 20px auto 60px;
            padding: 0 2rem;
        }
        .footer-details {
            background: var(--c-surface);
            border: 1px solid var(--c-border);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s;
        }
        .footer-details[open] {
            box-shadow: var(--shadow-card);
            border-color: var(--cat-bat);
        }
        .footer-summary {
            padding: 20px 24px;
            cursor: pointer;
            font-weight: 700;
            color: var(--c-text-secondary);
            list-style: none;
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--c-bg);
            transition: background 0.2s, color 0.2s;
            font-size: 0.9rem;
        }
        .footer-summary:hover {
            color: var(--c-text-primary);
            background: var(--c-surface);
        }
        .footer-summary::-webkit-details-marker { display: none; }
        .footer-summary::after {
            content: '+'; margin-left: auto; font-size: 1.2rem; font-weight: 400; transition: transform 0.3s;
        }
        .footer-details[open] .footer-summary::after { transform: rotate(45deg); }
        
        /* Icon in Footer */
        .footer-icon svg { width: 20px; height: 20px; stroke-width: 2.5; }

        .footer-content {
            padding: 30px 40px;
            border-top: 1px solid var(--c-border);
            font-size: 0.9rem;
            color: var(--c-text-secondary);
            line-height: 1.8;
            animation: fadeIn 0.3s ease;
        }
        .footer-content h3 {
            font-size: 1rem; color: var(--c-text-primary); margin: 30px 0 12px 0;
            display: flex; align-items: center; gap: 8px; font-weight: 800; letter-spacing: 0.05em;
        }
        .footer-content h3:first-child { margin-top: 0; }
        .footer-content h3::before {
            content: ''; display: inline-block; width: 4px; height: 1.2em; background: var(--cat-bat); border-radius: 2px;
        }
        .footer-content ul {
            margin: 0; padding: 0; list-style: none;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 10px;
        }
        .footer-content li { margin: 0; }
        .footer-content a {
            color: var(--c-text-primary); text-decoration: none; transition: all 0.2s;
            display: flex; align-items: center; gap: 6px; padding: 8px 12px;
            background: var(--c-bg); border-radius: 8px; border: 1px solid transparent;
            font-weight: 600; font-size: 0.85rem;
        }
        .footer-content a:hover {
            border-color: var(--cat-bat); color: var(--cat-bat); background: var(--c-surface); transform: translateX(4px);
        }
        .footer-content p { margin-top: 0; margin-bottom: 16px; }

        .logic-box {
            background: var(--c-bg);
            border: 1px solid var(--c-border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .logic-title {
            font-weight: 700; color: var(--c-text-primary); margin-bottom: 8px; font-size: 0.95rem;
            display: flex; align-items: center; justify-content: space-between;
        }
        .logic-cat { font-size: 0.7rem; background: var(--c-text-secondary); color: white; padding: 2px 6px; border-radius: 4px; }
        .logic-cat.bat { background: var(--cat-bat); }
        .logic-cat.pit { background: var(--cat-pit); }
        .logic-formula {
            font-family: var(--font-mono); font-size: 0.85rem; color: var(--cat-bat); background: rgba(255,255,255,0.5);
            padding: 10px; border-radius: 6px; border: 1px solid var(--c-border); margin-bottom: 10px;
        }
        .logic-desc { font-size: 0.85rem; color: var(--c-text-secondary); line-height: 1.6; }
        
        /* --- Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.show { opacity: 1; }

        .modal-panel {
            background: var(--c-surface);
            width: 95%;
            max-width: 850px;
            max-height: 92vh;
            border-radius: 24px;
            padding: 0;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-float);
            transform: scale(0.95) translateY(20px); 
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--c-border);
        }
        .modal-overlay.show .modal-panel { transform: scale(1) translateY(0); }

        .modal-header {
            padding: 32px 40px;
            background: var(--c-bg);
            border-bottom: 1px solid var(--c-border);
            position: relative;
        }
        .modal-body {
            padding: 40px;
            overflow-y: auto;
            color: var(--c-text-primary);
        }

        .m-cat {
            font-size: 0.8rem;
            font-weight: 800;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }
        .m-title {
            font-size: 3.5rem;
            font-weight: 900;
            margin: 0;
            line-height: 1;
            letter-spacing: -0.03em;
            color: var(--c-text-primary);
        }
        .m-full {
            font-size: 1.1rem;
            color: var(--c-text-secondary);
            margin-top: 5px;
            font-weight: 500;
        }

        .close-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: var(--c-surface);
            border: 1px solid var(--c-border);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.5rem;
            color: var(--c-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .close-btn:hover { background: var(--c-bg); color: var(--c-text-primary); transform: rotate(90deg); }

        .section-label {
            font-size: 0.8rem;
            font-weight: 800;
            color: var(--c-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 3rem 0 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        /* 句点を削除 */
        .section-label::before { content:''; color: var(--cat-bat); }
        .section-label::after { content:''; flex:1; height:1px; background: var(--c-border); }
        .section-label.has-hash::before { content:'#'; }

        /* --- Formula Box --- */
        .formula-box {
            background: #1e293b; /* Always dark for formula */
            border: 1px solid #334155;
            padding: 30px;
            border-radius: 16px;
            font-family: var(--font-serif);
            font-size: 1.3rem;
            font-style: italic;
            color: #e2e8f0;
            overflow-x: auto;
            text-align: center;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }
        .formula-var {
            color: #38bdf8;
            font-weight: bold;
            margin: 0 2px;
            font-family: var(--font-sans);
            font-style: normal;
        }
        .formula-op { color: #94a3b8; margin: 0 5px; }

        /* --- Calculator Section --- */
        .calc-container {
            background: var(--c-bg);
            border: 1px solid var(--c-border);
            border-radius: 16px;
            padding: 30px;
            margin-top: 10px;
            position: relative; /* For ocr button positioning */
        }
        .calc-container.ai-mode {
            background: rgba(139, 92, 46, 0.05);
            border-color: var(--ai-color);
        }
        .calc-container.ai-mode .calc-title span { color: var(--ai-color); }
        .calc-container.ai-mode .calc-btn { background: var(--ai-color); }
        .calc-container.ai-mode .calc-btn:hover { background: #7c3aed; opacity: 0.9; }
        .calc-container.ai-mode .calc-res-value { color: var(--ai-color); }

        .calc-title {
            font-size: 1rem;
            font-weight: 800;
            color: var(--cat-bat);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .calc-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .calc-group { display: flex; flex-direction: column; gap: 5px; }
        .calc-label { font-size: 0.7rem; font-weight: 700; color: var(--c-text-secondary); text-transform: uppercase; }
        .calc-field, .calc-select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-mono);
            text-align: right;
            font-size: 1rem;
            background: var(--c-surface);
            color: var(--c-text-primary);
        }
        .calc-select { text-align: left; font-family: var(--font-sans); cursor: pointer; }
        .calc-field:focus, .calc-select:focus { outline: none; border-color: var(--cat-bat); box-shadow: 0 0 0 2px rgba(14,165,233,0.2); }

        /* Preset Styles */
        .preset-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
            background: rgba(0,0,0,0.03);
            padding: 12px;
            border-radius: 12px;
            flex-wrap: wrap;
            border: 1px solid var(--c-border);
        }
        .preset-label { width: 100%; font-size: 0.75rem; font-weight: 700; color: var(--c-text-secondary); margin-bottom: 4px; }
        .preset-select {
            flex: 1;
            min-width: 140px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-sans);
            font-size: 0.9rem;
        }
        .preset-input {
            flex: 1;
            min-width: 140px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--c-border);
            font-family: var(--font-sans);
            font-size: 0.9rem;
        }
        .preset-btn {
            padding: 8px 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            color: white;
            transition: 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .btn-load { background: var(--c-text-secondary); }
        .btn-load:hover { background: var(--c-text-primary); }
        .btn-save { background: var(--cat-bat); }
        .btn-save:hover { opacity: 0.9; }
        .btn-del { background: #ef4444; color: white; }
        .btn-del:hover { opacity: 0.9; }
        .preset-btn svg { width: 16px; height: 16px; stroke-width: 2.5; }

        /* --- Advanced Settings Style --- */
        .advanced-details {
            grid-column: 1 / -1;
            margin-top: 10px;
            border: 1px solid var(--c-border);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0,0,0,0.02);
        }
        .advanced-summary {
            padding: 12px 15px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--c-text-secondary);
            background: rgba(255,255,255,0.5);
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .advanced-summary::before {
            content: ' '; /* 絵文字削除 */
            font-size: 1rem;
        }
        .advanced-summary:hover {
            background: var(--c-surface);
            color: var(--cat-bat);
        }
        .advanced-content {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            border-top: 1px solid var(--c-border);
        }
        .advanced-details[open] .advanced-summary {
            border-bottom: 1px solid transparent;
        }
        .advanced-summary .icon-gear {
            width: 16px;
            height: 16px;
            stroke-width: 2.5;
            color: var(--c-text-secondary);
        }
        .advanced-summary:hover .icon-gear { color: var(--cat-bat); }


        .warning-msg {
            grid-column: 1 / -1;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            color: #b45309;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            animation: fadeIn 0.3s ease;
        }
        .warning-msg::before {
            content: '⚠️';
            font-size: 1.2rem;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        .calc-result-area {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px dashed var(--c-border);
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }
        .calc-res-label { font-size: 0.9rem; color: var(--c-text-secondary); font-weight: 600; }
        .calc-res-label span { font-size: 0.7em; background: var(--ai-color); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 5px; vertical-align: middle; }
        .calc-res-value { font-size: 2.5rem; font-weight: 900; color: var(--cat-bat); font-family: var(--font-mono); line-height: 1; }
        .calc-btn {
            background: var(--cat-bat);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 50px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .calc-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .calc-btn svg { width: 18px; height: 18px; stroke-width: 2.5; }

        .criteria-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .criteria-table th { text-align: left; color: var(--c-text-secondary); width: 120px; padding: 12px 0; border-bottom: 1px solid var(--c-border); }
        .criteria-table td { padding: 12px 0; border-bottom: 1px solid var(--c-border); color: var(--c-text-primary); font-weight: 600; }

        .related-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .rel-chip {
            background: var(--c-bg);
            padding: 8px 20px;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--c-text-secondary);
            cursor: pointer;
            border: 1px solid transparent;
            transition: 0.2s;
        }
        .rel-chip:hover { background: var(--c-text-primary); color: var(--c-surface); }

        .no-result {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px;
            color: var(--c-text-secondary);
        }
        
        /* --- Smart Parser Style --- */
        .parser-area {
            margin-bottom: 20px;
            background: var(--c-surface);
            border: 1px dashed var(--cat-bat);
            padding: 15px;
            border-radius: 12px;
        }
        .parser-textarea {
            width: 100%;
            height: 120px;
            border: 1px solid var(--c-border);
            border-radius: 8px;
            padding: 15px;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            box-sizing: border-box;
            resize: vertical;
            background: #f8fafc;
            transition: all 0.2s;
        }
        .parser-textarea:focus {
            background: #ffffff;
            border-color: var(--cat-bat);
            outline: none;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }
        .parser-btn {
            background: var(--c-text-primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            width: 100%;
            transition: all 0.3s;
            margin-top: 10px;
        }
        .parser-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .parser-btn.analyzing { background: var(--cat-bat); cursor: wait; animation: pulse 1.5s infinite; }
        .parser-btn svg { width: 18px; height: 18px; stroke-width: 2.5; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* --- Chart Container --- */
        .chart-wrapper {
            max-width: 400px;
            margin: 20px auto;
            position: relative;
        }
        
        /* Helper for formula formatting */
        .var { color: #38bdf8; font-family: var(--font-sans); font-weight: 600; font-style: normal; margin: 0 2px; }

        @media (max-width: 700px) {
            .brand { font-size: 2.5rem; }
            .m-title { font-size: 2.5rem; }
            .grid-container { grid-template-columns: 1fr; padding: 40px 1rem;}
            .modal-panel { width: 100%; height: 100%; border-radius: 0; }
            .search-wrapper { padding: 0 1rem; }
        }

        /* === New Career Mode Styles (v3.0 Power Pros Style) === */
        #career-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #f8fafc; /* 背景色: 非常に薄い青グレー */
            z-index: 2000;
            visibility: hidden; opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto; color: #1e293b;
            display: flex; flex-direction: column;
        }
        #career-overlay.active { visibility: visible; opacity: 1; transform: translateY(0); }
        
        .career-header {
            padding: 15px 30px;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid #e2e8f0;
            position: sticky; top: 0; z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }
        .career-brand { font-size: 1.4rem; font-weight: 900; letter-spacing: -0.02em; color: #0f172a; display: flex; align-items: center; gap: 10px; }
        .career-brand span { color: #3b82f6; background: #eff6ff; padding: 2px 8px; border-radius: 6px; font-size: 0.8em; }
        
        .career-content {
            max-width: 1200px; margin: 0 auto; width: 100%; padding: 40px 20px;
            box-sizing: border-box; flex: 1;
        }
        
        .career-grid { display: grid; grid-template-columns: 380px 1fr; gap: 30px; align-items: start; }
        
        /* パネルデザイン */
        .career-panel { 
            background: #ffffff; 
            border-radius: 24px; 
            padding: 32px; 
            border: 1px solid #e2e8f0; 
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 8px 10px -6px rgba(0, 0, 0, 0.01);
        }
        
        .career-title { 
            font-size: 1.1rem; font-weight: 800; margin-bottom: 24px; 
            color: #1e293b; display: flex; align-items: center;
            letter-spacing: 0.05em; border-bottom: 2px solid #f1f5f9; padding-bottom: 10px;
        }
        .career-title svg { width: 20px; height: 20px; margin-right: 8px; color: #3b82f6; }
        
        /* フォーム要素 */
        .c-form-group { margin-bottom: 24px; }
        .c-label { display: block; font-size: 0.85rem; font-weight: 700; color: #64748b; margin-bottom: 8px; }
        .c-input, .c-select {
            width: 100%; padding: 12px; border-radius: 12px;
            border: 1px solid #cbd5e1; background: #f8fafc;
            color: #1e293b; font-weight: 600; font-size: 0.95rem;
            transition: 0.2s; box-sizing: border-box;
        }
        .c-input:focus, .c-select:focus { outline: none; border-color: #3b82f6; background: #fff; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        
        /* 能力値スライダー（パワプロ風） */
        .c-rank-bar {
            height: 6px; width: 100%; background: #e2e8f0; border-radius: 3px; position: relative; margin-top: 10px; margin-bottom: 25px;
        }
        .c-rank-fill {
            height: 100%; border-radius: 3px; background: linear-gradient(90deg, #3b82f6, #2563eb);
            width: 50%; transition: width 0.2s;
        }
        .c-rank-input {
            position: absolute; top: -8px; left: 0; width: 100%; height: 20px; opacity: 0; cursor: pointer;
        }
        .c-rank-label {
            display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 700; color: #475569;
        }
        /* ランク表示の色分け */
        .rank-s { color: #eab308; } /* Gold */
        .rank-a { color: #f97316; } /* Orange */
        .rank-b { color: #ef4444; } /* Red */
        .rank-c { color: #f43f5e; } /* Pink/Red */
        .rank-d { color: #10b981; } /* Green */
        .rank-e { color: #3b82f6; } /* Blue */
        .rank-f { color: #64748b; } /* Slate */
        .rank-g { color: #94a3b8; } /* Gray */
        
        /* ロール切り替えタブ */
        .role-tabs { display: flex; gap: 8px; margin-bottom: 24px; background: #f1f5f9; padding: 5px; border-radius: 12px; }
        .role-tab { 
            flex: 1; padding: 10px; text-align: center; cursor: pointer; border-radius: 8px; 
            font-weight: 700; font-size: 0.9rem; color: #94a3b8; transition: all 0.2s; 
        }
        .role-tab.active { background: #ffffff; color: #3b82f6; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .role-tab:hover:not(.active) { color: #1e293b; }
        
        /* 結果表示エリア */
        .c-result-header {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); 
            gap: 15px; margin-bottom: 30px; padding: 20px; background: #f8fafc; border-radius: 16px;
        }
        .c-big-stat { text-align: center; }
        .c-big-val { font-size: 1.8rem; font-weight: 900; color: #0f172a; line-height: 1; font-family: var(--font-mono); }
        .c-big-lbl { font-size: 0.7rem; font-weight: 700; color: #64748b; margin-top: 5px; letter-spacing: 0.05em; }
        
        /* 履歴テーブル（横スクロール対応） */
        .c-history-wrap {
            background: #ffffff; border-radius: 16px; border: 1px solid #e2e8f0;
            max-height: 500px; overflow: auto; /* 縦横スクロール */
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.02);
        }
        .c-table { width: 100%; min-width: 800px; border-collapse: collapse; font-size: 0.85rem; white-space: nowrap; }
        .c-table th { 
            text-align: center; padding: 12px 8px; background: #f1f5f9; 
            color: #475569; font-weight: 700; position: sticky; top: 0; z-index: 10;
            border-bottom: 1px solid #cbd5e1;
        }
        .c-table td { text-align: center; padding: 10px 8px; border-bottom: 1px solid #f1f5f9; color: #334155; font-family: var(--font-mono); }
        .c-table tr:hover { background: #f8fafc; }
        
        /* WARなど強調 */
        .val-outstanding { color: #d97706; font-weight: 800; background: #fffbeb; }
        .val-great { color: #ea580c; font-weight: 800; }
        .val-good { color: #16a34a; font-weight: 700; }
        
        /* レスポンシブ */
        @media (max-width: 900px) {
            .career-grid { grid-template-columns: 1fr; }
            .c-result-header { grid-template-columns: repeat(3, 1fr); }
        }

    </style>
</head>
<body>
    <!-- Utility Functions (Simplified for single file) -->
    <script>
        // Icon Definitions (Lucide Icons for a clean look)
        const icons = {
            search: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>`,
            sun: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`,
            moon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`,
            barChart: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bar-chart"><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></svg>`,
            calculator: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calculator"><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="10" y2="18"/><line x1="8" x2="8" y1="10" y2="18"/><line x1="12" x2="12" y1="10" y2="18"/><line x1="8" x2="16" y1="14" y2="14"/></svg>`,
            gear: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2H2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 2 2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 2 2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-2-2v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-2-2V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`,
            sparkle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles"><path d="m12 3-1.83 2.66-2.67 1.84 2.67 1.84L12 13l1.83-2.66 2.67-1.84-2.67-1.84L12 3z"/><path d="m20.2 16.2-1.22 1.8-1.78 1.22 1.78 1.22 1.22 1.8 1.22-1.8 1.78-1.22-1.78-1.22-1.22-1.8z"/><path d="m4.64 10.36-1.15 1.68-1.57 1.08 1.57 1.08 1.15 1.68 1.15-1.68 1.57-1.08-1.57-1.08-1.15-1.68z"/></svg>`,
            loader: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>`,
            trash: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 3h6"/></svg>`,
            save: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-save"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>`,
            clipboard: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clipboard-copy"><rect width="8" height="4" x="8" y="2"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="M15 22v-3a3 3 0 0 0-3-3l-2.5 2.5"/><path d="M8 13l2.5 2.5"/></svg>`
        };
    </script>
    
    <header style="padding: 2rem 2rem 1rem;">
        <div style="display:flex; flex-wrap:wrap; justify-content:space-between; align-items:center; gap:20px; margin-bottom:20px;">
            <div>
                <h1 class="brand" style="font-size:2.5rem; margin-bottom:5px;">SABR<span>METRICS</span> LAB</h1>
                <p class="subtitle" style="margin:0;">Ultimate Baseball Analytics Dictionary</p>
            </div>
            
            <div style="display:flex; gap:10px;">
                <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle" title="Dark Mode"></button>
                
                <button class="theme-toggle" onclick="openToolMenu()" style="
                    width:auto; padding:0 24px; font-weight:800; letter-spacing:0.05em;
                    background:var(--c-text-primary); color:var(--c-bg); border:none;
                    display:flex; align-items:center; gap:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                ">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/></svg>
                    TOOLS
                </button>
            </div>
        </div>
    
        <div class="search-wrapper" style="padding:0; margin-bottom:15px;">
            <input type="text" class="search-input" id="searchInput" placeholder="指標名、意味、計算式で検索" oninput="handleSearch()">
        </div>
        
        <div class="filter-scroll" style="padding:0; justify-content:flex-start;">
            <div class="filter-chip active" onclick="filterCategory('all')" data-cat="all">ALL</div>
            <div class="filter-chip" onclick="filterCategory('std')" data-cat="std">基本</div>
            <div class="filter-chip" onclick="filterCategory('bat')" data-cat="bat">打撃</div>
            <div class="filter-chip" onclick="filterCategory('pit')" data-cat="pit">投球</div>
            <div class="filter-chip" onclick="filterCategory('fld')" data-cat="fld">守備走塁</div>
            <div class="filter-chip" onclick="filterCategory('tot')" data-cat="tot">総合</div>
        </div>
    </header>

    <div style="max-width: 1200px; margin: 0 auto; padding: 50px 2rem 0;">
        <details class="footer-details" style="border-color: var(--cat-bat); background: var(--bg-bat); margin-bottom: 20px;">
            <summary class="footer-summary" style="font-weight:800; color:var(--cat-bat);">
                <span class="footer-icon">⚠️</span> 
                <span>【重要】当サイトの指標と計算ロジックについて</span>
            </summary>
            <div class="footer-content">
                <div class="warning-msg" style="margin-bottom: 30px; display:block; border-left: 4px solid #f59e0b; background: #fffbeb; color: #1e293b;">
                    <strong style="display:block; margin-bottom:8px; color:#b45309;"> 指標の解釈に関するご注意</strong>
                    当サイトで算出される指標（WAR, wRC+, xFIPなど）は、ユーザーが入力した限られたデータを基に計算される<strong>「概算値」</strong>です。<br>
                    公式記録や専門サイト（1.02やFanGraphs等）の厳密な算出値とは、データの粒度や補正係数の違いにより<strong>必ず乖離が発生します。</strong><br>
                    SNS等で数値を共有・引用される際は、公式記録と混同されないようご配慮をお願いいたします。
                </div>

                <div style="margin-bottom: 30px;">
                    <h3>計算ロジックの前提</h3>
                    <p>
                        入力項目として存在しないデータ（例：外野フライの正確な割合、球場ごとの詳細なパークファクター変動など）は、近年のNPB平均値に近い値をデフォルトとして使用しています。<br>
                        より正確な値を求めたい場合は、各計算画面の「詳細設定」からリーグ総合成績などのパラメータを調整してください。
                    </p>
                </div>

                <div style="margin-bottom: 30px;">
                    <h3>主要指標の詳細計算ロジック（本サイト内の処理）</h3>
                    
                    <div class="logic-box">
                        <div class="logic-title">野手WAR <span class="logic-cat bat">Batting</span></div>
                        <div class="logic-formula">
                            WAR = (攻撃貢献 + 守備貢献 + 走塁貢献 + 守備位置補正 + 代替水準補正) ÷ RPW
                        </div>
                        <div class="logic-desc">
                            まずリーグ総合成績（詳細設定の値）から、その環境における各プレーの得点価値（wOBA係数）を動的に算出します。
                            算出した係数を用いて対象選手のwOBAを求め、リーグ平均と比較して「平均的打者よりどれだけ得点を生み出したか（wRAA）」を計算します。
                            これに本拠地のパークファクター補正、守備位置ごとの難易度補正、入力された守備評価(UZR)と走塁貢献(wSB)を加算します。
                            最後に、出場打席数に応じた「代替可能選手（リプレイスメント・レベル）との差分」を加え、1勝あたりの得点価値(RPW)で割ることで勝利数に換算しています。
                        </div>
                    </div>

                    <div class="logic-box">
                        <div class="logic-title">wRC+ <span class="logic-cat bat">Batting</span></div>
                        <div class="logic-formula">
                            wRC+ = ( (パークファクター補正後の得点創出能力) ÷ リーグ平均得点力 ) × 100
                        </div>
                        <div class="logic-desc">
                            上記で算出したwRAA（平均より増やした得点数）に対し、本拠地のパークファクターに基づく補正を行います（打者有利な球場ならマイナス、不利ならプラス）。
                            補正後の値を打席あたりの得点生産力に換算し、「リーグ平均を100とした場合の指数」として正規化しています。
                            これにより、球場の違いを排除して打撃傑出度を比較可能にしています。
                        </div>
                    </div>

                    <div class="logic-box">
                        <div class="logic-title">投手WAR <span class="logic-cat pit">Pitching</span></div>
                        <div class="logic-formula">
                            WAR = (平均比失点抑止量 + 代替水準補正) ÷ RPW
                        </div>
                        <div class="logic-desc">
                            本ツールではFIP（守備の影響を除いた疑似防御率）をベースに計算しています。
                            まず対象投手のFIPと、パークファクター補正をかけたリーグ平均失点率(RA9)を比較し、平均に対してどれだけ失点を防いだか(RAA)を算出します。
                            そこに役割（先発・救援）に応じた「代替水準投手との差分」を加算し、RPWで割ることで勝利貢献数を算出しています。
                            ※FIP定数はリーグ総合成績から自動計算されます。
                        </div>
                    </div>

                    <div class="logic-box">
                        <div class="logic-title">xFIP <span class="logic-cat pit">Pitching</span></div>
                        <div class="logic-formula">
                            xFIP = (13 × (推定フライ数 × リーグHR/FB率) + 3×(BB+HBP) - 2×SO) ÷ IP + 定数
                        </div>
                        <div class="logic-desc">
                            入力された「打球傾向(GB%)」に基づき、全打球に対するゴロ・ライナー・フライの内訳を自動推定します。
                            そのうちフライボール(FB)に対して「リーグ平均のHR/FB率（フライが本塁打になる確率）」を適用することで、「運に左右されない期待被本塁打数」を算出します。
                            この期待値を用いてFIPの式を再計算し、リーグ平均防御率のスケールに合うよう定数（リーグ平均RA9とリーグ平均xFIPの差分）を加算して調整しています。
                        </div>
                    </div>

                    <div class="logic-box">
                        <div class="logic-title">tRA <span class="logic-cat pit">Pitching</span></div>
                        <div class="logic-formula">
                            tRA = ( Σ(各イベント数 × 期待失点価値) ) ÷ IP × 27 + 定数
                        </div>
                        <div class="logic-desc">
                            入力データと打球傾向から、三振、四死球、被本塁打に加え、ゴロ(GB)、ライナー(LD)、外野フライ(FB)、内野フライ(PU)の各打球数を推定します。
                            それぞれのイベントに対して統計的に導き出された「期待失点ウェイト（例：被本塁打=1.401, ライナー=0.289, 三振=-0.108など）」を掛け合わせ、総失点期待値を算出します。
                            これを27アウト（9イニング）あたりに換算し、リーグ全体の失点率スケールに合わせるための定数を加えて表示しています。
                        </div>
                    </div>

                    <div class="logic-box">
                        <div class="logic-title">SIERA <span class="logic-cat pit">Pitching</span></div>
                        <div class="logic-formula">
                            SIERA = 6.145 - 16.99(K%) + 11.43(BB%) - 1.86(GB%) ... [多項式]
                        </div>
                        <div class="logic-desc">
                            打球傾向から推定したゴロ率(GB%)と、奪三振率(K%)、与四球率(BB%)などを用い、それらの二乗項や相互作用項（例：奪三振率×ゴロ率）を含む複雑な回帰式によって計算しています。
                            「奪三振率が高い投手は打たれたゴロもヒットになりにくい」「与四球が多い投手はゴロ率が高いと併殺を取りやすい」といった指標間の相乗効果を数式化し、投球の質をより詳細に評価しています。
                        </div>
                    </div>

                </div>
                
                <div>
                    <h3>参考にしたサイト</h3>
                    <ul>
                        <li><a href="https://1point02.jp/op/index.aspx" target="_blank" rel="noopener noreferrer">1.02 - Essence of Baseball</a></li>
                        <li><a href="https://www.baseballprospectus.com/news/article/10027/introducing-siera-part-1/" target="_blank" rel="noopener noreferrer">Baseball Prospectus</a></li>
                        <li><a href="http://bbalone.blog119.fc2.com/blog-entry-551.html" target="_blank" rel="noopener noreferrer">Baseball Concrete Blog</a></li>
                        <li><a href="https://l-data-daily.com/post-1763/" target="_blank" rel="noopener noreferrer">セイバーメトリクス指標・用語辞典</a></li>
                        <li><a href="https://bo-no05.hatenadiary.org/" target="_blank" rel="noopener noreferrer">ぼーののブログ</a></li>
                        <li><a href="https://ranzankeikoku.blog.fc2.com/blog-entry-6591.html" target="_blank" rel="noopener noreferrer">日本プロ野球RCAA&PitchingRunまとめblog</a></li>
                    </ul>
                </div>
            </div>
        </details>
    </div>
        
    <script>
        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            if (currentScrollY > 60) {
                document.body.classList.add('scrolled');
            } else {
                document.body.classList.remove('scrolled');
            }
            lastScrollY = currentScrollY;
        }, { passive: true });
    </script>

    <div class="grid-container" id="grid">
        <!-- Generated -->
    </div>

    <footer class="footer-area">
        <div style="text-align:center; color:var(--c-text-secondary); padding:20px;">
            <p style="margin:0; font-weight:600;">SABR METRICS LAB</p>
            <p style="margin:5px 0 0; font-size:0.8rem;">Ultimate Baseball Analytics Dictionary</p>
        </div>
    </footer>
    
    <div class="modal-overlay" id="modal" onclick="closeModalOutside(event)">
        <div class="modal-panel">
            <div class="modal-header" id="modal-header">
                <button class="close-btn" onclick="closeModal()">×</button>
                <div id="modal-title-area"></div>
            </div>
            <div class="modal-body" id="modal-body-content"></div>
        </div>
    </div>

<script>
    // --- Data Helper ---
    const formatVar = (text) => `<span class="var">${text}</span>`;

    // --- Constants (Default Values) ---
    const DEFAULTS = {
        // リーグ全体の統計（デフォルト値は概算）
        LG_PA: 28500,
        LG_RUNS: 2800,
        LG_HITS: 6900,
        LG_2B: 1150,
        LG_3B: 120,
        LG_HR: 485, 
        LG_BB: 2300,
        // リーグ総数詳細
        LG_AB: 28750, // 打数
        LG_HBP: 300,  // 死球
        LG_SF: 190,   // 犠飛
        LG_SH: 550    // 犠打
    };
    
    // --- 統一された詳細設定の定義 (11項目) ---
    const ADVANCED_LEAGUE_INPUTS = [
        {id:'lg_pa', label:'リーグ総打席', type:'number', advanced:true, default: DEFAULTS.LG_PA},
        {id:'lg_runs', label:'リーグ総得点', type:'number', advanced:true, default: DEFAULTS.LG_RUNS},
        {id:'lg_ab', label:'リーグ総打数', type:'number', advanced:true, default: DEFAULTS.LG_AB}, 
        {id:'lg_hits', label:'リーグ総安打', type:'number', advanced:true, default: DEFAULTS.LG_HITS},
        {id:'lg_2b', label:'リーグ総二塁打', type:'number', advanced:true, default: DEFAULTS.LG_2B},
        {id:'lg_3b', label:'リーグ総三塁打', type:'number', advanced:true, default: DEFAULTS.LG_3B},
        {id:'lg_hr', label:'リーグ総本塁打', type:'number', advanced:true, default: DEFAULTS.LG_HR},
        {id:'lg_bb', label:'リーグ総四球', type:'number', advanced:true, default: DEFAULTS.LG_BB},
        {id:'lg_hbp', label:'リーグ総死球', type:'number', advanced:true, default: DEFAULTS.LG_HBP},
        {id:'lg_sf', label:'リーグ総犠飛', type:'number', advanced:true, default: DEFAULTS.LG_SF},
        {id:'lg_sh', label:'リーグ総犠打', type:'number', advanced:true, default: DEFAULTS.LG_SH}
    ];

    // Park Factors
    const PARK_FACTORS = {
        'avg':      {name: '平均',     pf: 1.00},
        'jingu':    {name: '明治神宮', pf: 1.19},
        'yoko':     {name: '横浜',     pf: 1.04},
        'mazda':    {name: 'マツダ',   pf: 0.99},
        'tokyo':    {name: '東京ドーム', pf: 0.97},
        'koshien':  {name: '甲子園',   pf: 0.92},
        'nagoya':   {name: 'バンテリン', pf: 0.86},
        'escon':    {name: 'エスコン', pf: 1.06},
        'zozo':     {name: 'ZOZOマリン', pf: 1.06},
        'paypay':   {name: 'PayPay',   pf: 1.05},
        'belluna':  {name: 'ベルーナ', pf: 0.97},
        'kyocera':  {name: '京セラ',   pf: 0.95},
        'rakuten':  {name: '楽天モバイル', pf: 0.94}
    };

    // --- Helper to calculate Derived Constants ---
    function calcDerived(d) {
        // 基本入力値
        const lg_hr = d.lg_hr || DEFAULTS.LG_HR;
        const lg_bb = d.lg_bb || DEFAULTS.LG_BB;
        // 詳細パラメータ
        const lg_ab = d.lg_ab || DEFAULTS.LG_AB;
        const lg_hbp = d.lg_hbp || DEFAULTS.LG_HBP;
        const lg_sf = d.lg_sf || DEFAULTS.LG_SF;
        const lg_sh = d.lg_sh || DEFAULTS.LG_SH;
        
        // その他のリーグ統計
        const lg_pa = d.lg_pa || DEFAULTS.LG_PA;
        const lg_runs = d.lg_runs || DEFAULTS.LG_RUNS;
        const lg_hits = d.lg_hits || DEFAULTS.LG_HITS;
        const lg_2b = d.lg_2b || DEFAULTS.LG_2B;
        const lg_3b = d.lg_3b || DEFAULTS.LG_3B;

        // --- リーグ詳細データの計算 ---
        const lg_ibb = lg_bb * 0.03; 
        const lg_roe = Math.max(0, lg_pa - (lg_ab + lg_bb + lg_hbp + lg_sf + lg_sh));
        const lg_1b = lg_hits - lg_2b - lg_3b - lg_hr;
        const lg_obp = (lg_hits + lg_bb + lg_hbp) / (lg_ab + lg_bb + lg_hbp + lg_sf);

        // 推定: リーグ三振数 (PAの約18%)
        const lg_so = lg_pa * 0.18;
        
        // 推定: リーグ打球数 (Batted Balls)
        // Batted Balls = PA - BB - HBP - SO
        const lg_batted = lg_pa - lg_bb - lg_hbp - lg_so;
        
        // 推定: リーグ外野フライ数 (ユーザー指定: FB% 45%, GB% 45%, LD% 10%)
        const lg_fb_est = lg_batted * 0.45;

        // --- wOBA計算 (基準係数: wOBA Scale=1.28想定) ---
        const woba_denom = lg_ab + lg_bb - lg_ibb + lg_hbp + lg_sf;
        
        const woba_num_std = 
            0.692 * (lg_bb - lg_ibb) +
            0.73  * lg_hbp +
            0.966 * lg_roe +
            0.865 * lg_1b +
            1.334 * lg_2b +
            1.725 * lg_3b +
            2.065 * lg_hr;
            
        const lg_woba_std = woba_denom > 0 ? woba_num_std / woba_denom : 0;

        // --- 係数補正比率 (Fitting Ratio) ---
        const fitting_ratio = (lg_woba_std > 0 && lg_obp > 0) ? (lg_obp / lg_woba_std) : 1.0;
        const lg_woba = lg_woba_std * fitting_ratio;

        // --- wOBA Scale ---
        const woba_scale = 1.28 * fitting_ratio;

        // --- その他パラメータ ---
        const lg_r_pa = lg_runs / lg_pa;
        const est_lg_ip = lg_pa / 4.25;
        const rpw = 20 * (lg_runs / est_lg_ip);
        const rep_per_pa = 0.12 * (lg_woba / woba_scale);
        
        const lg_tra = (lg_runs / est_lg_ip) * 9 * 0.92;

        // --- xFIP定数 & 比率の計算 ---
        
        // 比率 = 本塁打 ÷ 外野フライ
        const lg_xfip_ratio = lg_hr / lg_fb_est;
        
        // リーグ失点率 (RA9)
        const lg_ra9 = (lg_runs / est_lg_ip) * 9;
        
        // リーグ防御率 (ERA) 推定 (RA9の約92%)
        const lg_era_est = lg_ra9 * 0.92;
        
        // xFIPのリーグ成分
        const lg_xfip_component = (13 * lg_xfip_ratio * lg_fb_est + 3 * (lg_bb - lg_ibb + lg_hbp) - 2 * lg_so) / est_lg_ip;
        
        // 定数 = リーグ防御率 - リーグxFIP成分
        const xfip_constant = lg_era_est - lg_xfip_component;

        // --- tRA定数の計算 (新規追加) ---
        // リーグ打球内訳の推定
        // インプレー打球 (BIP) = PA - BB - HBP - SO - HR
        let lg_bip = lg_pa - lg_bb - lg_hbp - lg_so - lg_hr;
        if (lg_bip < 0) lg_bip = 0;

        // 平均的な分布率 (GB:45%, LD:21%, FB系:34%)
        const lg_gb = lg_bip * 0.45;
        const lg_ld = lg_bip * 0.21;
        const lg_fb_system = lg_bip * 0.34;
        const lg_pu = lg_fb_system * 0.10; // 内野フライ (FB系の10%)
        const lg_fb = lg_fb_system - lg_pu; // 純粋な外野フライ

        // リーグtRA成分 (定数なしのtRA)
        const lg_tra_num = 
            0.297 * lg_bb + 
            0.327 * lg_hbp - 
            0.108 * lg_so + 
            1.401 * lg_hr + 
            0.036 * lg_gb - 
            0.124 * lg_pu + 
            0.132 * lg_fb + 
            0.289 * lg_ld;

        const lg_tra_denom = 
            lg_so + 
            0.745 * lg_gb + 
            0.304 * lg_ld + 
            0.994 * lg_pu + 
            0.675 * lg_fb;
        
        let tra_constant = 0;
        if (lg_tra_denom > 0) {
            const lg_tra_raw = (lg_tra_num / lg_tra_denom) * 27;
            // 定数 = リーグ失点率(RA9) - リーグtRA
            tra_constant = lg_ra9 - lg_tra_raw;
        }

        return { 
            lg_r_pa, rpw, rep_per_pa, lg_woba, lg_tra, woba_scale, fitting_ratio, 
            xfip_constant, lg_xfip_ratio, lg_fb_est, tra_constant, lg_ra9, lg_era_est
        };
    }

    // --- 新規追加: 打球内訳の推定ロジック ---
    function estimateBattedBalls(d) {
        // 既に実数がある場合は計算しない（再計算防止）
        // NOTE: dにはリーグ平均値が含まれるため、再計算防止はここでは行わない方が良い
        // if (d.est_done) return d; 
        
        // リーグ総本塁打を使用
        const lg_hr = d.lg_hr || DEFAULTS.LG_HR;

        // 1. 打者数(BF)の確保
        let bf = d.bf;
        if (!bf) {
            // BFがなければ投球回から推定 (IP x 4.20 程度が平均的)
            bf = d.ip * 4.20; 
        }

        // 2. 三振、四死球
        const so = d.so || (d.ip * 0.8); // 仮置き
        const bb = d.bb || (d.ip * 0.3);
        const hbp = d.hbp || 0;
        const hr = d.hr || 0; // 被本塁打 (SIERA, tRAの計算に必要)

        // 3. インプレー打球数 (BIP) の推定
        // BIP = 打者 - 三振 - 四球 - 死球 - 被本塁打
        let bip = bf - so - bb - hbp - hr;
        if (bip < 0) bip = 0;

        // 4. ゴロ率 (GB%) の取得
        // セレクトボックスの値(文字列)を数値化。デフォルトは平均の45%
        let gb_pct_val = 45; 
        if (d.gb_type) {
            gb_pct_val = parseFloat(d.gb_type);
        }

        const gb_rate = gb_pct_val / 100;
        const ld_rate = 0.21; // Line Driveは投手によらず約21%で一定とするのが一般的
        
        // 残りがフライ系 (FB + PU)
        let fb_system_rate = 1.0 - gb_rate - ld_rate;
        if (fb_system_rate < 0) fb_system_rate = 0;

        // 内野フライ率 (IFFB% / FB_total)
        // フライ全体のうち約10%が内野フライと仮定
        const iffb_rate = 0.10; 

        // 実数計算 (BIPをベースに分配)
        const gb = bip * gb_rate;
        const ld = bip * ld_rate;
        const fb_total = bip * fb_system_rate;
        const pu = fb_total * iffb_rate;     // 内野フライ
        const fb = fb_total - pu;            // 純粋な外野フライ (HRは含まない)

        // データオブジェクトに注入
        d.gb = gb;
        d.ld = ld;
        d.fb = fb;
        d.pu = pu;
        d.bf = bf; // 推定したBFも保存
        d.hr = hr; // 被本塁打も計算用に注入
        d.est_done = true; // フラグ

        return d;
    }

    // --- Helper: 詳細スタッツの計算 (Calculate Details from Inputs) ---
    function estimateDetails(d) {
        // IBBは入力がないため概算 (四球の約4%)
        const ibb = d.bb * 0.04;

        // ROE (失策出塁) の計算
        // ROE = 打席 - (打数 + 四球 + 死球 + 犠飛 + 犠打)
        const roe = Math.max(0, d.pa - (d.ab + d.bb + d.hbp + d.sf + d.sh));

        // 単打 (S)
        // Note: d.h must be defined. Assuming it is 0 if undefined.
        const h = d.h || 0;
        const d_val = d.d || 0;
        const t = d.t || 0;
        const hr = d.hr || 0;
        const s = h - d_val - t - hr;

        return { ibb, roe, s };
    }

    // --- Terms Database (説明文を常体に統一) ---
    const terms = [
        /* ---------------- 総合 (Total) ---------------- */
        {
            id: "war", category: "tot", title: "WAR (野手)", full: "Wins Above Replacement (Batter)",
            short: "打撃、走塁、守備を総合的に評価して野手の貢献度を表す指標",
            desc: "代替可能な控え選手（リプレイスメント・レベルの選手）が出場する場合に比べ、どれだけ勝利数を増やしたかによって計算される。",
            formula: `(wRAA + UZR + BaseRunning + ポジション補正 + 代替水準補正) ÷ RPW`,
            criteria: "2.0: レギュラー / 5.0: スター / 8.0: MVP",
            related: ["wraa", "uzr", "woba", "rpw"],
            aiMode: true,
            inputs: [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},
                {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'},
                
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'pos', label:'守備位置', type:'select', options:{'dh':'DH', '1b':'一塁', 'lf':'左翼', 'rf':'右翼', '3b':'三塁', '2b':'二塁', 'cf':'中堅', 'ss':'遊撃', 'c':'捕手'}},
                {id:'def', label:'守備評価', type:'select', options:{'0':'平均的 (0)', '5':'上手い (+5)', '10':'名手 (+10)', '15':'神 (+15)', '-5':'苦手 (-5)', '-10':'下手 (-10)'}},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio; // 補正係数

                // 1. Calculate wOBA (Coefficients scaled by fitting_ratio)
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;

                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * est.s +
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;

                const woba_val = woba_denom > 0 ? woba_num / woba_denom : 0;
                
                // 2. wRAA
                const raw_wRAA = ((woba_val - C.lg_woba) / C.woba_scale) * d.pa;

                // 3. Park Adj
                const pf = PARK_FACTORS[d.stadium].pf;
                const home_ratio = 0.5;
                const pf_coef = (home_ratio * pf) + ((1 - home_ratio) * (6 - pf) / 5);
                const parkAdj = (1 - pf_coef) * C.lg_r_pa * d.pa;
                
                const battingRuns = raw_wRAA + parkAdj;
                
                // 4. Pos Adj
                const posVals = {'dh':-15.1, '1b':-14.1, 'lf':-12.0, 'rf':-5.0, '3b':-4.8, '2b':3.4, 'cf':4.2, 'ss':10.3, 'c':18.1};
                const posAdj = (posVals[d.pos] || 0) * (d.pa / 600);
                
                // 5. UZR & BaseRunning
                const uzr = parseFloat(d.def) || 0;
                const baseRunning = (d.sb * 0.2) - (d.cs * 0.4);
                
                // 6. Replacement Level
                const repRuns = C.rep_per_pa * d.pa;
                
                // 7. Calc WAR
                const totalRuns = battingRuns + uzr + baseRunning + posAdj + repRuns;
                return (totalRuns / C.rpw).toFixed(1);
            }
        },
        {
            id: "wrc_plus", category: "bat", title: "wRC+", full: "weighted Runs Created Plus",
            short: "打撃の傑出度を評価する指標",
            desc: "打席あたりの得点創出の多さを、平均的な打者を100とした場合のパーセンテージで評価する指標",
            formula: `(((wRAA/打席 + R/PA) + (R/PA - PF補正係数×R/PA)) ÷ R/PA) × 100`,
            criteria: "100: 平均 / 160: MVP候補 / 200: 歴史的",
            related: ["woba", "wraa"],
            aiMode: true,
            inputs: [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},

                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio;
                const pf = PARK_FACTORS[d.stadium].pf;
                
                // wOBA
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;
                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * est.s +
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;
                const woba_val = woba_denom > 0 ? woba_num / woba_denom : 0;
                
                // wRAA
                const raw_wraa = ((woba_val - C.lg_woba) / C.woba_scale) * d.pa;
                
                // Park Adj
                const home_ratio = 0.5;
                const pf_coef = (home_ratio * pf) + ((1 - home_ratio) * (6 - pf) / 5);
                const parkAdj = (1 - pf_coef) * C.lg_r_pa * d.pa;

                // wRC+ Calc
                const wrc_plus_val = (((raw_wraa + parkAdj) / d.pa) + C.lg_r_pa) / C.lg_r_pa * 100;
                
                return wrc_plus_val.toFixed(0);
            }
        },
        {
            id: "pit_war", category: "tot", title: "WAR (投手)", full: "Wins Above Replacement (Pitcher)",
            short: "投球を総合的に評価して投手の貢献度を表す指標",
            desc: "代替可能な控え選手に比べ、どれだけ勝利数を増やしたかによって計算される。<br>SPRAR (先発としての貢献) と RPRAR (救援としての貢献) を足し合わせ、RPWで割って算出する",
            formula: `(SPRAR + RPRAR) ÷ RPW`,
            criteria: "2.0: ローテ投手 / 4.0: エース",
            related: ["fip", "tra", "rsaa", "rpw"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hr', label:'被本塁打'},
                {id:'role', label:'役割', type:'select', options:{'sp':'先発', 'rp':'救援'}},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);

                // 1. FIP Calculation (Standard Constant approx 3.10)
                const fip = (13 * d.hr + 3 * d.bb - 2 * d.so) / d.ip + 3.10; // Simple FIP constant is approx 3.10

                // 2. League Parameters
                // C.lg_ra9 is calculated inside calcDerived using the new comprehensive inputs
                const lg_ra9 = C.lg_ra9;

                // 3. Park Adjustment
                const pf = PARK_FACTORS[d.stadium].pf;
                // Park Adjusted League RA9
                const lg_ra9_park = lg_ra9 * pf;

                // 4. Runs Above Average (RAA) based on FIP
                // RAA = (League RA - Pitcher FIP) * IP / 9
                const raa = (lg_ra9_park - fip) * (d.ip / 9);

                // 5. Replacement Level Adjustment
                // SP: +0.38 runs/9, RP: +0.47 runs/9 (approx)
                const rep_bonus = d.role === 'sp' ? 0.38 : 0.47;
                const rep_runs = rep_bonus * (d.ip / 9);

                // 6. RAR (Runs Above Replacement) -> SPRAR or RPRAR
                const rar = raa + rep_runs;
                
                // Since inputs only allow one role, SPRAR+RPRAR is just RAR
                return (rar / C.rpw).toFixed(1);
            }
        },
        {
            id: "rpw", category: "tot", title: "RPW", full: "Runs Per Win",
            short: "勝利を1つ増やすのに必要な得点数",
            desc: "「1勝の重み」を得点換算したもの。",
            formula: `20 × (リーグ総得点 ÷ リーグ総投球回)`,
            criteria: "約8.5 ～ 10.0",
            related: ["war", "pythag"],
            inputs: [
                {id:'lg_runs', label:'リーグ総得点'},
                {id:'lg_pa', label:'リーグ総打席'}
                // IPはPAから推定されるため、ここではPAを使用
            ],
            calc: (d) => {
                const est_lg_ip = d.lg_pa / 4.25; // Estimate IP from PA
                return (20 * (d.lg_runs / est_lg_ip)).toFixed(2);
            }
        },
        {
            id: "wpa", category: "tot", title: "WPA", full: "Win Probability Added",
            short: "勝利確率をどれだけ変動させたかを示す",
            desc: "状況（点差、イニング、走者、アウト）ごとの勝利確率を、プレイ前後でどれだけ増やしたかによって評価する。サヨナラホームランなどは非常に高い値になる",
            formula: `プレイ後の勝利確率 - プレイ前の勝利確率`,
            criteria: "状況に依存",
            related: ["re24"]
        },
        {
            id: "re24", category: "tot", title: "RE24", full: "Run Expectancy 24",
            short: "状況別の「得点期待値」の増減を示す",
            desc: "24種類の状況（無死一塁など）における得点期待値をどれだけ改善させたかを測る。",
            formula: `プレイ後期待値 - プレイ前期待値 + 得点`,
            criteria: "0: 平均",
            related: ["wpa"]
        },
        {
            id: "pythag", category: "tot", title: "Pythagenpat", full: "Pythagorean Expectation",
            short: "得失点から予測される「本来あるべき勝率」",
            desc: "実際の勝率がこれより高いと「運が良い」または「接戦に強い（監督の采配が良い）」とされる。未来の勝率予測に役立つとして重視される",
            formula: `${formatVar('得点')}^x ÷ (${formatVar('得点')}^x + ${formatVar('失点')}^x) <br><small style="font-size:0.7em; color:#94a3b8;">x = (得点+失点)^0.287</small>`,
            criteria: "実際の勝率との乖離を確認",
            inputs: [
                {id:'rs', label:'得点'}, {id:'ra', label:'失点'}
            ],
            calc: (d) => {
                const x = Math.pow((d.rs + d.ra), 0.287);
                return (Math.pow(d.rs, x) / (Math.pow(d.rs, x) + Math.pow(d.ra, x))).toFixed(3);
            }
        },
        {
            id: "pf", category: "tot", title: "PF", full: "Park Factor",
            short: "球場の特性（打者有利/投手有利）を表す数値",
            desc: "1.00が平均。1.00より大きければ打者有利、小さければ投手有利とされる。セイバーメトリクスでは、選手の成績を比較する際にこのPF補正をかけることが常識となっている",
            formula: `(本拠地での試合あたり得点 + 失点) ÷ (本拠地以外での試合あたり得点 + 失点)`,
            criteria: "1.00: 中立 / 1.20: ヒッターズパーク",
            related: ["wrc_plus"]
        },

        /* ---------------- 打撃 (Batting) ---------------- */
        {
            id: "avg", category: "std", title: "AVG", full: "Batting Average",
            short: "打率",
            formula: `${formatVar('安打')} ÷ ${formatVar('打数')}`,
            criteria: ".250: 平均 / .300: 優秀",
            inputs: [{id:'h', label:'安打'}, {id:'ab', label:'打数'}],
            calc: (d) => (d.h / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "obp", category: "std", title: "OBP", full: "On Base Percentage",
            short: "出塁率",
            desc: "打率よりも得点との相関が高いため、セイバーメトリクスでは打率より重視される。四死球を選べる打者は価値が高いと評価される",
            formula: `(${formatVar('安打')} + ${formatVar('四球')} + ${formatVar('死球')}) ÷ (${formatVar('打数')} + ${formatVar('四球')} + ${formatVar('死球')} + ${formatVar('犠飛')})`,
            criteria: ".320: 平均 / .400: 優秀",
            related: ["ops", "isod"],
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}],
            calc: (d) => ((d.h+d.bb+d.hbp)/(d.ab+d.bb+d.hbp+d.sf)).toFixed(3).replace(/^0/,'')
        },
        {
            id: "slg", category: "std", title: "SLG", full: "Slugging Percentage",
            short: "長打率",
            desc: "打率のような名前だが「1打数あたりの期待塁打数」を表す。単打=1、本塁打=4として計算する",
            formula: `${formatVar('塁打')} ÷ ${formatVar('打数')}`,
            criteria: ".400: 平均 / .500: パワーヒッター",
            related: ["ops", "iso"],
            inputs: [{id:'tb', label:'塁打'}, {id:'ab', label:'打数'}],
            calc: (d) => (d.tb / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "ops", category: "std", title: "OPS", full: "On-base Plus Slugging",
            short: "出塁率 + 長打率",
            desc: "計算が簡単でありながら、チームの得点数と非常に高い相関を持つ指標。現在では公式記録としても採用されることが多い",
            formula: `${formatVar('出塁率')} + ${formatVar('長打率')}`,
            criteria: ".730: 平均 / .800: 優秀 / 1.000: 最強",
            related: ["woba", "xr"],
            inputs: [
                {id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, 
                {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}, {id:'tb', label:'塁打'}
            ],
            calc: (d) => {
                const obp = (d.h+d.bb+d.hbp)/(d.ab+d.bb+d.hbp+d.sf);
                const slg = d.tb / d.ab;
                return (obp + slg).toFixed(3).replace(/^0/,'');
            }
        },
        {
            id: "woba", category: "bat", title: "wOBA", full: "weighted On-Base Average",
            short: "各イベントを得点価値で重み付けした「真の出塁率」",
            desc: "OPSの欠点を修正し、各イベント（単打、本塁打、四球など）が得点にどれだけ貢献したかを係数化して計算する。係数は年度ごとに変動する",
            formula: `(0.69×${formatVar('四球')} + 0.72×${formatVar('死球')} + 0.89×${formatVar('単打')} + 1.27×${formatVar('二塁打')} + 1.62×${formatVar('三塁打')} + 2.10×${formatVar('本塁打')}) ÷ ${formatVar('打席')}`,
            criteria: ".320: 平均 / .400: MVP級",
            related: ["ops", "wrc_plus"],
            inputs: [
                {id:'pa', label:'打席'}, {id:'ab', label:'打数'},
                {id:'s', label:'単打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球', default:0}, 
                {id:'sf', label:'犠飛', default:0}, {id:'sh', label:'犠打', default:0},

                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio;
                
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;
                const woba_num = 
                    (0.692 * fr) * (d.bb - est.ibb) +
                    (0.73  * fr) * d.hbp +
                    (0.966 * fr) * est.roe +
                    (0.865 * fr) * d.s + 
                    (1.334 * fr) * d.d +
                    (1.725 * fr) * d.t +
                    (2.065 * fr) * d.hr;
                    
                return woba_denom > 0 ? (woba_num / woba_denom).toFixed(3).replace(/^0/,'') : "---";
            }
        },
        {
            id: "wraa", category: "bat", title: "wRAA", full: "weighted Runs Above Average",
            short: "平均的な打者より「何点」多く取ったかを示す",
            desc: "積み上げ指標。出場数が多く、かつ打撃成績が良いほど数値が高くなる。WARの打撃構成要素として使われる。<br>式中の<strong>wOBAScale（約1.24）</strong>は、wOBAを出塁率のスケール（.320前後が平均）に合わせるために掛けられていた係数を、得点単位に戻すために割るもの",
            formula: `(${formatVar('wOBA')} - リーグ平均wOBA) ÷ wOBAScale × ${formatVar('打席')}`,
            criteria: "0: 平均 / +20: 一流",
            related: ["war", "woba"]
        },
        {
            id: "iso", category: "bat", title: "ISO", full: "Isolated Power",
            short: "打率を除いた純粋な長打力",
            desc: "長打率から打率を引いて算出する。単打を無視し、二塁打以上を打つ能力のみを評価する",
            formula: `${formatVar('長打率')} - ${formatVar('打率')}`,
            criteria: ".140: 平均 / .250: 強打者",
            inputs: [
                {id:'slg', label:'長打率', default: 0.400}, 
                {id:'avg', label:'打率', default: 0.250}
            ],
            calc: (d) => (d.slg - d.avg).toFixed(3).replace(/^0/,'')
        },
        {
            id: "babip", category: "bat", title: "BABIP", full: "Batting Average on Balls In Play",
            short: "インプレー打球のヒット率（運の指標）",
            desc: "本塁打以外のフェアゾーンに飛んだ打球がヒットになった割合。極端に高い/低い場合は「運」や「守備」の影響が強い",
            formula: `(${formatVar('安打')}-${formatVar('本塁打')}) ÷ (${formatVar('打数')}-${formatVar('三振')}-${formatVar('本塁打')}+${formatVar('犠飛')})`,
            criteria: ".300前後が基準",
            inputs: [{id:'h', label:'安打'}, {id:'hr', label:'本塁打'}, {id:'ab', label:'打数'}, {id:'so', label:'三振'}, {id:'sf', label:'犠飛'}],
            calc: (d) => ((d.h - d.hr) / (d.ab - d.so - d.hr + d.sf)).toFixed(3).replace(/^0/,'')
        },
        {
            id: "bb_k", category: "bat", title: "BB/K", full: "Walk to Strikeout Ratio",
            short: "三振1つに対する四球の数",
            desc: "選球眼とコンタクト能力のバランスを示す。1.0を超えれば非常に優秀な打者とされる",
            formula: `${formatVar('四球')} ÷ ${formatVar('三振')}`,
            criteria: "0.4: 平均 / 1.0以上: 優秀",
            inputs: [{id:'bb', label:'四球'}, {id:'so', label:'三振'}],
            calc: (d) => (d.bb / d.so).toFixed(2)
        },
        {
            id: "k_pct", category: "bat", title: "K%", full: "Strikeout Percentage",
            short: "打席に占める三振の割合",
            desc: "三振が少ないほどコンタクト能力が高いとされるが、現代野球では長打とのトレードオフとしてある程度許容される傾向がある",
            formula: `${formatVar('三振')} ÷ ${formatVar('打席')}`,
            criteria: "20%: 平均 / 10%以下: コンタクト巧者",
            inputs: [{id:'so', label:'三振'}, {id:'pa', label:'打席'}],
            calc: (d) => ((d.so / d.pa) * 100).toFixed(1) + '%'
        },
        {
            id: "bb_pct", category: "bat", title: "BB%", full: "Walk Percentage",
            short: "打席に占める四球の割合",
            desc: "選球眼の良さを示す。打率が低くてもBB%が高い選手は出塁能力が高く、チームへの貢献度は大きいとされる",
            formula: `${formatVar('四球')} ÷ ${formatVar('打席')}`,
            criteria: "8%: 平均 / 10%以上: 選球眼が良い",
            inputs: [{id:'bb', label:'四球'}, {id:'pa', label:'打席'}],
            calc: (d) => ((d.bb / d.pa) * 100).toFixed(1) + '%'
        },
        {
            id: "rc", category: "bat", title: "RC", full: "Runs Created",
            short: "打者が創出した総得点数",
            desc: "ビル・ジェームズが考案した古典的な指標。安打や四球などの出塁能力と、長打力を掛け合わせて得点能力を推定する",
            formula: `(出塁能力A × 進塁能力B) ÷ (打席C)`,
            criteria: "積み上げ型指標",
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'tb', label:'塁打'}, {id:'ab', label:'打数'}, {id:'sf', label:'犠飛'}],
            calc: (d) => {
                // Basic RC Formula
                const a = d.h + d.bb;
                const b = d.tb;
                const c = d.ab + d.bb;
                return ((a * b) / c).toFixed(1);
            }
        },
        {
            id: "rc27", category: "bat", title: "RC27", full: "Runs Created per 27 Outs",
            short: "この打者9人で打線を組んだ時の1試合予想得点",
            desc: "RCを27アウト（1試合分）に換算したもの。打者の得点能力を直感的に理解しやすい",
            formula: `RC ÷ (${formatVar('打数')}-${formatVar('安打')}+${formatVar('盗塁死')}+${formatVar('併殺')}+${formatVar('犠打')}+${formatVar('犠飛')}) × 27`,
            criteria: "4.5点: 平均",
            inputs: [{id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'tb', label:'塁打'}, {id:'ab', label:'打数'}],
            calc: (d) => {
                const rc = ((d.h + d.bb) * d.tb) / (d.ab + d.bb);
                const outs = d.ab - d.h; 
                return (rc / outs * 27).toFixed(2);
            }
        },
        {
            id: "xr", category: "bat", title: "XR", full: "Extrapolated Runs",
            short: "各プレーに得点価値係数を掛けて算出する得点力",
            desc: "RCと似ているが、より各イベント（単打0.5点、本塁打1.44点など）の得点貢献を線形的に足し合わせて評価する指標",
            formula: `0.5×${formatVar('単打')} + 0.72×${formatVar('二塁打')} + 1.44×${formatVar('HR')} + 0.34×(${formatVar('四球')}+${formatVar('死球')})...`,
            criteria: "RC27と同様に評価可能",
            related: ["rc27"],
            inputs: [{id:'s', label:'単打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, {id:'bb', label:'四死球'}],
            calc: (d) => (0.5*d.s + 0.72*d.d + 1.04*d.t + 1.44*d.hr + 0.34*d.bb).toFixed(1)
        },
        {
            id: "ab_hr", category: "bat", title: "AB/HR", full: "At Bats per Home Run",
            short: "HR1本打つのにかかる打数",
            formula: `${formatVar('打数')} ÷ ${formatVar('本塁打')}`,
            criteria: "20.0以下: 本塁打打者",
            inputs: [{id:'ab', label:'打数'}, {id:'hr', label:'本塁打'}],
            calc: (d) => (d.ab / d.hr).toFixed(1)
        },
        {
            id: "pa_bb", category: "bat", title: "PA/BB", full: "Plate Appearances per Walk",
            short: "四球を1つ選ぶのにかかる打席数",
            formula: `${formatVar('打席')} ÷ ${formatVar('四球')}`,
            inputs: [{id:'pa', label:'打席'}, {id:'bb', label:'四球'}],
            calc: (d) => (d.pa / d.bb).toFixed(1)
        },
        {
            id: "isod", category: "bat", title: "IsoD", full: "Isolated Discipline",
            short: "四死球による出塁能力",
            desc: "出塁率から打率を引いて算出する。選球眼の良さを示す",
            formula: `${formatVar('出塁率')} - ${formatVar('打率')}`,
            criteria: "0.06: 平均 / 0.10: 選球眼良",
            inputs: [{id:'obp', label:'出塁率'}, {id:'avg', label:'打率'}],
            calc: (d) => (d.obp - d.avg).toFixed(3).replace(/^0/,'')
        },
        {
            id: "gpa", category: "bat", title: "GPA", full: "Gross Production Average",
            short: "OPSより打率に近い感覚で評価できる指標",
            desc: "OPSは出塁率を過小評価する傾向があるため、出塁率に1.8倍の重みをかけてバランスを取り、さらに打率のようなスケールに変換したもの",
            formula: `(1.8 × ${formatVar('出塁率')} + ${formatVar('長打率')}) ÷ 4`,
            criteria: ".250: 平均",
            inputs: [{id:'obp', label:'出塁率'}, {id:'slg', label:'長打率'}],
            calc: (d) => ((1.8 * d.obp + d.slg) / 4).toFixed(3).replace(/^0/,'')
        },
        {
            id: "seca", category: "bat", title: "SecA", full: "Secondary Average",
            short: "打率以外の要素（四球、長打、盗塁）での貢献度",
            desc: "ビル・ジェームズ考案。「打率」に含まれない攻撃力を測る",
            formula: `(${formatVar('塁打')}-${formatVar('安打')} + ${formatVar('四球')} + ${formatVar('盗塁')} - ${formatVar('盗塁死')}) ÷ ${formatVar('打数')}`,
            criteria: ".250: 平均 / .400: 超優秀",
            inputs: [{id:'tb', label:'塁打'}, {id:'h', label:'安打'}, {id:'bb', label:'四球'}, {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}, {id:'ab', label:'打数'}],
            calc: (d) => ((d.tb - d.h + d.bb + d.sb - d.cs) / d.ab).toFixed(3).replace(/^0/,'')
        },
        {
            id: "noi", category: "bat", title: "NOI", full: "New Offensive Index",
            short: "出塁率＋長打率÷3",
            desc: "OPSの簡易修正版。出塁率の価値を長打率の3倍と見積もって計算する。",
            formula: `(${formatVar('出塁率')} + ${formatVar('長打率')} ÷ 3) × 1000`,
            criteria: "450: 平均 / 550: 優秀",
            inputs: [{id:'obp', label:'出塁率'}, {id:'slg', label:'長打率'}],
            calc: (d) => ((d.obp + d.slg / 3) * 1000).toFixed(0)
        },
        
        /* ---------------- 投球 (Pitching) ---------------- */
        {
            id: "era", category: "std", title: "ERA", full: "Earned Run Average",
            short: "防御率",
            formula: `${formatVar('自責点')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "3.00: 平均",
            inputs: [{id:'er', label:'自責点'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.er * 9 / d.ip).toFixed(2)
        },
        {
            id: "whip", category: "std", title: "WHIP", full: "Walks plus Hits per Inning Pitched",
            short: "1回あたりに出したランナーの数",
            formula: `(${formatVar('被安打')} + ${formatVar('与四球')}) ÷ ${formatVar('投球回')}`,
            criteria: "1.30: 平均 / 1.00未満: エース",
            inputs: [{id:'h', label:'被安打'}, {id:'bb', label:'与四球'}, {id:'ip', label:'投球回'}],
            calc: (d) => ((d.h + d.bb) / d.ip).toFixed(2)
        },
        {
            id: "fip", category: "pit", title: "FIP", full: "Fielding Independent Pitching",
            short: "守備の影響を除外した「真の防御率」",
            desc: "投手の責任である三振・四球・被本塁打のみで評価する。防御率よりも将来の成績予測に役立つ",
            formula: `(13×${formatVar('本塁打')} + 3×(${formatVar('四球')}+${formatVar('死球')}) - 2×${formatVar('三振')}) ÷ ${formatVar('投球回')} + 3.10`,
            criteria: "防御率スケール",
            inputs: [{id:'hr', label:'被本塁打'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'so', label:'奪三振'}, {id:'ip', label:'投球回'}],
            calc: (d) => ((13*d.hr + 3*(d.bb+d.hbp) - 2*d.so)/d.ip + 3.10).toFixed(2)
        },
        {
            id: "xfip", category: "pit", title: "xFIP", full: "Expected FIP",
            short: "被本塁打の代わりに「フライボール数」を用いたFIPの進化版",
            desc: "HR/FB（フライに対する本塁打の割合）をリーグ平均値に置き換えて計算する。被本塁打の運要素を排除し、より純粋な実力を測る。",
            formula: `(13 × (FB × LgHR/LgFB) + 3 × (BB - IBB + HBP) - 2 × SO) ÷ IP + 定数`,
            criteria: "防御率スケール",
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'},
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // 打球内訳を推定
                estimateBattedBalls(d);
                
                const C = calcDerived(d);
                const est_ibb = d.bb * 0.04;
                
                // d.fb は estimateBattedBalls で生成されている
                const term1 = 13 * C.lg_xfip_ratio * d.fb;
                const term2 = 3 * (d.bb - est_ibb + d.hbp);
                const term3 = 2 * d.so;
                
                // xFIP = (13 * lg_xfip_ratio * FB + 3 * (BB - IBB + HBP) - 2 * SO) / IP + xfip_constant
                const val = (term1 + term2 - term3) / d.ip + C.xfip_constant;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "siera", category: "pit", title: "SIERA", full: "Skill-Interactive Earned Run Average",
            short: "打球の質や三振・四球を考慮した、FIPより精度の高い指標",
            desc: "投球の「質」を最も正確に反映するとされる指標。ゴロ率や三振、四球のバランスから算出される。",
            // formula: `6.145 - 16.99(SO/PA) + 11.43(BB/PA) - 1.86((GB-FB-PU)/PA) + ...`,
            formula: `6.145 - 16.99(SO/PA) + 11.43(BB/PA) - 1.86((GB-FB-PU)/PA) + 7.65((SO/PA)²) - 6.66(((GB-FB-PU)/PA)²) + 10.13(SO/PA)((GB-FB-PU)/PA) - 5.20(BB/PA)((GB-FB-PU)/PA)`,
            criteria: "失点率スケール (3.00: 優秀)",
            related: ["fip", "xfip", "tra"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, 
                {id:'hr', label:'被本塁打'}, // 必須項目に変更
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                {id:'bf', label:'打者数'}, // 必須項目に変更
                
                // --- 統一された詳細設定の追加 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // 打球内訳を推定
                estimateBattedBalls(d);

                const pa = d.bf;
                // ゼロ除算防止 (打者数(bf)が0の場合は計算不可)
                if (!pa || pa === 0) return "---";

                // SIERA計算 (Updated Formula)
                // SIERA = 6.145 – 16.986*(SO/PA) + 11.434*(BB/PA) – 1.858*((GB-FB-PU)/PA) 
                //       + 7.653*((SO/PA)^2) - 6.664*(((GB-FB-PU)/PA)^2)
                //       + 10.130*(SO/PA)*((GB-FB-PU)/PA) – 5.195*(BB/PA)*((GB-FB-PU)/PA)
                
                const A = d.so / pa;
                const B = d.bb / pa;
                const C_val = (d.gb - d.fb - d.pu) / pa;
                
                const val = 6.145 
                    - 16.986 * A 
                    + 11.434 * B 
                    - 1.858 * C_val 
                    + 7.653 * (A * A) 
                    - 6.664 * (C_val * C_val) 
                    + 10.130 * A * C_val 
                    - 5.195 * B * C_val;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "tra", category: "pit", title: "tRA", full: "True Runs Allowed",
            short: "打球の種類（ゴロ・フライなど）も考慮した指標",
            desc: "FIPを発展させ、各打球種別（ライナー、ゴロ、フライ）の期待失点値を割り当てて算出する指標。",
            formula: `( (0.297×BB + 0.327×HBP - 0.108×SO + 1.401×HR + 0.036×GB - 0.124×PU + 0.132×FB + 0.289×LD) ÷ (SO + 0.745×GB + 0.304×LD + 0.994×PU + 0.675×FB) × 27 ) + 定数`,
            criteria: "失点率スケール",
            related: ["fip"],
            aiMode: true,
            inputs: [
                {id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'hr', label:'被HR'},
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                // --- 統一された詳細設定 ---
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                estimateBattedBalls(d);
                const C = calcDerived(d);
                
                // tRA計算 (Updated Formula)
                const numerator = 
                    0.297 * d.bb + 
                    0.327 * d.hbp - 
                    0.108 * d.so + 
                    1.401 * d.hr + 
                    0.036 * d.gb - 
                    0.124 * d.pu + 
                    0.132 * d.fb + 
                    0.289 * d.ld;
                    
                const denominator = 
                    d.so + 
                    0.745 * d.gb + 
                    0.304 * d.ld + 
                    0.994 * d.pu + 
                    0.675 * d.fb;
                
                if (denominator === 0) return "---";

                // tRA Raw (Base value)
                const tra_raw = (numerator / denominator) * 27;
                
                // 定数加算 (リーグRA9に合わせる補正)
                const val = tra_raw + C.tra_constant;
                
                return isFinite(val) ? val.toFixed(2) : "---";
            }
        },
        {
            id: "k_9", category: "pit", title: "K/9", full: "Strikeouts per 9",
            short: "奪三振率",
            formula: `${formatVar('奪三振')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "7.0: 平均 / 9.0: ドクターK",
            inputs: [{id:'so', label:'奪三振'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.so * 9 / d.ip).toFixed(2)
        },
        {
            id: "bb_9", category: "pit", title: "BB/9", full: "Walks per 9",
            short: "与四球率",
            formula: `${formatVar('与四球')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "3.0: 平均 / 2.0以下: 制球良",
            inputs: [{id:'bb', label:'与四球'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.bb * 9 / d.ip).toFixed(2)
        },
        {
            id: "k_pct_pit", category: "pit", title: "K%", full: "Strikeout Percentage (Pitcher)",
            short: "対戦打者に占める奪三振の割合",
            desc: "奪三振率(K/9)よりも投球回数に依存せず、投手の支配力を正確に表す指標",
            formula: `${formatVar('奪三振')} ÷ ${formatVar('打者数')}`,
            criteria: "20%: 平均 / 30%: 優秀",
            inputs: [{id:'so', label:'奪三振'}, {id:'bf', label:'打者数'}],
            calc: (d) => ((d.so / d.bf) * 100).toFixed(1) + '%'
        },
        {
            id: "bb_pct_pit", category: "pit", title: "BB%", full: "Walk Percentage (Pitcher)",
            short: "対戦打者に占める与四球の割合",
            desc: "与四球率(BB/9)よりも投球回数に依存せず、制球力を正確に表す指標",
            formula: `${formatVar('与四球')} ÷ ${formatVar('打者数')}`,
            criteria: "8%: 平均 / 5%以下: 優秀",
            inputs: [{id:'bb', label:'与四球'}, {id:'bf', label:'打者数'}],
            calc: (d) => ((d.bb / d.bf) * 100).toFixed(1) + '%'
        },
        {
            id: "k_bb_pit", category: "pit", title: "K/BB", full: "K-to-BB Ratio",
            short: "奪三振と与四球の比率",
            desc: "投手の完成度・安定感を示す重要指標。3.5を超えると非常に優秀とされる",
            formula: `${formatVar('奪三振')} ÷ ${formatVar('与四球')}`,
            criteria: "2.5: 平均 / 4.0: 非常に優秀",
            inputs: [{id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}],
            calc: (d) => (d.so / d.bb).toFixed(2)
        },
        {
            id: "gb_pct", category: "pit", title: "GB%", full: "Ground Ball Percentage (Est)",
            short: "打球傾向設定に基づく推定ゴロ率",
            desc: "選択された打球傾向設定から算出されたゴロ率を表示する",
            formula: `推定値`,
            criteria: "45%: 平均 / 50%超: ゴロP",
            aiMode: true,
            inputs: [
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }}
            ],
            calc: (d) => d.gb_type ? d.gb_type + '%' : "45%"
        },
        {
            id: "fb_pct", category: "pit", title: "FB%", full: "Fly Ball Percentage (Est)",
            short: "打球傾向設定に基づく推定フライ率",
            desc: "選択された打球傾向設定から算出されたフライ率（内野フライ含む）を表示する",
            formula: `推定値`,
            criteria: "35%: 平均",
            aiMode: true,
            inputs: [
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }}
            ],
            calc: (d) => {
                const gb = parseFloat(d.gb_type || 45);
                // LD 21%固定と仮定した場合の残り
                const fb = 100 - gb - 21;
                return fb + '%';
            }
        },

        /* ---------------- 守備 (Fielding) ---------------- */
        {
            id: "uzr", category: "fld", title: "UZR", full: "Ultimate Zone Rating",
            short: "守備による失点防止量（平均比）",
            desc: "1.02などで採用される守備指標のスタンダード。グラウンドをゾーンに分割し、打球ごとの処理難易度に応じて貢献度を算出する",
            formula: "加点方式",
            criteria: "0: 平均 / +15: ゴールドグラブ",
            // 入力された守備評価(def)をそのまま返す簡易実装
            inputs: [{id:'def', label:'守備評価'}], 
            calc: (d) => d.def ? parseFloat(d.def).toFixed(1) : "---"
        },
        {
            id: "der", category: "fld", title: "DER", full: "Defensive Efficiency Ratio",
            short: "本塁打以外のインプレー打球をアウトにした割合",
            desc: "チーム全体の守備力を測る指標。1-被BABIP",
            formula: `1 - ((${formatVar('被安打')} - ${formatVar('被HR')}) ÷ (${formatVar('打者')} - ${formatVar('三振')} - ${formatVar('四球')} - ${formatVar('死球')} - ${formatVar('被HR')}))`,
            criteria: ".700前後が平均",
            inputs: [{id:'h', label:'被安打'}, {id:'hr', label:'被HR'}, {id:'bf', label:'打者数'}, {id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}],
            calc: (d) => (1 - ((d.h - d.hr) / (d.bf - d.so - d.bb - d.hbp - d.hr))).toFixed(3).replace(/^0/,'')
        },
        {
            id: "drs", category: "fld", title: "DRS", full: "Defensive Runs Saved",
            short: "UZRと並ぶ守備指標",
            desc: "UZRと同様のコンセプトだが、測定方法が異なる。MLBではUZRと共にゴールドグラブ賞の選考基準となる",
            formula: "加点方式",
            criteria: "+15以上: 最高レベル"
        },
        {
            id: "rf", category: "fld", title: "RF", full: "Range Factor",
            short: "1試合あたりに関与したアウトの数",
            desc: "守備範囲の広さを示すとされる指標だが、投手の奪三振能力などに影響を受けるため、UZRなどより精度は低い",
            formula: `(${formatVar('刺殺')}+${formatVar('補殺')}) ÷ ${formatVar('守備回')} × 9`,
            inputs: [{id:'po', label:'刺殺'}, {id:'a', label:'補殺'}, {id:'inn', label:'守備回'}],
            calc: (d) => ((d.po + d.a) / d.inn * 9).toFixed(2)
        },
        {
            id: "fp", category: "fld", title: "FP%", full: "Fielding Percentage",
            short: "守備率",
            desc: "失策をしなかった割合。守備範囲の広さは考慮されないため、現代のセイバーメトリクスでは重要視されない",
            formula: `(${formatVar('刺殺')}+${formatVar('補殺')}) ÷ (${formatVar('刺殺')}+${formatVar('補殺')}+${formatVar('失策')})`,
            inputs: [{id:'po', label:'刺殺'}, {id:'a', label:'補殺'}, {id:'e', label:'失策'}],
            calc: (d) => ((d.po + d.a)/(d.po + d.a + d.e)).toFixed(3).replace(/^0/,'')
        },

        /* ---------------- 走塁 (Running) ---------------- */
        {
            id: "wsb", category: "fld", title: "wSB", full: "weighted Stolen Base Runs",
            short: "盗塁による得点貢献",
            desc: "盗塁成功によるプラスと、盗塁死によるマイナス（成功よりペナルティが大きい）を合算したもの",
            formula: `0.2×${formatVar('盗塁')} - 0.4×${formatVar('盗塁死')}`,
            desc: "係数は概算値。盗塁死のマイナスは成功のプラスより大きいとされる",
            inputs: [{id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}],
            calc: (d) => (0.2*d.sb - 0.4*d.cs).toFixed(1)
        },
        {
            id: "sb_pct", category: "fld", title: "SB%", full: "Stolen Base Percentage",
            short: "盗塁成功率",
            formula: `${formatVar('盗塁')} ÷ (${formatVar('盗塁')} + ${formatVar('盗塁死')})`,
            criteria: "70%以上が損益分岐点",
            inputs: [{id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'}],
            calc: (d) => ((d.sb / (d.sb + d.cs)) * 100).toFixed(1) + '%'
        },

        /* ---------------- その他 ---------------- */
        {
            id: "p_ip", category: "pit", title: "P/IP", full: "Pitches per Inning",
            short: "1イニングあたりの投球数",
            formula: `${formatVar('投球数')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "15球以下: 省エネ",
            inputs: [{id:'np', label:'球数'}, {id:'ip', label:'投球回'}],
            calc: (d) => d.np > 0 ? (d.np / d.ip).toFixed(1) : "---"
        },
        {
            id: "rsaa", category: "pit", title: "RSAA", full: "Runs Saved Above Average",
            short: "平均的な投手に比べて、どれだけ失点を防いだかを示す",
            desc: "防御率と投球回を基に算出する積み上げ系指標。WARの投球版の簡易計算に使われることがある",
            formula: `(リーグ平均防御率 - ${formatVar('防御率')}) × ${formatVar('投球回')} ÷ 9`,
            criteria: "プラスなら平均以上",
            inputs: [
                {id:'er', label:'自責点'}, 
                {id:'ip', label:'投球回'},
                // リーグ平均防御率の代わりに、詳細設定から推定できるようにする
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                // ERAを計算 (入力がない場合は自責点から計算)
                const my_era = d.er ? (d.er * 9 / d.ip) : 0;
                
                // リーグ平均防御率を詳細設定から推定
                const C = calcDerived(d);
                const lg_era = C.lg_era_est;
                
                return ((lg_era - my_era) * d.ip / 9).toFixed(1);
            }
        },
        {
            id: "ta", category: "bat", title: "TA", full: "Total Average",
            short: "攻撃の効率性を測る古典的指標",
            desc: "獲得した塁数を、消費したアウト数で割ったもの。OPS普及以前によく使われていた指標。",
            formula: `(${formatVar('塁打')}+${formatVar('四球')}+${formatVar('死球')}+${formatVar('盗塁')}) ÷ (${formatVar('打数')}-${formatVar('安打')}+${formatVar('盗塁死')}+${formatVar('併殺打')})`,
            criteria: "0.700: 平均 / 1.000: 優秀",
            inputs: [
                {id:'tb', label:'塁打'}, {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'sb', label:'盗塁'},
                {id:'ab', label:'打数'}, {id:'h', label:'安打'}, {id:'cs', label:'盗塁死'}, {id:'gidp', label:'併殺打'}
            ],
            calc: (d) => {
                const num = d.tb + d.bb + d.hbp + d.sb;
                const denom = d.ab - d.h + d.cs + d.gidp;
                return denom > 0 ? (num / denom).toFixed(3) : "---";
            }
        },
        {
            id: "psn", category: "bat", title: "PSN", full: "Power-Speed Number",
            short: "パワーとスピードの兼備レベルを示す",
            desc: "本塁打数と盗塁数の調和平均。トリプルスリーなどを狙う選手のバランス評価に使われる。",
            formula: `(2 × ${formatVar('本塁打')} × ${formatVar('盗塁')}) ÷ (${formatVar('本塁打')} + ${formatVar('盗塁')})`,
            criteria: "20.0: 一流 / 30.0: 超一流",
            inputs: [{id:'hr', label:'本塁打'}, {id:'sb', label:'盗塁'}],
            calc: (d) => {
                return (d.hr + d.sb) > 0 ? ((2 * d.hr * d.sb) / (d.hr + d.sb)).toFixed(2) : "0.00";
            }
        },
        {
            id: "tto_pct", category: "bat", title: "TTO%", full: "Three True Outcomes Percentage",
            short: "「運に左右されない結果」の割合",
            desc: "打席結果が守備の影響を受けない「三振、四球、本塁打」のいずれかで終わった割合。現代野球ではこの割合が増加傾向にある。",
            formula: `(${formatVar('三振')} + ${formatVar('四球')} + ${formatVar('本塁打')}) ÷ ${formatVar('打席')}`,
            criteria: "35%: 平均 / 50%: 極端なパワーヒッター",
            inputs: [{id:'so', label:'三振'}, {id:'bb', label:'四球'}, {id:'hr', label:'本塁打'}, {id:'pa', label:'打席'}],
            calc: (d) => ((d.so + d.bb + d.hr) / d.pa * 100).toFixed(1) + '%'
        },
        {
            id: "pa_so", category: "bat", title: "PA/K", full: "Plate Appearances per Strikeout",
            short: "1三振するまでにかかる打席数",
            desc: "三振の少なさ（コンタクト能力）を示す指標。K%の逆数的な意味合いを持つ。",
            formula: `${formatVar('打席')} ÷ ${formatVar('三振')}`,
            criteria: "5.0: 平均 / 10.0: 三振しない",
            inputs: [{id:'pa', label:'打席'}, {id:'so', label:'三振'}],
            calc: (d) => (d.so > 0 ? (d.pa / d.so).toFixed(1) : "---")
        },
        {
            id: "hr_fb_bat", category: "bat", title: "HR/FB", full: "HR per Fly Ball (Batter)",
            short: "フライが本塁打になる確率",
            desc: "パワーの指標。これが極端に高い場合は運が良いか、真のパワーヒッターかのどちらかである。",
            formula: `${formatVar('本塁打')} ÷ ${formatVar('フライ総数')}`,
            criteria: "10%: 平均 / 20%: パワーヒッター",
            related: ["xfip"]
        },
        {
            id: "hard_pct", category: "bat", title: "Hard%", full: "Hard Contact Percentage",
            short: "強い打球（95mph以上）の割合",
            desc: "Statcastデータに基づく指標。打球速度が速いほどヒットや長打になる確率は高まる。",
            formula: "打球速度95マイル以上の打球数 ÷ 全打球数",
            criteria: "35%: 平均 / 50%: エリート"
        },
        {
            id: "barrel_pct", category: "bat", title: "Barrel%", full: "Barrel Percentage",
            short: "「バレル」ゾーンに入った打球の割合",
            desc: "打球速度と角度の組み合わせが、長打になる確率が最も高いゾーン（バレル）に入った割合。",
            formula: "バレル打球数 ÷ 打球数 (BBE)",
            criteria: "6-9%: 平均 / 15%以上: エリート",
            related: ["xwoba"]
        },
        {
            id: "xwoba", category: "bat", title: "xwOBA", full: "Expected wOBA",
            short: "打球の質から推定されるwOBA",
            desc: "打球速度と角度から「本来なるはずだった結果」を算出し、三振・四球と合わせて計算したwOBA。運の要素を排除した真の実力。",
            formula: "Statcast推定",
            criteria: ".320: 平均",
            related: ["woba"]
        },
        {
            id: "xba", category: "bat", title: "xBA", full: "Expected Batting Average",
            short: "期待打率",
            desc: "打球速度・角度・スプリントスピードなどから推定される「本来あるべき打率」。",
            formula: "Statcast推定",
            related: ["avg", "babip"]
        },
        {
            id: "whiff_pct", category: "bat", title: "Whiff%", full: "Whiff Percentage",
            short: "空振り率（スイング対比）",
            desc: "振ったスイングのうち、空振りになった割合。コンタクト能力の低さを示す。",
            formula: "空振り数 ÷ スイング総数",
            criteria: "25%: 平均"
        },
        {
            id: "chase_pct", category: "bat", title: "O-Swing%", full: "Outside Zone Swing % (Chase Rate)",
            short: "ボール球スイング率",
            desc: "ストライクゾーンから外れた球を振ってしまった割合。選球眼の悪さや積極性を示す。",
            formula: "ゾーン外スイング ÷ ゾーン外投球数",
            criteria: "30%: 平均 / 20%: 選球眼良"
        },
        {
            id: "zone_pct", category: "bat", title: "Zone%", full: "Zone Percentage",
            short: "ストライクゾーンへの投球割合",
            desc: "相手投手がどれだけゾーン内で勝負してきているかを示す。強打者ほど避けられやすく、Zone%は下がる傾向がある。",
            formula: "ゾーン内投球数 ÷ 全投球数",
            criteria: "48-51%: 平均"
        },
        {
            id: "swstr_pct", category: "bat", title: "SwStr%", full: "Swinging Strike Percentage",
            short: "空振り率（全投球対比）",
            desc: "全投球のうち空振りを奪った割合。投手視点では奪三振能力、打者視点ではコンタクト難易度。",
            formula: "空振り数 ÷ 全投球数",
            criteria: "10-12%: 平均"
        },
        {
            id: "ubr", category: "fld", title: "UBR", full: "Ultimate Base Running",
            short: "盗塁以外の走塁貢献",
            desc: "タッチアップや一塁からの長打での生還など、盗塁以外の走塁による得点貢献を得点価値化したもの。",
            formula: "加点方式",
            criteria: "0: 平均"
        },
        {
            id: "wgdp", category: "bat", title: "wGDP", full: "Weighted GIDP Runs",
            short: "併殺打による得点損失",
            desc: "平均的な選手と比較して、併殺打によってどれだけ得点機会を潰したか（あるいは回避したか）を示す。",
            formula: "併殺打数 × 損失価値係数",
            criteria: "0: 平均"
        },
        {
            id: "bsr", category: "fld", title: "BsR", full: "Base Running Runs",
            short: "走塁総合貢献 (wSB + UBR + wGDP)",
            desc: "盗塁(wSB)、走塁(UBR)、併殺回避(wGDP)をすべて合計した、走塁による総合的な得点貢献。",
            formula: "wSB + UBR + wGDP",
            criteria: "0: 平均 / +6.0: 神足"
        },
    
        /* ---------------- 投手 (Pitching) ---------------- */
        {
            id: "ra9", category: "pit", title: "RA9", full: "Runs Allowed per 9 Innings",
            short: "9イニングあたりの失点率",
            desc: "防御率(ERA)とは異なり、自責点ではなく「総失点」を用いて計算する。実際に防いだ失点量を示す。",
            formula: `${formatVar('失点')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "4.00前後: 平均",
            inputs: [{id:'r', label:'失点'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.r * 9 / d.ip).toFixed(2)
        },
        {
            id: "h_9", category: "pit", title: "H/9", full: "Hits per 9",
            short: "9イニングあたりの被安打数",
            desc: "打たれにくさを示すが、運や守備力の影響を受けやすい。",
            formula: `${formatVar('被安打')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "8.5: 平均",
            inputs: [{id:'h', label:'被安打'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.h * 9 / d.ip).toFixed(2)
        },
        {
            id: "hr_9", category: "pit", title: "HR/9", full: "Home Runs per 9",
            short: "9イニングあたりの被本塁打数",
            desc: "一発病の傾向を示す。被本塁打はFIP計算において最も重いウェイトを占める。",
            formula: `${formatVar('被本塁打')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "1.0: 平均 / 0.5: 優秀",
            inputs: [{id:'hr', label:'被本塁打'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.hr * 9 / d.ip).toFixed(2)
        },
        {
            id: "k_minus_bb", category: "pit", title: "K-BB%", full: "Strikeout minus Walk Percentage",
            short: "奪三振率と与四球率の差",
            desc: "K/BBよりも投手の能力を素直に反映するとされる指標。投手の基礎能力を測るのに最適。",
            formula: `${formatVar('K%')} - ${formatVar('BB%')}`,
            criteria: "15%: 平均 / 20%: 優秀 / 25%: エース",
            inputs: [{id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'bf', label:'打者数'}],
            calc: (d) => (((d.so - d.bb) / d.bf) * 100).toFixed(1) + '%'
        },
        {
            id: "lob_pct", category: "pit", title: "LOB%", full: "Left On Base Percentage",
            short: "残塁率（粘り強さ）",
            desc: "出塁させたランナーをどれだけホームに還さなかったか。72%前後が平均で、極端に高い・低い場合は運の影響が疑われる。",
            formula: `(${formatVar('安打')}+${formatVar('四死球')}-${formatVar('失点')}) ÷ (${formatVar('安打')}+${formatVar('四死球')}-1.4×${formatVar('HR')})`,
            criteria: "70-72%: 平均",
            inputs: [{id:'h', label:'被安打'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'r', label:'失点'}, {id:'hr', label:'被本塁打'}],
            calc: (d) => {
                const num = d.h + d.bb + d.hbp - d.r;
                const denom = d.h + d.bb + d.hbp - (1.4 * d.hr);
                return denom > 0 ? ((num / denom) * 100).toFixed(1) + '%' : "---";
            }
        },
        {
            id: "gb_fb_ratio", category: "pit", title: "GB/FB", full: "Ground Ball to Fly Ball Ratio",
            short: "ゴロとフライの比率",
            desc: "1.0を超えるとゴロ投手、下回るとフライ投手傾向。ゴロ投手は長打を浴びにくいが、守備の影響を受けやすい。",
            formula: `${formatVar('ゴロ')} ÷ ${formatVar('フライ')}`,
            criteria: "1.0: 平均 / 1.5以上: ゴロP",
            // 打球傾向入力から計算
            aiMode: true,
            inputs: [{id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{'55':'55% (超ゴロP)', '50':'50% (ゴロP)', '45':'45% (平均)', '40':'40% (フライP)', '35':'35% (超フライP)'}}],
            calc: (d) => {
                const gb = parseFloat(d.gb_type);
                const fb = 100 - gb - 21; // LD 21% fixed
                return (gb / fb).toFixed(2);
            }
        },
        {
            id: "gmsc", category: "pit", title: "GmSc", full: "Game Score",
            short: "先発投手の1試合ごとの投球評価",
            desc: "50を基準とし、イニング数、奪三振、被安打、失点などから算出されるスコア。100に近づくほど伝説的な投球。",
            formula: `50 + アウト1つにつき1点 + 5回以降1回につき2点 + 三振1点 - 被安打2点 - 自責点4点...`,
            criteria: "50: 平均 / 60: QSレベル / 90: 最高",
            inputs: [{id:'ip', label:'投球回'}, {id:'so', label:'奪三振'}, {id:'h', label:'被安打'}, {id:'r', label:'失点'}, {id:'er', label:'自責点'}, {id:'bb', label:'与四球'}],
            calc: (d) => {
                const outs = Math.floor(d.ip) * 3 + (d.ip % 1 * 10);
                const inn_bonus = d.ip > 4 ? (d.ip - 4) * 2 : 0; // 簡易計算
                return (50 + outs + inn_bonus + d.so - (2 * d.h) - (4 * d.er) - (2 * (d.r - d.er)) - d.bb).toFixed(0);
            }
        },
        {
            id: "qs", category: "pit", title: "QS", full: "Quality Start",
            short: "先発投手の最低限の責任回数",
            desc: "先発して6イニング以上を投げ、自責点3以内に抑えた試合数。",
            criteria: "達成率50%以上でローテ定着"
        },
        {
            id: "hqs", category: "pit", title: "HQS", full: "High Quality Start",
            short: "QSより厳しい基準",
            desc: "7イニング以上を投げ、自責点2以内に抑えた試合数。エース級の指標。",
            criteria: "エースの証"
        },
        {
            id: "csw_pct", category: "pit", title: "CSW%", full: "Called Strikes + Whiffs Percentage",
            short: "見逃し＋空振り率",
            desc: "全投球のうち、見逃しストライクと空振りを奪った割合。K%やSIERAとの相関が強く、投手の「支配力」を示す。",
            formula: "(見逃しS + 空振り) ÷ 全投球",
            criteria: "30%: 優秀"
        },
        {
            id: "stuff_plus", category: "pit", title: "Stuff+", full: "Stuff Plus",
            short: "「球威」の傑出度",
            desc: "球速、回転数、変化量など物理的特性のみから「どれだけ打たれにくい球か」を評価した指標。100が平均。",
            formula: "トラッキングデータ解析",
            criteria: "100: 平均 / 120: エース級"
        },
        {
            id: "location_plus", category: "pit", title: "Location+", full: "Location Plus",
            short: "「コマンド（制球）」の傑出度",
            desc: "ストライクゾーンの適切な位置に投げられているかを評価した指標。100が平均。",
            criteria: "100: 平均"
        },
        {
            id: "pitching_plus", category: "pit", title: "Pitching+", full: "Pitching Plus",
            short: "Stuff+とLocation+の総合評価",
            desc: "球威と制球を総合した投手の能力値。将来の成績予測に役立つ。",
            criteria: "100: 平均"
        },
        {
            id: "sv_pct", category: "pit", title: "SV%", full: "Save Percentage",
            short: "セーブ成功率",
            desc: "セーブ機会に対してセーブに成功した割合。",
            formula: `${formatVar('セーブ')} ÷ (${formatVar('セーブ')} + ${formatVar('救援失敗')})`,
            criteria: "90%以上: 絶対的守護神",
            inputs: [{id:'sv', label:'セーブ'}, {id:'bs', label:'救援失敗(BS)'}],
            calc: (d) => (d.sv + d.bs) > 0 ? ((d.sv / (d.sv + d.bs)) * 100).toFixed(1) + '%' : "---"
        },
        {
            id: "hld", category: "pit", title: "HLD", full: "Hold",
            short: "ホールド",
            desc: "セーブの条件を満たす局面で登板し、リードを保って降板した救援投手に記録される。",
            criteria: "積み上げ指標"
        },
        {
            id: "bs", category: "pit", title: "BS", full: "Blown Save",
            short: "セーブ失敗",
            desc: "セーブ機会で登板しながら同点または逆転を許した回数。勝利投手になってもBSは記録される。",
            criteria: "少ないほど良い"
        },
        {
            id: "irs_pct", category: "pit", title: "IRS%", full: "Inherited Runners Scored Percentage",
            short: "前の投手が残した走者を還した率",
            desc: "リリーフ投手の「火消し」能力を示す。低いほど優秀。",
            formula: `${formatVar('還した走者')} ÷ ${formatVar('引き継いだ走者')}`,
            criteria: "30%: 平均 / 20%以下: 優秀",
            inputs: [{id:'is', label:'還した走者'}, {id:'ir', label:'引き継いだ走者'}],
            calc: (d) => d.ir > 0 ? ((d.is / d.ir) * 100).toFixed(1) + '%' : "---"
        },
        {
            id: "rs_9", category: "pit", title: "RS/9", full: "Run Support per 9",
            short: "9イニングあたりの援護点",
            desc: "味方打線がどれだけ点を取ってくれたか。勝敗数に大きく影響するが、投手自身の能力ではない。",
            formula: `${formatVar('援護点')} × 9 ÷ ${formatVar('投球回')}`,
            criteria: "4.0: 平均",
            inputs: [{id:'rs_runs', label:'援護点総数'}, {id:'ip', label:'投球回'}],
            calc: (d) => (d.rs_runs * 9 / d.ip).toFixed(2)
        },
        {
            id: "kw_era", category: "pit", title: "kwERA", full: "Kitchen Sink ERA",
            short: "三振と四球のみで計算する簡易防御率予測",
            desc: "被本塁打すら除外し、三振と四球のみで能力を測る。FIPよりもさらに純粋な能力指標。",
            formula: `5.40 - 12 × (${formatVar('K%')} - ${formatVar('BB%')})`,
            criteria: "低いほど優秀",
            inputs: [{id:'so', label:'奪三振'}, {id:'bb', label:'与四球'}, {id:'bf', label:'打者数'}],
            calc: (d) => d.bf > 0 ? (5.40 - 12 * ((d.so - d.bb) / d.bf)).toFixed(2) : "---"
        },
    
        /* ---------------- 守備・総合 (Fielding / Overall) ---------------- */
        {
            id: "rngr", category: "fld", title: "RngR", full: "Range Runs",
            short: "守備範囲による失点抑止",
            desc: "平均的な野手よりどれだけ多くの打球をアウトにしたか（またはヒットにしてしまったか）を点数化したもの。UZRの主要構成要素。",
            criteria: "0: 平均"
        },
        {
            id: "errr", category: "fld", title: "ErrR", full: "Error Runs",
            short: "失策による失点関与",
            desc: "平均的な野手と比較して、失策によってどれだけ失点を増やしたか（減らしたか）。",
            criteria: "0: 平均"
        },
        {
            id: "arm", category: "fld", title: "ARM", full: "Arm Runs",
            short: "送球による失点抑止",
            desc: "外野手の補殺（進塁阻止）による貢献を点数化したもの。肩の強さと正確さを示す。",
            criteria: "0: 平均"
        },
        {
            id: "dpr", category: "fld", title: "DPR", full: "Double Play Runs",
            short: "併殺完成による失点抑止",
            desc: "内野手が併殺を取ることで防いだ失点量。",
            criteria: "0: 平均"
        },
        {
            id: "tz", category: "fld", title: "TZ", full: "Total Zone",
            short: "トータルゾーン",
            desc: "UZRが登場する前に主流だった守備指標。プレイごとのデータではなく、ゾーンごとの集計データを使用する。",
            related: ["uzr", "drs"]
        },
        {
            id: "fraa", category: "fld", title: "FRAA", full: "Fielding Runs Above Average",
            short: "Baseball Prospectus版の守備指標",
            desc: "UZRやDRSとは異なるアプローチで算出される守備貢献度。フレーミングなども考慮される場合がある。",
            criteria: "0: 平均"
        },
        {
            id: "wpa_li", category: "tot", title: "WPA/LI", full: "Context Neutral Wins",
            short: "場面重要度を中立化したWPA",
            desc: "WPA（勝利確率寄与）から「場面の重要度」の影響を取り除いたもの。チャンスで打ったかどうかに関わらず、プレイそのものの価値を評価する。",
            related: ["wpa", "li"]
        },
        {
            id: "li", category: "tot", title: "LI", full: "Leverage Index",
            short: "場面の重要度（レバレッジ）",
            desc: "そのプレイが試合の勝敗にどれだけ影響するかを示す指数。1.0が平均。サヨナラの場面などでは非常に高くなる。",
            criteria: "1.0: 平均 / 2.0以上: 勝負所"
        },
        {
            id: "clutch", category: "tot", title: "Clutch", full: "Clutch",
            short: "勝負強さ",
            desc: "「実際のWPA」と「場面重要度を考慮しない場合のWPA」の差。プラスなら勝負強い、マイナスなら勝負弱いとされるが、年次変動が大きく実力とはみなされにくい。",
            formula: "WPA - (WPA/LI)",
            criteria: "0: 平均"
        },
        {
            id: "cwpa", category: "tot", title: "cWPA", full: "Championship WPA",
            short: "優勝確率への貢献度",
            desc: "WPAが「その試合の勝利」への貢献なら、cWPAは「チームの優勝（ポストシーズン進出）」への貢献度を示す。優勝争いをしている時期の活躍ほど高くなる。",
            criteria: "%表記"
        },
        {
            id: "re", category: "tot", title: "RE", full: "Run Expectancy",
            short: "得点期待値",
            desc: "アウトカウントと走者状況（24パターン）ごとに、そのイニングが終了するまでに平均あと何点入るかを示した数値。",
            criteria: "無死満塁で約2.3点など",
            related: ["re24"]
        },
        {
            id: "linear_weights", category: "tot", title: "LWts", full: "Linear Weights",
            short: "線形加重",
            desc: "wOBAなどの基礎となる考え方。各プレイ（単打、四球など）が得点期待値を平均で何点増やしたかを算出し、係数として用いる手法。",
            related: ["woba", "xr"]
        },
        {
            id: "xera", category: "pit", title: "xERA", full: "Expected ERA",
            short: "予想防御率（Statcast）",
            desc: "打たれた打球の質（xwOBA）に基づいて算出される防御率。xFIPよりもさらに打球の物理的性質を考慮している。",
            related: ["era", "xwoba"]
        },
        {
            id: "dra", category: "pit", title: "DRA", full: "Deserved Run Average",
            short: "最も洗練された防御率指標",
            desc: "Baseball Prospectusが算出。球場、守備、捕手のフレーミング、対戦打者の質、気温などあらゆる要素を調整した「投手の真の責任失点率」。",
            criteria: "失点率スケール"
        },
        {
            id: "wrc", category: "bat", title: "wRC", full: "weighted Runs Created",
            short: "打者が創出した総得点数（wRAAベース）",
            desc: "wRC+の元となる積み上げ指標。平均的な打者と比較したwRAAに、リーグ平均レベルの得点創出数を加えて算出する。RCよりも厳密な得点価値に基づく。",
            formula: `wRAA + (リーグ平均得点率 × 打席数)`,
            criteria: "積み上げ指標",
            related: ["wrc_plus", "wraa"],
            inputs: [
                // wRAA計算用
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'}, 
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'sf', label:'犠飛'},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const C = calcDerived(d);
                const est = estimateDetails(d);
                const fr = C.fitting_ratio;
                const pf = PARK_FACTORS[d.stadium].pf;
    
                // wOBA
                const woba_denom = d.ab + d.bb - est.ibb + d.hbp + d.sf;
                const woba_num = (0.692*fr)*(d.bb-est.ibb) + (0.73*fr)*d.hbp + (0.966*fr)*est.roe + (0.865*fr)*est.s + (1.334*fr)*d.d + (1.725*fr)*d.t + (2.065*fr)*d.hr;
                const woba_val = woba_denom > 0 ? woba_num / woba_denom : 0;
    
                // wRAA
                const raw_wraa = ((woba_val - C.lg_woba) / C.woba_scale) * d.pa;
                const home_ratio = 0.5;
                const pf_coef = (home_ratio * pf) + ((1 - home_ratio) * (6 - pf) / 5);
                const parkAdj = (1 - pf_coef) * C.lg_r_pa * d.pa;
                const wraa = raw_wraa + parkAdj;
    
                // wRC = wRAA + (lg_R/PA * PA)
                return (wraa + (C.lg_r_pa * d.pa)).toFixed(1);
            }
        },
        {
            id: "xslg", category: "bat", title: "xSLG", full: "Expected Slugging Percentage",
            short: "期待長打率",
            desc: "打球速度と角度から、打球が本来どの程度の長打になる確率があったかを推定した指標。実際のSLGとの乖離で運不運を測る。",
            formula: "Statcast推定",
            criteria: ".400: 平均",
            related: ["slg", "xwoba"]
        },
        {
            id: "xwobacon", category: "bat", title: "xwOBAcon", full: "xwOBA on Contact",
            short: "打球のみのxwOBA（三振・四球除く）",
            desc: "バットに当たった打球がどれだけ得点価値を持っていたかを示す。コンタクト能力は無視し、純粋な「破壊力」を評価する。",
            formula: "Statcast推定",
            criteria: ".370前後: 平均"
        },
        {
            id: "barrels_pa", category: "bat", title: "Brls/PA%", full: "Barrels per Plate Appearance",
            short: "打席あたりのバレル率",
            desc: "全打席のうち、バレル打球（長打確率が非常に高い打球）を放った割合。長打力を示す信頼性の高い指標。",
            formula: "バレル数 ÷ 打席数",
            criteria: "4-5%: 平均 / 10%: 超一流"
        },
        {
            id: "la_avg", category: "bat", title: "LA", full: "Average Launch Angle",
            short: "平均打球角度",
            desc: "打球の平均角度。10度〜20度がラインドライブ（安打になりやすい）、25度〜30度がフライ（本塁打になりやすい）とされる。",
            formula: "平均値(度)",
            criteria: "12度: 平均"
        },
        {
            id: "ev_avg", category: "bat", title: "EV", full: "Average Exit Velocity",
            short: "平均打球速度",
            desc: "打球の平均速度。速いほど安打や長打になる確率が高い。近年最も重視される基礎能力の一つ。",
            formula: "平均値(km/h or mph)",
            criteria: "88mph (141km/h): 平均"
        },
        {
            id: "max_ev", category: "bat", title: "MaxEV", full: "Maximum Exit Velocity",
            short: "最高打球速度",
            desc: "その選手が記録した最も速い打球速度。打者のポテンシャル（限界能力）を示す。",
            criteria: "110mph (177km/h)以上: パワーヒッター"
        },
        {
            id: "sweet_spot", category: "bat", title: "SweetSpot%", full: "Sweet Spot Percentage",
            short: "最適角度（8〜32度）の打球割合",
            desc: "ヒットや長打になりやすい角度（スイートスポット）で打球を放った割合。",
            formula: "最適角度打球 ÷ 全打球",
            criteria: "33%: 平均"
        },
        {
            id: "pull_pct", category: "bat", title: "Pull%", full: "Pull Percentage",
            short: "引っ張り方向への打球割合",
            desc: "打球が引っ張り方向（右打者ならレフト側）に飛んだ割合。高いと長打力がある傾向だが、シフトを敷かれやすい。",
            formula: "引張打球 ÷ 全打球",
            criteria: "40%: 平均",
            inputs: [{id:'pull', label:'引張打球数'}, {id:'bbe', label:'全打球数'}],
            calc: (d) => d.bbe > 0 ? ((d.pull/d.bbe)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "oppo_pct", category: "bat", title: "Oppo%", full: "Opposite Field Percentage",
            short: "逆方向への打球割合",
            desc: "打球が流し方向（右打者ならライト側）に飛んだ割合。広角に打てる技術を示す。",
            formula: "逆方向打球 ÷ 全打球",
            criteria: "25%: 平均",
            inputs: [{id:'oppo', label:'逆方向打球数'}, {id:'bbe', label:'全打球数'}],
            calc: (d) => d.bbe > 0 ? ((d.oppo/d.bbe)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "gb_pct_bat", category: "bat", title: "GB% (Bat)", full: "Ground Ball Percentage (Batter)",
            short: "打者のゴロ率",
            desc: "打球に占めるゴロの割合。足の速い選手以外は低い方が好ましいとされる（ゴロは長打になりにくいため）。",
            formula: "ゴロ ÷ 全打球",
            criteria: "45%: 平均",
            inputs: [{id:'gb', label:'ゴロ数'}, {id:'bbe', label:'全打球数'}],
            calc: (d) => d.bbe > 0 ? ((d.gb/d.bbe)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "ld_pct", category: "bat", title: "LD%", full: "Line Drive Percentage",
            short: "ライナー率",
            desc: "打球に占めるライナーの割合。最も安打になりやすい打球。",
            formula: "ライナー ÷ 全打球",
            criteria: "21%: 平均",
            inputs: [{id:'ld', label:'ライナー数'}, {id:'bbe', label:'全打球数'}],
            calc: (d) => d.bbe > 0 ? ((d.ld/d.bbe)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "iffb_pct", category: "bat", title: "IFFB%", full: "Infield Fly Ball Percentage",
            short: "内野フライ率",
            desc: "フライに占める内野フライの割合。ほぼ自動的にアウトになるため、打者にとっては「最悪のフライ」。",
            formula: "内野フライ ÷ 全フライ",
            criteria: "10%: 平均",
            inputs: [{id:'iffb', label:'内野フライ'}, {id:'fb', label:'全フライ'}],
            calc: (d) => d.fb > 0 ? ((d.iffb/d.fb)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "swing_pct", category: "bat", title: "Swing%", full: "Swing Percentage",
            short: "スイング率",
            desc: "全投球に対してスイングした割合。積極性を示す。高すぎるとボール球に手を出しやすくなる傾向がある。",
            formula: "スイング ÷ 全投球",
            criteria: "47%: 平均"
        },
        {
            id: "contact_pct", category: "bat", title: "Contact%", full: "Contact Percentage",
            short: "コンタクト率",
            desc: "スイングした際にバットにボールが当たった（空振りしなかった）割合。",
            formula: "(スイング - 空振り) ÷ スイング",
            criteria: "76%: 平均"
        },
        {
            id: "z_contact_pct", category: "bat", title: "Z-Contact%", full: "Zone Contact Percentage",
            short: "ゾーン内コンタクト率",
            desc: "ストライクゾーン内の球をスイングした際のコンタクト率。この数値が高い打者は三振しにくい。",
            formula: "Statcast計測",
            criteria: "85%: 平均"
        },
        {
            id: "tav", category: "bat", title: "TAv", full: "True Average",
            short: "打撃の総合貢献度（打率スケール）",
            desc: "Baseball Prospectusが算出する総合指標。打率のような感覚で見ることができるが、出塁や長打の価値も適切に含まれている。",
            criteria: ".260: 平均"
        },
    
        /* --- Pitching (Advanced / Statcast) --- */
        {
            id: "era_minus", category: "pit", title: "ERA-", full: "ERA Minus",
            short: "パークファクター補正済み防御率（傑出度）",
            desc: "リーグ平均を100として防御率を指数化したもの。100より低いほど優秀（例：90なら平均より10%優れている）。球場の有利不利も補正される。",
            formula: "100 × (ERA ÷ (LgERA × PF))",
            criteria: "100: 平均 / 80: エース級",
            related: ["era", "fip_minus"],
            inputs: [
                {id:'er', label:'自責点'}, {id:'ip', label:'投球回'},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const era = d.ip > 0 ? (d.er * 9 / d.ip) : 0;
                const C = calcDerived(d);
                const pf = PARK_FACTORS[d.stadium].pf;
                const lg_era = C.lg_era_est; // 推定リーグ防御率
                
                // ERA- = 100 * (ERA / (LgERA * PF)) ※PFはリーグ平均に対するその球場の倍率
                // 簡易式として、球場補正をかけた平均防御率と比較する
                const adj_lg_era = lg_era * pf;
                return adj_lg_era > 0 ? (100 * (era / adj_lg_era)).toFixed(0) : "---";
            }
        },
        {
            id: "fip_minus", category: "pit", title: "FIP-", full: "FIP Minus",
            short: "パークファクター補正済みFIP（傑出度）",
            desc: "ERA-と同様に、FIPをリーグ平均と比較して指数化したもの。100より低いほど優秀。守備の影響を排除した真の投手力を比較するのに最適。",
            formula: "100 × (FIP ÷ (LgFIP × PF))",
            criteria: "100: 平均 / 80: エース級",
            related: ["fip", "era_minus"],
            inputs: [
                {id:'hr', label:'被本塁打'}, {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'}, {id:'so', label:'奪三振'}, {id:'ip', label:'投球回'},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                ...ADVANCED_LEAGUE_INPUTS
            ],
            calc: (d) => {
                const fip = d.ip > 0 ? ((13*d.hr + 3*(d.bb+d.hbp) - 2*d.so)/d.ip + 3.10) : 0;
                const C = calcDerived(d);
                // リーグFIPはリーグ防御率に近いと仮定（定数3.10を使っているため）
                // 正確にはリーグごとのFIP定数が必要だが、ここではLgERAを代用基準とする
                const pf = PARK_FACTORS[d.stadium].pf;
                const adj_lg_fip = C.lg_era_est * pf; 
                return adj_lg_fip > 0 ? (100 * (fip / adj_lg_fip)).toFixed(0) : "---";
            }
        },
        {
            id: "era_plus", category: "pit", title: "ERA+", full: "Adjusted ERA+",
            short: "ERA-の逆数版（大きいほど優秀）",
            desc: "リーグ平均防御率を自身の防御率で割ったもの。100が平均で、数値が大きいほど優れている（例：120なら平均より20%良い）。",
            formula: "100 × (LgERA × PF ÷ ERA)",
            criteria: "100: 平均 / 130: 優秀",
            related: ["era_minus"]
        },
        {
            id: "vaa", category: "pit", title: "VAA", full: "Vertical Approach Angle",
            short: "縦の進入角度",
            desc: "ホームベース通過時のボールの縦の角度。高めのストレートはVAAが浅い（地面と平行に近い）ほどホップして見え、空振りが取れやすい。",
            formula: "トラッキングデータ",
            criteria: "-4度台: ホップ型 / -6度台: 沈む球"
        },
        {
            id: "ivb", category: "pit", title: "IVB", full: "Induced Vertical Break",
            short: "伸び（ホップ成分）",
            desc: "重力の影響を除いた縦の変化量。ボールがどれだけ「落ちなかったか」を示す。数値が大きいほど打者の手元で伸びるストレートとなる。",
            formula: "トラッキングデータ",
            criteria: "18インチ以上: ノビがある"
        },
        {
            id: "spin_rate", category: "pit", title: "SpinRate", full: "Spin Rate",
            short: "回転数",
            desc: "ボールが1分間に回転する回数(rpm)。回転数が多いストレートは落ちにくく、カーブは大きく曲がる傾向がある。",
            formula: "回転数/分",
            criteria: "2200rpm: 直球平均"
        },
        {
            id: "bauer_units", category: "pit", title: "Bauer Units", full: "Bauer Units",
            short: "球速に対する回転数の比率",
            desc: "回転数を球速(mph)で割ったもの。球速に関わらず「回転の質」が高いかどうかを判断する目安となる。",
            formula: "回転数 ÷ 球速(mph)",
            criteria: "24.0: 平均",
            inputs: [{id:'spin', label:'回転数(rpm)'}, {id:'velo', label:'球速(mph)'}],
            calc: (d) => d.velo > 0 ? (d.spin / d.velo).toFixed(1) : "---"
        },
        {
            id: "extension", category: "pit", title: "Extension", full: "Extension",
            short: "リリースポイントの前のめり度",
            desc: "プレートからリリース位置までの距離。エクステンションが長いほど打者までの距離が縮まり、体感速度が上がる。",
            formula: "フィート(ft)",
            criteria: "6.3ft: 平均"
        },
        {
            id: "active_spin", category: "pit", title: "Active Spin", full: "Active Spin (Spin Efficiency)",
            short: "有効回転率",
            desc: "ボールの変化に寄与している回転の割合。100%に近いほど綺麗な縦回転（または横回転）で、変化の効率が良い。",
            formula: "有効回転 ÷ 総回転",
            criteria: "直球は高いほど良い"
        },
        {
            id: "meatball_pct", category: "pit", title: "Meatball%", full: "Meatball Percentage",
            short: "ど真ん中失投率",
            desc: "ストライクゾーンの真ん中付近（甘いコース）に投じられた球の割合。低いほどコマンド（制球）が良い。",
            formula: "Statcast計測",
            criteria: "7%: 平均"
        },
        {
            id: "putaway_pct", category: "pit", title: "PutAway%", full: "Put Away Percentage",
            short: "決め球での三振奪取率",
            desc: "2ストライクと追い込んだ状況で、その球種を投じた際に三振を奪えた割合。ウイニングショットの威力。",
            formula: "三振 ÷ 2ストライク後の投球数",
            criteria: "20%: 優秀"
        },
        {
            id: "edge_pct", category: "pit", title: "Edge%", full: "Edge Percentage",
            short: "エッジ（ゾーン境界）投球率",
            desc: "ストライクゾーンの境界線付近（幅ボール1個分）への投球割合。コマンド能力の高さを示す。",
            formula: "Statcast計測",
            criteria: "42%: 平均"
        },
        {
            id: "f_strike_pct", category: "pit", title: "F-Strike%", full: "First Pitch Strike Percentage",
            short: "初球ストライク率",
            desc: "初球でストライク（ファウル・インプレー含む）を取った割合。カウント有利に進める能力。",
            formula: "初球ストライク ÷ 全対戦数",
            criteria: "60%: 平均 / 65%以上: 優秀"
        },
        {
            id: "hr_fb_pit", category: "pit", title: "HR/FB (Pit)", full: "HR per Fly Ball (Pitcher)",
            short: "被フライあたりの被本塁打率",
            desc: "打たれたフライが本塁打になった割合。リーグ平均より極端に高い場合は「運が悪い」可能性があり、xFIPでの補正対象となる。",
            formula: "被本塁打 ÷ 被フライ数",
            criteria: "10-12%: 平均",
            inputs: [{id:'hr', label:'被本塁打'}, {id:'fb', label:'被フライ数'}],
            calc: (d) => d.fb > 0 ? ((d.hr/d.fb)*100).toFixed(1)+'%' : '---'
        },
        {
            id: "pace", category: "pit", title: "Pace", full: "Pace",
            short: "投球間隔（秒）",
            desc: "投手が前の投球から次の投球動作に入るまでの平均秒数。近年はピッチクロック導入により短縮傾向。",
            formula: "秒数",
            criteria: "速いほうが守備のリズムが良いとされる"
        },
    
        /* --- Fielding / Running / Other --- */
        {
            id: "oaa", category: "fld", title: "OAA", full: "Outs Above Average",
            short: "平均より多く取ったアウトの数",
            desc: "Statcastによる守備指標。打球の滞空時間や野手の移動距離から「アウト確率」を算出し、実際にアウトにしたかどうかで貢献度を積算する。",
            formula: "Statcast計測",
            criteria: "0: 平均 / +10: 名手"
        },
        {
            id: "frm", category: "fld", title: "FRM", full: "Catcher Framing",
            short: "フレーミング貢献度",
            desc: "捕手が際どいコースをストライクと判定させる技術（フレーミング）による得点貢献。",
            formula: "CSAA等を換算",
            criteria: "0: 平均"
        },
        {
            id: "pop_time", category: "fld", title: "Pop Time", full: "Pop Time",
            short: "ポップタイム（二塁送球時間）",
            desc: "捕手が捕球してから二塁ベース上の野手が捕球するまでの時間。盗塁阻止能力に直結する。",
            formula: "秒数",
            criteria: "2.0秒: 平均 / 1.8秒: 強肩"
        },
        {
            id: "exchange_time", category: "fld", title: "Exchange", full: "Exchange Time",
            short: "握り替え時間",
            desc: "捕手がボールを捕ってから手から離すまでの時間。ポップタイム短縮には肩の強さより重要とも言われる。",
            formula: "秒数",
            criteria: "0.7秒: 平均"
        },
        {
            id: "raa_fld", category: "fld", title: "RAA (Fld)", full: "Runs Above Average (Fielding)",
            short: "守備による平均比得点貢献",
            desc: "OAAを得点価値に換算した指標。UZRやDRSと同様にWARの守備要素として使われることが多い。",
            criteria: "0: 平均"
        },
        {
            id: "spd", category: "fld", title: "Spd", full: "Speed Score",
            short: "スピードスコア",
            desc: "盗塁成功率、三塁打、得点率、併殺打の少なさなどから算出される、選手の「足の速さ」を0〜10で評価した指標。ビル・ジェームズ考案。",
            formula: "0〜10のスコア",
            criteria: "4.5: 平均 / 7.0: 俊足"
        },
        {
            id: "sprint_speed", category: "fld", title: "Sprint Speed", full: "Sprint Speed",
            short: "スプリントスピード",
            desc: "全力疾走時のトップスピード（フィート/秒）。走力の最も純粋な指標。",
            formula: "ft/sec",
            criteria: "27ft/s: 平均 / 30ft/s: エリート"
        },
        {
            id: "hp_to_1b", category: "fld", title: "HP to 1B", full: "Home to First Base Time",
            short: "一塁到達タイム",
            desc: "打撃インパクトから一塁ベースに到達するまでの時間。左打者の方が有利になる傾向がある。",
            formula: "秒数",
            criteria: "4.3秒: 平均(右) / 4.2秒: 平均(左)"
        },
        {
            id: "baseruns", category: "tot", title: "BaseRuns", full: "BaseRuns",
            short: "チーム得点力の推計式",
            desc: "チームの安打、四球、本塁打などの要素から「理論上の総得点」を算出する。実際の得点との乖離を見ることで、運や勝負強さを分析できる。",
            formula: "BSR = A*B / (A+B) ...",
            criteria: "実際の得点と比較"
        },
        {
            id: "vorp", category: "tot", title: "VORP", full: "Value Over Replacement Player",
            short: "代替選手対比価値",
            desc: "WARの概念の先駆けとなった指標。ポジション補正を含まない攻撃の貢献度を得点数で表す。",
            criteria: "積み上げ指標"
        },
        {
            id: "log5", category: "tot", title: "Log5", full: "Log5 Method",
            short: "対戦勝率予測式",
            desc: "チームAとチームBの勝率から、直接対決した際の勝率を予測する計算式。",
            formula: "(A - A×B) ÷ (A + B - 2×A×B)",
            inputs: [{id:'wa', label:'A勝率(0.xxx)'}, {id:'wb', label:'B勝率(0.xxx)'}],
            calc: (d) => {
                const num = d.wa - (d.wa * d.wb);
                const den = d.wa + d.wb - (2 * d.wa * d.wb);
                return den !== 0 ? (num / den).toFixed(3) : "---";
            }
        },
        {
            id: "pli", category: "tot", title: "pLI", full: "Player Leverage Index",
            short: "平均重要局面指数",
            desc: "その選手が打席（またはマウンド）に立った場面の平均的な重要度。1.0より高い場合、勝敗を分ける重要な場面での起用が多かったことを示す。",
            criteria: "1.0: 平均"
        }
    ];
    // --- End Terms Database ---


    // --- Application Logic ---
    const grid = document.getElementById('grid');
    const modal = document.getElementById('modal');
    const modalTitleArea = document.getElementById('modal-title-area');
    const modalBodyContent = document.getElementById('modal-body-content');
    const searchInput = document.getElementById('searchInput');
    const filterChips = document.querySelectorAll('.filter-chip');
    const themeToggleBtn = document.getElementById('themeToggle');
    // 追加: 検索アイコンの要素
    const searchIconEl = document.getElementById('searchIcon');
    
    let currentFilter = 'all';
    let currentSearch = '';
    let currentTermId = null; 

    // Dark Mode Toggle Function
    function toggleTheme() {
        document.body.classList.toggle('dark-mode');
        // 修正: アイコンを動的に更新
        if (document.body.classList.contains('dark-mode')) {
            themeToggleBtn.innerHTML = icons.sun;
            themeToggleBtn.title = "Light Mode";
            localStorage.setItem('theme', 'dark');
        } else {
            themeToggleBtn.innerHTML = icons.moon;
            themeToggleBtn.title = "Dark Mode";
            localStorage.setItem('theme', 'light');
        }
    }
    
    // Initial theme check & icon setup
    (function() {
        // 1. 検索アイコンの設定
        if (searchIconEl) {
            searchIconEl.innerHTML = icons.search;
        }

        // 2. テーマ設定とアイコンの設定
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode');
            themeToggleBtn.innerHTML = icons.sun;
            themeToggleBtn.title = "Light Mode";
        } else {
             themeToggleBtn.innerHTML = icons.moon;
             themeToggleBtn.title = "Dark Mode";
        }
    })();


    function render() {
        grid.innerHTML = '';
        
        const filtered = terms.filter(term => {
            const catMatch = currentFilter === 'all' || term.category === currentFilter;
            const searchLower = currentSearch.toLowerCase();
            const searchMatch = !currentSearch || 
                term.title.toLowerCase().includes(searchLower) || 
                term.full.toLowerCase().includes(searchLower) ||
                term.short.includes(currentSearch) ||
                (term.desc && term.desc.includes(currentSearch));
            return catMatch && searchMatch;
        });

        if(filtered.length === 0) {
            grid.innerHTML = '<div class="no-result">一致する用語が見つかりませんでした。</div>';
            return;
        }

        filtered.forEach(term => {
            const el = document.createElement('div');
            el.className = `metric-card cat-${term.category}`;
            el.onclick = () => openModal(term.id);
            
            let catLabel = getCatLabel(term.category);
            
            // アイコンをSVGに置き換え
            let iconSvg = icons.calculator;
            if(term.aiMode) {
                iconSvg = icons.barChart;
            }
            const hasCalc = term.inputs ? `<span class="calc-icon ${term.aiMode ? 'ai' : ''}" title="${term.aiMode ? '推定' : '計算可能'}">${iconSvg}</span>` : '';
            
            el.innerHTML = `
                <div class="card-header">
                    <span class="card-tag">${catLabel}</span>
                    ${hasCalc}
                </div>
                <h3 class="metric-title">${term.title}</h3>
                <div class="metric-full">${term.full}</div>
                <p class="metric-desc">${term.short}</p>
            `;
            grid.appendChild(el);
        });
    }

    function getCatLabel(cat) {
        switch(cat){
            case 'bat': return "Batting";
            case 'pit': return "Pitching";
            case 'fld': return "Fielding";
            case 'tot': return "Overall";
            case 'std': return "Basic";
            default: return "";
        }
    }
    
    function getCatColor(cat) {
        switch(cat){
            case 'bat': return "#0ea5e9";
            case 'pit': return "#f43f5e";
            case 'fld': return "#d97706";
            case 'tot': return "#10b981";
            case 'std': return "#6366f1";
            default: return "#64748b";
        }
    }

    function handleSearch() {
        currentSearch = searchInput.value;
        render();
    }

    function filterCategory(cat) {
        currentFilter = cat;
        filterChips.forEach(chip => {
            if(chip.dataset.cat === cat) chip.classList.add('active');
            else chip.classList.remove('active');
        });
        render();
    }

    function createInputHtml(inp) {
        if(inp.type === 'select') {
            const opts = Object.keys(inp.options).map(k => `<option value="${k}">${inp.options[k]}</option>`).join('');
            return `
                <div class="calc-group">
                    <label class="calc-label">${inp.label}</label>
                    <select class="calc-select" id="calc-${inp.id}">
                        ${opts}
                    </select>
                </div>
            `;
        } else {
            // Handle default value if present
            // 修正: デフォルト値が0の場合はvalue属性に入れない（空欄にしてプレースホルダーを表示）
            let val = '';
            if (inp.default !== undefined) {
                val = inp.default === 0 ? '' : inp.default;
            }
            
            const advClass = inp.advanced ? 'advanced-input' : '';
            return `
                <div class="calc-group">
                    <label class="calc-label">${inp.label}</label>
                    <input type="number" class="calc-field ${advClass}" id="calc-${inp.id}" placeholder="0" value="${val}" ${inp.advanced ? 'oninput="checkAdvancedChanges()"' : ''}>
                </div>
            `;
        }
    }

    function openModal(id) {
        currentTermId = id; // Set current term ID
        const term = terms.find(t => t.id === id);
        if(!term) return;

        // Build Related HTML
        let relatedHtml = '';
        if(term.related && term.related.length > 0) {
            term.related.forEach(rid => {
                const rTerm = terms.find(t => t.id === rid);
                if(rTerm) {
                    relatedHtml += `<div class="rel-chip" onclick="event.stopPropagation(); openModal('${rid}')">${rTerm.title}</div>`;
                }
            });
        }

        // Build Calculator HTML if inputs exist
        let calcHtml = '';
        if(term.inputs && term.calc) {
            const basicInputs = [];
            const advancedInputs = [];

            term.inputs.forEach(inp => {
                if (inp.advanced) {
                    advancedInputs.push(inp);
                } else {
                    basicInputs.push(inp);
                }
            });

            const basicInputsHtml = basicInputs.map(inp => createInputHtml(inp)).join('');
            
            let advancedSectionHtml = '';
            if (advancedInputs.length > 0) {
                const advInputsHtml = advancedInputs.map(inp => createInputHtml(inp)).join('');
                
                // --- 追加: リーグ設定用プリセットUI ---
                const leaguePresetHtml = `
                    <div class="preset-bar" style="margin-bottom:15px; background:rgba(255,255,255,0.5); border:1px dashed var(--c-border);">
                        <div class="preset-label" style="width:auto; margin-right:auto;">${icons.gear} リーグ設定プリセット</div>
                        <select class="preset-select" id="league-preset-select" style="min-width:100px; font-size:0.85rem; padding:6px;">
                            <option value="">設定を選択...</option>
                        </select>
                        <button type="button" class="preset-btn btn-load" onclick="loadLeaguePreset()" style="padding:6px 10px; font-size:0.75rem;">読込</button>
                        <button type="button" class="preset-btn btn-del" onclick="removeLeaguePreset()" title="削除" style="padding:6px 10px;">${icons.trash}</button>
                        <input type="text" class="preset-input" id="league-preset-name" placeholder="設定名 (例: 2023セ)" style="min-width:100px; font-size:0.85rem; padding:6px;">
                        <button type="button" class="preset-btn btn-save" onclick="saveLeaguePreset()" style="padding:6px 10px; font-size:0.75rem;">保存</button>
                    </div>
                `;
                // --------------------------------------

                advancedSectionHtml = `
                    <details class="advanced-details">
                        <summary class="advanced-summary">
                            <span class="icon-gear">${icons.gear}</span>
                            詳細設定 (リーグ平均値など)
                        </summary>
                        <div class="advanced-content">
                            ${leaguePresetHtml}  ${advInputsHtml}
                        </div>
                        <div id="warning-box" class="warning-msg" style="display:none;">
                            詳細設定を変更すると精度が落ちる可能性があります
                        </div>
                    </details>
                `;
            }

            const aiClass = term.aiMode ? 'ai-mode' : '';
            const aiIcon = term.aiMode ? icons.barChart : icons.calculator;
            const aiText = term.aiMode ? '推定を実行' : 'CALCULATE';
            const titleText = term.aiMode ? 'ESTIMATOR' : 'SIMULATOR';
            const calcBtnIcon = term.aiMode ? icons.barChart : icons.calculator;
            const delIcon = icons.trash;
            const saveIcon = icons.save;

            // 見出しの句点を削除
            calcHtml = `
                <div class="section-label has-hash">LABORATORY / ${aiText}</div>
                <div class="calc-container ${aiClass}" id="calc-container">
                    <div class="calc-title">
                        <div><span>${aiIcon}</span> ${term.title} ${titleText}</div>
                    </div>
                    
                    <!-- Preset Controls -->
                    <div class="preset-bar">
                        <div class="preset-label">${saveIcon} 成績プリセット (自動入力)</div>
                        <select class="preset-select" id="preset-select">
                            <option value="">保存データを選択...</option>
                        </select>
                        <button type="button" class="preset-btn btn-load" onclick="loadPreset()">読込</button>
                        <button type="button" class="preset-btn btn-del" onclick="removePreset()" title="削除">${delIcon}</button>
                        <div style="flex-basis: 100%; height: 0; margin: 0;"></div> <!-- Line break for visual -->
                        <input type="text" class="preset-input" id="preset-name" placeholder="新規保存名 (例: 2024山田)">
                        <button type="button" class="preset-btn btn-save" onclick="savePreset()">保存</button>
                    </div>

                    <div class="calc-inputs">
                        ${basicInputsHtml}
                        ${advancedSectionHtml}
                    </div>
                    <button class="calc-btn" onclick="calculateMetric('${term.id}')">
                        ${calcBtnIcon} ${aiText}
                    </button>
                    <div class="calc-result-area">
                        <div class="calc-res-label">RESULT ${term.aiMode ? '<span>推定値</span>' : ''}:</div>
                        <div class="calc-res-value" id="calc-result">---</div>
                    </div>
                </div>
            `;
        }

        const catLabel = getCatLabel(term.category);
        const catColor = getCatColor(term.category);

        // Header
        modalTitleArea.innerHTML = `
            <div class="m-cat" style="color:${catColor}">${catLabel}</div>
            <h2 class="m-title">${term.title}</h2>
            <div class="m-full">${term.full}</div>
        `;

        // Body
        modalBodyContent.innerHTML = `
            <p style="font-size:1.2rem; font-weight:700; line-height:1.6; color:var(--c-text-primary);">${term.short}</p>
            ${term.desc ? `<p style="color:var(--c-text-secondary); line-height:1.8;">${term.desc}</p>` : ''}

            <div class="section-label has-hash">計算式 / FORMULA</div>
            <div class="formula-box">${term.formula}</div>

            ${calcHtml}

            <div class="section-label has-hash">評価基準 / CRITERIA</div>
            <table class="criteria-table">
                <tr><th>目安</th><td>${term.criteria || '---'}</td></tr>
            </table>

            <div class="section-label has-hash">関連指標 / RELATED</div>
            <div class="related-grid">${relatedHtml || '<span style="color:#94a3b8; font-size:0.9rem">なし</span>'}</div>
        `;

        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });

        // Initialize Preset List
        updatePresetList();
        updateLeaguePresetList();
    }

    // Logic to check advanced inputs
    window.checkAdvancedChanges = function() {
        const warningBox = document.getElementById('warning-box');
        if (!warningBox) return;

        const advInputs = document.querySelectorAll('.advanced-input');
        let isChanged = false;

        advInputs.forEach(input => {
            const key = input.id.replace('calc-', '').toUpperCase();
            const defVal = DEFAULTS[key];
            if (defVal !== undefined && parseFloat(input.value) !== defVal) {
                isChanged = true;
            }
        });

        warningBox.style.display = isChanged ? 'flex' : 'none';
    }

    // Calculation Function
    window.calculateMetric = function(id) {
        const term = terms.find(t => t.id === id);
        if(!term || !term.inputs) return;

        const data = {};
        let allFilled = true;
        
        term.inputs.forEach(inp => {
            const el = document.getElementById(`calc-${inp.id}`);
            const val = el.value;
            
            // 必須入力のチェック (select以外でadvanced:trueが設定されていないもの)
            const isBasicRequired = inp.type !== 'select' && !inp.advanced;
            if (isBasicRequired && val === '') {
                allFilled = false;
            }
            
            if(inp.type === 'select') {
                data[inp.id] = val;
            } else {
                data[inp.id] = parseFloat(val) || 0;
            }
        });

        if(!allFilled && !confirm("未入力の必須項目は0として計算しますか？")) return;

        const result = term.calc(data);
        
        const resDiv = document.getElementById('calc-result');
        resDiv.style.opacity = 0;
        resDiv.style.transform = "translateY(10px)";
        setTimeout(() => {
            resDiv.innerHTML = result;
            resDiv.style.transition = "all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)";
            resDiv.style.opacity = 1;
            resDiv.style.transform = "translateY(0)";
        }, 50);
    }

    function closeModal() {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }

    function closeModalOutside(e) {
        if (e.target === modal) closeModal();
    }

    /* --- Batch Calculator Logic --- */
    function openBatchCalc(mode) {
        const isBat = mode === 'bat';
        const title = isBat ? "野手指標 一括計算" : "投手指標 一括計算";
        const catColor = isBat ? getCatColor('bat') : getCatColor('pit');
        
        // Define input fields for batch mode
        let fields = [];
        if (isBat) {
            fields = [
                {id:'pa', label:'打席数'}, {id:'ab', label:'打数'},
                {id:'h', label:'安打'}, {id:'d', label:'二塁打'}, {id:'t', label:'三塁打'}, {id:'hr', label:'本塁打'},
                {id:'bb', label:'四球'}, {id:'hbp', label:'死球'}, {id:'so', label:'三振'},
                {id:'sf', label:'犠飛'}, {id:'sh', label:'犠打'},
                {id:'sb', label:'盗塁'}, {id:'cs', label:'盗塁死'},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'pos', label:'守備位置', type:'select', options:{'dh':'DH', '1b':'一塁', 'lf':'左翼', 'rf':'右翼', '3b':'三塁', '2b':'二塁', 'cf':'中堅', 'ss':'遊撃', 'c':'捕手'}},
                {id:'def', label:'守備評価', type:'select', options:{'0':'平均的 (0)', '5':'上手い (+5)', '10':'名手 (+10)', '15':'神 (+15)', '-5':'苦手 (-5)', '-10':'下手 (-10)'}}
            ];
        } else {
            fields = [
                {id:'ip', label:'投球回'}, {id:'r', label:'失点'},
                {id:'h', label:'被安打'}, {id:'hr', label:'被本塁打'}, 
                {id:'bb', label:'与四球'}, {id:'hbp', label:'与死球'},
                {id:'so', label:'奪三振'}, {id:'bf', label:'打者数'}, // 追加: K%, BB%用
                // 変更: 実数入力廃止 -> 傾向選択へ
                {id:'gb_type', label:'打球傾向(GB%)', type:'select', options:{
                    '55':'55% (超ゴロP)', 
                    '50':'50% (ゴロP)', 
                    '45':'45% (平均)', 
                    '40':'40% (フライP)', 
                    '35':'35% (超フライP)'
                }},
                {id:'stadium', label:'本拠地', type:'select', options: Object.keys(PARK_FACTORS).reduce((acc, key) => ({...acc, [key]: PARK_FACTORS[key].name}), {})},
                {id:'role', label:'役割', type:'select', options:{'sp':'先発', 'rp':'救援'}}
            ];
        }

        // Generate HTML
        const inputsHtml = fields.map(inp => createInputHtml(inp)).join('');
        
        // Generate Advanced Settings (Unified)
        const advInputsHtml = ADVANCED_LEAGUE_INPUTS.map(inp => createInputHtml(inp)).join('');

        // Smart Parser HTML (Text Only AI)
        const parserHtml = `
            <div class="parser-area" style="border-color:${catColor}">
                <div style="font-size:0.8rem; font-weight:700; color:var(--c-text-secondary); margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                    <span>${icons.sparkle} AIテキスト解析 (AI ANALYZER)</span>
                    <span style="font-size:0.7em; background:#e2e8f0; padding:2px 6px; border-radius:4px;">TEXT MODE</span>
                </div>
                <textarea class="parser-textarea" id="smart-text" placeholder="ここにWebサイトの成績表などをコピー＆ペーストしてください...&#13;&#10;（例：打率.300 試合143 本塁打20...）"></textarea>
                
                <button class="parser-btn" id="parser-btn" onclick="parseSmartContent('${mode}')" style="background:${catColor}">
                    <span>${icons.sparkle}</span> AIでテキストを解析して入力
                </button>
                <div id="parser-msg" style="font-size:0.85rem; color:var(--c-text-secondary); margin-top:10px; text-align:center; display:none; line-height:1.5;"></div>
            </div>
        `;

        const saveIcon = icons.save;
        const delIcon = icons.trash;
        const gearIcon = icons.gear;

        const html = `
            <div class="section-label has-hash">INPUT DATA / データ入力</div>
            <div class="calc-container" style="border-color:${catColor}">
                
                ${parserHtml}

                <!-- Preset Controls -->
                <div class="preset-bar">
                    <div class="preset-label">${saveIcon} 成績プリセット (自動入力)</div>
                    <select class="preset-select" id="preset-select">
                        <option value="">保存データを選択...</option>
                    </select>
                    <button type="button" class="preset-btn btn-load" onclick="loadPreset()">読込</button>
                    <button type="button" class="preset-btn btn-del" onclick="removePreset()" title="削除">${delIcon}</button>
                    <div style="flex-basis: 100%; height: 0; margin: 0;"></div> <!-- Line break for visual -->
                    <input type="text" class="preset-input" id="preset-name" placeholder="新規保存名 (例: 2024山田)">
                    <button type="button" class="preset-btn btn-save" onclick="savePreset()">保存</button>
                </div>

                <div class="calc-inputs">
                    ${inputsHtml}
                    <details class="advanced-details">
                        <summary class="advanced-summary">
                            <span class="icon-gear">${gearIcon}</span>
                            詳細設定 (リーグ平均値など)
                        </summary>
                        <div class="advanced-content">
                            <div class="preset-bar" style="margin-bottom:15px; background:rgba(255,255,255,0.5); border:1px dashed var(--c-border);">
                                <div class="preset-label" style="width:auto; margin-right:auto;">${icons.gear} リーグ設定プリセット</div>
                                <select class="preset-select" id="league-preset-select" style="min-width:100px; font-size:0.85rem; padding:6px;">
                                    <option value="">設定を選択...</option>
                                </select>
                                <button type="button" class="preset-btn btn-load" onclick="loadLeaguePreset()" style="padding:6px 10px; font-size:0.75rem;">読込</button>
                                <button type="button" class="preset-btn btn-del" onclick="removeLeaguePreset()" title="削除" style="padding:6px 10px;">${icons.trash}</button>
                                <input type="text" class="preset-input" id="league-preset-name" placeholder="設定名 (例: 2023セ)" style="min-width:100px; font-size:0.85rem; padding:6px;">
                                <button type="button" class="preset-btn btn-save" onclick="saveLeaguePreset()" style="padding:6px 10px; font-size:0.75rem;">保存</button>
                            </div>
                            ${advInputsHtml}
                        </div>
                    </details>
                </div>
                <button class="calc-btn" style="background:${catColor}" onclick="runBatchCalc('${mode}')">
                    ${icons.barChart} 一括計算実行 (CALCULATE ALL)
                </button>
            </div>
            <div id="batch-results-area" style="margin-top:30px;"></div>
        `;

        modalTitleArea.innerHTML = `
            <div class="m-cat" style="color:${catColor}">BATCH CALCULATOR</div>
            <h2 class="m-title">${title}</h2>
        `;
        modalBodyContent.innerHTML = html;
        
        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
        
        updatePresetList();
        updateLeaguePresetList();
    }

    // --- Smart Text Parser Logic ---
    window.parseSmartContent = function(mode) {
        const textInput = document.getElementById('smart-text');
        const btn = document.getElementById('parser-btn');
        const msg = document.getElementById('parser-msg');

        const text = textInput.value.trim();

        if (!text) {
            // alert("テキストを入力してください"); // 警告をカスタムメッセージに変更
            msg.style.display = 'block';
            msg.innerHTML = `<div style="color:#ef4444;">❌ テキストを入力してください。</div>`;
            return;
        }

        // AI分析演出
        btn.innerHTML = `${icons.loader} テキスト構造を解析中...`;
        btn.classList.add('analyzing');
        msg.style.display = 'none';

        setTimeout(() => {
            // 解析実行
            btn.innerHTML = `${icons.sparkle} AIでテキストを解析して入力`;
            btn.classList.remove('analyzing');
            
            runParser(text, mode);
            
        }, 800); // 演出用のウェイト
    };

    function runParser(text, mode) {
        const msg = document.getElementById('parser-msg');
        
        // AI Analysis Logic (Advanced Regex Pattern Matching)
        // Added synonyms for better matching
        const mapBat = {
            '打席': 'pa', '打数': 'ab', '安打': 'h', '二塁打': 'd', '三塁打': 't', '本塁打': 'hr', '本': 'hr', 'HR': 'hr',
            '四球': 'bb', '死球': 'hbp', '三振': 'so', '犠飛': 'sf', '犠打': 'sh', '盗塁': 'sb', '盗塁死': 'cs', '併殺': 'gidp'
        };
        const mapPit = {
            // 修正: WHIPの"IP"に反応しないように (?<!WH) を追加
            '回': 'ip', '投球回': 'ip', 'IP': 'ip', 
            '失点': 'r', '自責': 'er', '被安打': 'h', '被本塁打': 'hr', '被本': 'hr',
            // 修正: 無四球の"四球"に反応しないように (?<!無) を追加
            '与四球': 'bb', '四球': 'bb', 
            '与死球': 'hbp', '死球': 'hbp', '奪三振': 'so', '三振': 'so', '打者': 'bf'
        };

        const map = mode === 'bat' ? mapBat : mapPit;
        let count = 0;
        let extractedInfo = [];

        for (const [key, id] of Object.entries(map)) {
            // Regex: Label followed by space/colon/tab, then number
            const regex = new RegExp(`${key}[:\\s　]*([0-9]+(?:\\.[0-9]+)?)`, 'g');
            let match;
            // Need to handle regex.exec(text) iteration correctly if text contains multiple matches for one key (e.g., '四球 20 四球 30')
            // For simplicity, we use matchAll and take the last match.
            const matches = [...text.matchAll(regex)];
            if(matches.length > 0) {
                match = matches[matches.length - 1]; // Take the last match
            }

            if(match) {
                const val = parseFloat(match[1]);
                const el = document.getElementById(`calc-${id}`);
                if(el) {
                    el.value = val;
                    el.style.backgroundColor = "#dcfce7"; // Success Color
                    setTimeout(()=>el.style.backgroundColor="", 2000);
                    count++;
                    if(extractedInfo.length < 6) extractedInfo.push(key);
                }
            }
        }

        msg.style.display = 'block';
        if (count > 0) {
            msg.innerHTML = `
                <div style="color:var(--cat-tot); font-weight:bold;">
                    ${icons.sparkle} 解析完了: ${count} 項目を抽出しました
                </div>
                <div style="font-size:0.8em; color:var(--c-text-secondary);">
                    検出: ${extractedInfo.join(', ')}${extractedInfo.length>=6 ? '...' : ''}
                </div>
            `;
        } else {
            msg.innerHTML = `
                <div style="color:#ef4444;">
                    ❌ データが見つかりませんでした。<br>
                    「打率.300 本塁打20」のように項目名と数字が含まれるテキストを貼り付けてください。
                </div>
            `;
        }
    }

    let radarChartInstance = null;

    function runBatchCalc(mode) {
        const isBat = mode === 'bat';
        const data = {};
        
        // Collect all inputs
        const inputs = document.querySelectorAll('.calc-field, .calc-select');
        inputs.forEach(el => {
            const id = el.id.replace('calc-', '');
            if(el.tagName === 'SELECT') {
                data[id] = el.value;
            } else {
                data[id] = parseFloat(el.value) || 0;
            }
        });
        
        // 必須のリーグ平均値をデータオブジェクトに注入 (calcDerivedの依存関係を解決するため)
        ADVANCED_LEAGUE_INPUTS.forEach(inp => {
            const id = inp.id;
            const el = document.getElementById(`calc-${id}`);
            data[id] = parseFloat(el.value) || inp.default || 0;
        });

        // Calculate Indicators
        let results = [];
        
        // ユーザー指定の指標IDリストを更新 (ISO, xFIPを追加)
        const targetIds = isBat ? 
            ['war', 'wrc_plus', 'woba', 'iso', 'babip', 'k_pct', 'bb_pct', 'wsb'] : 
            ['pit_war', 'fip', 'xfip', 'siera', 'k_pct_pit', 'bb_pct_pit'];

        terms.forEach(term => {
            if (targetIds.includes(term.id) && term.calc) {
                try {
                    // ISO, wsb, wrc_plusが正しく計算されるよう、必要な入力を事前に準備
                    if (isBat) {
                        if (term.id === 'iso') {
                            // ISOを計算するために必要なSLG, AVGを計算
                            const tb = (data.h - (data.d+data.t+data.hr) + 2*data.d + 3*data.t + 4*data.hr) || 0;
                            const slg = data.ab > 0 ? tb / data.ab : 0;
                            const avg = data.ab > 0 ? data.h / data.ab : 0;
                            data.slg = slg;
                            data.avg = avg;
                        } else if (term.id === 'k_pct' || term.id === 'bb_pct') {
                            // K%とBB%の計算にはPAが必要
                            if (data.pa === 0) return;
                        }
                    }

                    const res = term.calc(data);
                    if (res !== "---" && res !== "NaN" && res !== "Infinity") {
                        results.push({
                            title: term.title,
                            full: term.full,
                            value: res,
                            criteria: term.criteria,
                            cat: term.category,
                            id: term.id
                        });
                    }
                } catch(e) {
                    console.error(`Error calculating ${term.id}:`, e);
                }
            }
        });

        // --- Radar Chart Logic ---
        let radarHtml = '';
        if (results.length > 0) {
            radarHtml = `
                <div class="chart-wrapper">
                    <canvas id="radarChart"></canvas>
                </div>
                <div style="font-size:0.75rem; color:var(--c-text-secondary); text-align:center; margin-bottom:20px; line-height:1.5;">
                    <strong>【レーダーチャート評価項目】</strong><br>
                    ${mode === 'bat' 
                        ? '総合攻撃力(wRC+) / パワー(ISO) / 走力(wSB) / 選球眼(BB%) / 守備(UZR)' 
                        : '球威(K%) / 制球(BB%) / 将来性(xFIP) / 真の実力(SIERA) / ゴロ率(GB%)'}
                </div>
            `;
        }

        // Render Table
        if (results.length === 0) {
            document.getElementById('batch-results-area').innerHTML = '<div class="no-result">計算可能な指標がありませんでした。</div>';
            return;
        }

        let tableHtml = `
            <div class="section-label has-hash">ANALYSIS RESULTS / 分析結果</div>
            ${radarHtml}
            <table class="criteria-table" style="margin-top:20px;">
                <thead>
                    <tr style="background:var(--c-bg);">
                        <th style="padding-left:10px;">指標 (METRIC)</th>
                        <th style="text-align:right; padding-right:20px;">値 (VALUE)</th>
                        <th>基準 (CRITERIA)</th>
                    </tr>
                </thead>
                <tbody>
        `;

        results.forEach(r => {
            const catColor = getCatColor(r.cat);
            tableHtml += `
                <tr>
                    <td style="padding-left:10px;">
                        <span style="color:${catColor}; font-weight:900;">${r.title}</span>
                        <div style="font-size:0.75rem; color:var(--c-text-secondary);">${r.full}</div>
                    </td>
                    <td style="text-align:right; padding-right:20px; font-family:var(--font-mono); font-size:1.5rem; font-weight:700; color:var(--c-text-primary);">
                        ${r.value}
                    </td>
                    <td style="font-size:0.85rem; color:var(--c-text-secondary);">
                        ${r.criteria || '-'}
                    </td>
                </tr>
            `;
        });

        tableHtml += `</tbody></table>`;
        
        // 📋をSVGに置き換え
        tableHtml += `
            <button class="calc-btn" style="margin-top:20px; background:var(--c-text-secondary);" onclick="copyBatchResults()">
                ${icons.clipboard} 結果をコピー (COPY TEXT)
            </button>
        `;

        const resArea = document.getElementById('batch-results-area');
        resArea.innerHTML = tableHtml;
        resArea.scrollIntoView({behavior: 'smooth'});

        // --- Render Chart ---
        if (radarChartInstance) {
            radarChartInstance.destroy();
        }
        
        const ctx = document.getElementById('radarChart');
        if (ctx) {
            // Calculate Scores (0-100)
            let scores = [];
            let labels = [];
            
            // Helper function to calculate raw metric values needed for the chart, even if they weren't in the table.
            const calculateMetricValue = (id, inputData) => {
                const term = terms.find(t => t.id === id);
                if (term && term.calc) {
                    try {
                        const val = term.calc(inputData);
                        return parseFloat(val) || 0;
                    } catch(e) {
                        return 0; // Return 0 if calculation fails
                    }
                }
                return 0;
            };

            if (isBat) {
                // Batting Scores
                // 1. wRC+ (Overall Offense): 40(min) - 180(max) -> 100 is avg
                const wrc = calculateMetricValue('wrc_plus', data);
                const scoreWrc = Math.min(100, Math.max(0, (wrc - 40) / 140 * 100));
                
                // 2. ISO (Power): .050 - .350
                const tb = (data.h - (data.d+data.t+data.hr) + 2*data.d + 3*data.t + 4*data.hr) || 0;
                const slg = data.ab > 0 ? tb / data.ab : 0;
                const avg = data.ab > 0 ? data.h / data.ab : 0;
                const iso = slg - avg;
                const scoreIso = Math.min(100, Math.max(0, (iso - 0.050) / 0.300 * 100));
                
                // 3. wSB (Speed/Running): -5 - +10
                const wsb = calculateMetricValue('wsb', data);
                const scoreWsb = Math.min(100, Math.max(0, (wsb - (-5)) / 15 * 100));
                
                // 4. BB% (Eye): 3% - 18%
                const bb_pct = data.pa > 0 ? data.bb / data.pa : 0;
                const scoreBb = Math.min(100, Math.max(0, (bb_pct - 0.03) / 0.15 * 100));
                
                // 5. UZR (Defense): -15 - +15
                const uzr = parseFloat(data.def) || 0;
                const scoreUzr = Math.min(100, Math.max(0, (uzr - (-15)) / 30 * 100));

                labels = ['wRC+', 'ISO', 'wSB', 'BB%', 'UZR'];
                scores = [scoreWrc, scoreIso, scoreWsb, scoreBb, scoreUzr];

            } else {
                // Pitching Scores
                // 1. K% (Stuff): 10% - 35%
                const k_pct = data.bf > 0 ? data.so / data.bf : 0;
                const scoreK = Math.min(100, Math.max(0, (k_pct - 0.10) / 0.25 * 100));
                
                // 2. BB% (Control): 15% - 2% (Reverse)
                const bb_pct = data.bf > 0 ? data.bb / data.bf : 0.10;
                const scoreBb = Math.min(100, Math.max(0, (0.15 - bb_pct) / 0.13 * 100));
                
                // 3. xFIP (Expected Performance): 6.00 - 2.00 (Reverse)
                const xfip = calculateMetricValue('xfip', data); // Recalculate xFIP using input data
                const scoreXfip = Math.min(100, Math.max(0, (6.00 - xfip) / 4.00 * 100));
                
                // 4. SIERA (True Skill): 6.00 - 2.00 (Reverse)
                const siera = calculateMetricValue('siera', data); // Recalculate SIERA using input data
                const scoreSiera = Math.min(100, Math.max(0, (6.00 - siera) / 4.00 * 100));
                
                // 5. GB% (Groundball): 30% - 60%
                const gb_pct = parseFloat(data.gb_type || 45) / 100;
                const scoreGb = Math.min(100, Math.max(0, (gb_pct - 0.30) / 0.30 * 100));

                labels = ['K%', 'BB%', 'xFIP', 'SIERA', 'GB%'];
                scores = [scoreK, scoreBb, scoreXfip, scoreSiera, scoreGb];
            }

            radarChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Score',
                        data: scores,
                        backgroundColor: isBat ? 'rgba(14, 165, 233, 0.2)' : 'rgba(244, 63, 94, 0.2)',
                        borderColor: isBat ? '#0ea5e9' : '#f43f5e',
                        pointBackgroundColor: '#fff',
                        pointBorderColor: isBat ? '#0ea5e9' : '#f43f5e',
                        borderWidth: 2
                    }]
                },
                options: {
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            ticks: { display: false }, // Hide numbers
                            pointLabels: {
                                font: { size: 14, weight: '800', family: 'var(--font-mono)' },
                                color: document.body.classList.contains('dark-mode') ? '#94a3b8' : '#475569'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(51, 65, 85, 0.5)' : 'rgba(203, 213, 225, 0.5)'
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
    }

    function copyBatchResults() {
        const rows = document.querySelectorAll('#batch-results-area tr');
        let text = "【SABR METRICS LAB Calculation Results】\n";
        rows.forEach((row, i) => {
            if(i===0) return; // skip header
            const cols = row.querySelectorAll('td');
            if(cols.length > 0) {
                const metric = cols[0].querySelector('span').innerText;
                const value = cols[1].innerText.trim();
                text += `${metric}: ${value}\n`;
            }
        });

        // Fallback approach for iframe/sandbox environments
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        textArea.style.opacity = "0";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if(successful) {
                alert("クリップボードにコピーしました！");
            } else {
                alert("コピーに失敗しました。");
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            alert("コピーに失敗しました。");
        }

        document.body.removeChild(textArea);
    }

    /* --- Preset Logic (LocalStorage) --- */
    const STORAGE_KEY = 'sabr_metrics_presets';

    function getPresets() {
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Failed to parse presets", e);
            return {};
        }
    }

    function savePresets(presets) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(presets));
    }

    function updatePresetList() {
        const select = document.getElementById('preset-select');
        if (!select) return;

        const presets = getPresets();
        select.innerHTML = '<option value="">保存データを選択...</option>';
        
        Object.keys(presets).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        });
    }

    window.savePreset = function() {
        const nameInput = document.getElementById('preset-name');
        const name = nameInput.value.trim();
        
        if (!name) {
            alert('保存名を入力してください');
            return;
        }

        // Collect current input values
        const inputs = document.querySelectorAll('.calc-field, .calc-select');
        const data = {};
        let hasData = false;

        inputs.forEach(input => {
            // Strip "calc-" prefix from ID
            const key = input.id.replace('calc-', '');
            if (input.value) {
                data[key] = input.value;
                hasData = true;
            }
        });

        if (!hasData) {
            alert('保存するデータがありません');
            return;
        }

        const presets = getPresets();
        if (presets[name] && !confirm(`"${name}" は既に存在します。上書きしますか？`)) {
            return;
        }

        presets[name] = data;
        savePresets(presets);
        
        updatePresetList();
        document.getElementById('preset-select').value = name;
        nameInput.value = ''; // clear input
        alert(`"${name}" を保存しました`);
    }

    window.loadPreset = function() {
        const select = document.getElementById('preset-select');
        const name = select.value;
        
        if (!name) return;

        const presets = getPresets();
        const data = presets[name];
        
        if (data) {
            let count = 0;
            Object.keys(data).forEach(key => {
                const el = document.getElementById(`calc-${key}`);
                if (el) {
                    el.value = data[key];
                    // Visual feedback
                    el.style.backgroundColor = "#f0fdf4";
                    setTimeout(() => el.style.backgroundColor = "", 1000);
                    count++;
                }
            });
            
            // Trigger advanced check if any advanced inputs were loaded
            if (window.checkAdvancedChanges) window.checkAdvancedChanges();
        }
    }

    window.removePreset = function() {
        const select = document.getElementById('preset-select');
        const name = select.value;
        
        if (!name) return;

        // "Are you sure?" confirmation removed for easier deletion
        const presets = getPresets();
        if (presets[name]) {
            delete presets[name];
            savePresets(presets);
            updatePresetList();
            select.value = ""; // Reset selection
            alert(`"${name}" を削除しました`);
        }
    }
    /* --- League Preset Logic (Advanced Settings) --- */
    const LEAGUE_STORAGE_KEY = 'sabr_league_presets';

    function getLeaguePresets() {
        try {
            const stored = localStorage.getItem(LEAGUE_STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Failed to parse league presets", e);
            return {};
        }
    }

    function saveLeaguePresets(presets) {
        localStorage.setItem(LEAGUE_STORAGE_KEY, JSON.stringify(presets));
    }

    window.updateLeaguePresetList = function() {
        const select = document.getElementById('league-preset-select');
        if (!select) return;

        const presets = getLeaguePresets();
        select.innerHTML = '<option value="">設定を選択...</option>';
        
        Object.keys(presets).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        });
    }

    window.saveLeaguePreset = function() {
        const nameInput = document.getElementById('league-preset-name');
        const name = nameInput.value.trim();
        
        if (!name) {
            alert('設定名を入力してください');
            return;
        }

        const data = {};
        // ADVANCED_LEAGUE_INPUTS で定義されたIDのみを収集
        ADVANCED_LEAGUE_INPUTS.forEach(inp => {
            const el = document.getElementById(`calc-${inp.id}`);
            if (el && el.value) {
                data[inp.id] = el.value;
            }
        });

        if (Object.keys(data).length === 0) {
            alert('保存する詳細設定データがありません');
            return;
        }

        const presets = getLeaguePresets();
        if (presets[name] && !confirm(`"${name}" は既に存在します。上書きしますか？`)) {
            return;
        }

        presets[name] = data;
        saveLeaguePresets(presets);
        
        updateLeaguePresetList();
        document.getElementById('league-preset-select').value = name;
        nameInput.value = '';
        alert(`リーグ設定 "${name}" を保存しました`);
    }

    window.loadLeaguePreset = function() {
        const select = document.getElementById('league-preset-select');
        const name = select.value;
        if (!name) return;

        const presets = getLeaguePresets();
        const data = presets[name];
        
        if (data) {
            Object.keys(data).forEach(key => {
                const el = document.getElementById(`calc-${key}`);
                if (el) {
                    el.value = data[key];
                    // 視覚的フィードバック
                    el.style.backgroundColor = "#e0f2fe"; // 薄い青
                    setTimeout(() => el.style.backgroundColor = "", 1000);
                }
            });
            // 変更検知（警告表示の更新など）
            if (window.checkAdvancedChanges) window.checkAdvancedChanges();
        }
    }

    window.removeLeaguePreset = function() {
        const select = document.getElementById('league-preset-select');
        const name = select.value;
        if (!name) return;

        const presets = getLeaguePresets();
        if (presets[name]) {
            delete presets[name];
            saveLeaguePresets(presets);
            updateLeaguePresetList();
            select.value = "";
            alert(`リーグ設定 "${name}" を削除しました`);
        }
    }

/* --- Tool Menu Logic (修正版) --- */
    function openToolMenu() {
        const title = "LABORATORY TOOLS";
        const catColor = "var(--c-text-primary)";
    
        // ツール一覧の定義
        // keepOpen: true の場合、メニューと同じウィンドウを使うため closeModal() を実行しない
        const tools = [
            { 
                id: 'batch-bat', name: '野手一括計算', 
                icon: icons.calculator, func: "openBatchCalc('bat')", 
                color: 'var(--cat-bat)', desc: '打撃・守備指標をまとめて計算',
                keepOpen: true
            },
            { 
                id: 'batch-pit', name: '投手一括計算', 
                icon: icons.calculator, func: "openBatchCalc('pit')", 
                color: 'var(--cat-pit)', desc: '投球指標・FIP等をまとめて計算',
                keepOpen: true
            },
            { 
                id: 'galaxy', name: 'GALAXY EXPLORER', 
                icon: icons.sparkle, func: "openMindMap()", 
                color: '#8b5cf6', desc: '指標の関係性を宇宙地図で探索',
                keepOpen: false // マインドマップは別画面なのでメニューを閉じる
            },
            { 
                id: 'gm', name: 'GM CHALLENGE', 
                icon: icons.barChart, func: "openGMChallenge()", 
                color: '#10b981', desc: '最強チーム編成シミュレーション',
                keepOpen: true
            },
            { 
                id: 'career', name: 'MY CAREER', 
                icon: icons.save, func: "openCareerSim()", 
                color: '#d97706', desc: '選手人生シミュレーション',
                keepOpen: true
            }
        ];
    
        let html = `<div class="grid-container" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); padding:0; gap:15px; max-width:100%;">`;
        
        let count = 0;
        tools.forEach(t => {
            const fnName = t.func.split('(')[0];
            if (typeof window[fnName] === 'function') {
                // keepOpenフラグに応じて closeModal() を呼ぶか決定
                const clickAction = t.keepOpen ? t.func : `${t.func}; closeModal();`;
                
                html += `
                    <div onclick="${clickAction}" style="
                        background:var(--c-bg); border:1px solid var(--c-border); border-radius:16px; padding:20px; 
                        cursor:pointer; transition:all 0.2s; display:flex; align-items:center; gap:15px; box-shadow:var(--shadow-card);
                    " onmouseover="this.style.borderColor='${t.color}'; this.style.transform='translateY(-3px)';" 
                      onmouseout="this.style.borderColor='var(--c-border)'; this.style.transform='none';">
                        <div style="
                            width:50px; height:50px; border-radius:12px; background:${t.color}; color:white; 
                            display:flex; align-items:center; justify-content:center; flex-shrink:0;
                        ">
                            ${t.icon}
                        </div>
                        <div>
                            <div style="font-weight:800; color:var(--c-text-primary); font-size:1rem; line-height:1.2; margin-bottom:4px;">${t.name}</div>
                            <div style="font-size:0.75rem; color:var(--c-text-secondary); line-height:1.4;">${t.desc}</div>
                        </div>
                    </div>
                `;
                count++;
            }
        });
        html += `</div>`;
        
        if(count === 0) html += `<div style="text-align:center; padding:20px;">利用可能なツールがありません。</div>`;
    
        modalTitleArea.innerHTML = `
            <div class="m-cat" style="color:${catColor}">MENU</div>
            <h2 class="m-title">${title}</h2>
            <div class="m-full">Select a tool to launch</div>
        `;
        modalBodyContent.innerHTML = html;
    
        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
    }

    /* --- New Career Simulation Logic (v3.1 Fixed K-Rate & Name) --- */
    
    let careerMode = 'batter'; // 'batter' or 'pitcher'
    
    function openCareerSim() {
        const overlay = document.getElementById('career-overlay');
        renderCareerCreationUI();
        overlay.classList.add('active');
        closeModal();
    }
    
    function closeCareerSim() {
        document.getElementById('career-overlay').classList.remove('active');
    }
    
    function setCareerMode(mode) {
        careerMode = mode;
        renderCareerCreationUI();
    }
    
    // ランク判定用関数
    function getRank(val) {
        if (val >= 90) return { rank: 'S', class: 'rank-s' };
        if (val >= 80) return { rank: 'A', class: 'rank-a' };
        if (val >= 70) return { rank: 'B', class: 'rank-b' };
        if (val >= 60) return { rank: 'C', class: 'rank-c' };
        if (val >= 53) return { rank: 'D', class: 'rank-d' };
        if (val >= 40) return { rank: 'E', class: 'rank-e' };
        if (val >= 20) return { rank: 'F', class: 'rank-f' };
        return { rank: 'G', class: 'rank-g' };
    }
    
    function updateRankDisplay(id, val) {
        const r = getRank(val);
        const labelEl = document.getElementById(`val-${id}`);
        const fillEl = document.getElementById(`fill-${id}`);
        
        if(labelEl && fillEl) {
            labelEl.innerHTML = `<span class="${r.class}" style="margin-right:8px; font-size:1.1em;">${r.rank}</span>${val}`;
            fillEl.style.width = `${val}%`;
            
            const colorMap = {
                'S': '#eab308', 'A': '#f97316', 'B': '#ef4444', 
                'C': '#f43f5e', 'D': '#10b981', 'E': '#3b82f6', 
                'F': '#64748b', 'G': '#94a3b8'
            };
            fillEl.style.background = colorMap[r.rank];
        }
    }
    
    function renderCareerCreationUI() {
        const content = document.getElementById('career-content');
        
        const isBat = careerMode === 'batter';
        const activeClassBat = isBat ? 'active' : '';
        const activeClassPit = !isBat ? 'active' : '';
    
        const params = isBat ? [
            {id:'contact', label:'ミート (Contact)', val:55, desc:'打率・コンタクト能力'},
            {id:'power', label:'パワー (Power)', val:55, desc:'本塁打・長打力'},
            {id:'speed', label:'走力 (Speed)', val:55, desc:'盗塁・内野安打・守備範囲'},
            {id:'arm', label:'肩力 (Arm)', val:55, desc:'補殺・守備貢献(UZR)'},
            {id:'defense', label:'守備力 (Fielding)', val:55, desc:'失策率・守備範囲'},
            {id:'catch', label:'捕球 (Error)', val:55, desc:'失策回避率'}
        ] : [
            {id:'velocity', label:'球速 (km/h)', val:145, min:120, max:170, desc:'最高球速・奪三振率'},
            {id:'control', label:'コントロール', val:55, desc:'与四球率・丁寧さ'},
            {id:'stamina', label:'スタミナ', val:55, desc:'投球回数・完投能力'},
            {id:'breaking', label:'変化球総変化量', val:3, min:0, max:20, desc:'空振り率・被打率'}
        ];
    
        const slidersHtml = params.map(p => {
            const isSpecial = (p.id === 'velocity' || p.id === 'breaking');
            const min = p.min || 1;
            const max = p.max || 100;
            
            let valDisplay = p.val;
            let rankHtml = '';
            
            if (!isSpecial) {
                const r = getRank(p.val);
                rankHtml = `<span class="${r.class}" style="margin-right:8px; font-size:1.1em;">${r.rank}</span>`;
            }
            
            let percent = ((p.val - min) / (max - min)) * 100;
    
            return `
                <div class="c-form-group">
                    <div class="c-rank-label">
                        <span>${p.label}</span>
                        <span id="val-${p.id}">${rankHtml}${valDisplay}</span>
                    </div>
                    <div class="c-rank-bar">
                        <div class="c-rank-fill" id="fill-${p.id}" style="width:${percent}%"></div>
                        <input type="range" id="sim-${p.id}" min="${min}" max="${max}" value="${p.val}" class="c-rank-input"
                            oninput="
                                const v = parseInt(this.value);
                                const min = ${min}, max = ${max};
                                const pct = ((v - min) / (max - min)) * 100;
                                if(${!isSpecial}) {
                                    updateRankDisplay('${p.id}', v);
                                } else {
                                    document.getElementById('val-${p.id}').innerText = v;
                                    document.getElementById('fill-${p.id}').style.width = pct + '%';
                                }
                            "
                        >
                    </div>
                </div>
            `;
        }).join('');
    
        const posOptions = isBat 
            ? `<option value="c">キャッチャー</option><option value="1b">ファースト</option><option value="2b">セカンド</option><option value="3b">サード</option><option value="ss">ショート</option><option value="cf">センター</option><option value="lf">レフト</option><option value="rf">ライト</option><option value="dh">DH</option>`
            : `<option value="sp">先発 (Starter)</option><option value="rp">救援 (Reliever)</option>`;
    
        content.innerHTML = `
            <div class="career-grid">
                <div class="career-panel">
                    <div class="career-title">
                        <div>
                            ${icons.save} PLAYER CREATION
                        </div>
                    </div>
                    
                    <div class="role-tabs">
                        <div class="role-tab ${activeClassBat}" onclick="setCareerMode('batter')">野手</div>
                        <div class="role-tab ${activeClassPit}" onclick="setCareerMode('pitcher')">投手</div>
                    </div>
    
                    <div class="c-form-group">
                        <label class="c-label">選手名</label>
                        <input type="text" id="sim-name" class="c-input" placeholder="入力なしで「名無し選手」" value="">
                    </div>
    
                    <div class="c-form-group">
                        <div class="c-slider-row">
                            <span class="c-label" style="margin:0;">開始年齢</span>
                            <span class="c-slider-val" id="val-age">18歳</span>
                        </div>
                        <input type="range" id="sim-age" min="18" max="30" value="18" class="c-slider"
                            oninput="document.getElementById('val-age').innerText = this.value + '歳'">
                        <div style="font-size:0.75rem; color:#94a3b8; margin-top:5px; display:flex; justify-content:space-between;">
                            <span>高卒(18)</span><span>大卒(22)</span><span>社会人(24~)</span>
                        </div>
                    </div>
    
                    <div class="c-form-group">
                        <label class="c-label">ポジション</label>
                        <select id="sim-pos" class="c-select">
                            ${posOptions}
                        </select>
                    </div>
    
                    <hr style="border:0; border-top:1px dashed #e2e8f0; margin:20px 0;">
    
                    ${slidersHtml}
    
                    <button class="calc-btn" style="background:#0f172a; margin-top:20px; box-shadow:0 4px 12px rgba(15,23,42,0.2);" onclick="runCareerSim()">
                        キャリアスタート
                    </button>
                </div>
    
                <div class="career-panel" id="career-result-panel" style="min-height:500px; display:flex; align-items:center; justify-content:center; flex-direction:column; text-align:center; color:#94a3b8;">
                    <div style="font-size:3rem; margin-bottom:15px; opacity:0.3; filter:grayscale(1);">🏟️</div>
                    <div style="font-weight:700;">PLAYER SIMULATION</div>
                    <div style="font-size:0.85rem; margin-top:8px;">
                        左側のパネルで能力を設定し、<br>プロ野球人生を開始してください。<br>
                        能力値はパワプロ風（S〜G）を参考にしています。
                    </div>
                </div>
            </div>
        `;
        
        if(isBat) {
            ['contact','power','speed','arm','defense','catch'].forEach(id => updateRankDisplay(id, 55));
        } else {
            updateRankDisplay('control', 55);
            updateRankDisplay('stamina', 55);
        }
    }
    
    function runCareerSim() {
        // 名前が空なら「名無し選手」を設定
        let rawName = document.getElementById('sim-name').value;
        const name = rawName.trim() === "" ? "名無し選手" : rawName;
        
        const startAge = parseInt(document.getElementById('sim-age').value);
        const pos = document.getElementById('sim-pos').value;
        const isBat = careerMode === 'batter';
    
        let stats = {};
        if (isBat) {
            ['contact', 'power', 'speed', 'arm', 'defense', 'catch'].forEach(id => {
                stats[id] = parseInt(document.getElementById(`sim-${id}`).value);
            });
        } else {
            ['velocity', 'control', 'stamina', 'breaking'].forEach(id => {
                stats[id] = parseInt(document.getElementById(`sim-${id}`).value);
            });
        }
    
        let age = startAge;
        let active = true;
        let history = [];
        let career = isBat 
            ? { g:0, pa:0, ab:0, h:0, hr:0, rbi:0, sb:0, bb:0, so:0, war:0 }
            : { g:0, ip_outs:0, w:0, l:0, sv:0, hld:0, so:0, bb:0, war:0, er:0 };
    
        let peakWar = -999;
        let peakStatsData = null;
    
        while (active && age < 46) {
            // --- 成長・衰退 ---
            let growth = 0;
            if (age < 24) growth = Math.random() * 4 + 1;
            else if (age < 28) growth = Math.random() * 2;
            else if (age < 32) growth = Math.random() * 1 - 1;
            else if (age < 36) growth = -Math.random() * 3 - 1;
            else growth = -Math.random() * 5 - 3;
    
            if (isBat) {
                Object.keys(stats).forEach(k => {
                    stats[k] = Math.max(1, Math.min(100, stats[k] + growth));
                });
            } else {
                stats.velocity = Math.max(120, Math.min(170, stats.velocity + (growth * 0.5))); 
                ['control', 'stamina', 'breaking'].forEach(k => {
                    stats[k] = Math.max(1, Math.min(100, stats[k] + growth));
                });
            }
    
            let abilityScore = 0;
            if (isBat) {
                abilityScore = (stats.contact + stats.power + stats.defense + stats.speed)/4;
            } else {
                let veloScore = (stats.velocity - 130) * 2;
                abilityScore = (veloScore + stats.control + stats.stamina + stats.breaking*5) / 4;
            }
    
            let season = {};
            let war = 0;
    
            if (abilityScore < 40) {
                // 2軍
                season = isBat 
                    ? { g:0, avg:'.---', hr:0, rbi:0, sb:0, ops:'.---', bb:0, so:0, uzr:'---' } 
                    : { g:0, w:0, l:0, sv:0, hld:0, era:'-.--', so:0, whip:'-.--', ip:'0.0' };
                war = 0;
                if (age > 25 && Math.random() < 0.3) active = false; 
            } else {
                // 1軍
                if (isBat) {
                    let games = Math.floor(Math.min(143, (abilityScore - 30) * 2.5 + Math.random()*20));
                    if(games > 143) games = 143;
                    
                    let pa = Math.floor(games * (3.5 + Math.random())); 
                    let bb_pct = 0.05 + (stats.contact * 0.0005); 
                    let bb = Math.floor(pa * bb_pct);
                    let ab = pa - bb;
    
                    let avg = 0.150 + (stats.contact * 0.002) + (Math.random()*0.04 - 0.02);
                    let h = Math.floor(ab * avg);
    
                    let hr_rate = Math.pow(stats.power, 2) / 180000;
                    let hr = Math.floor(pa * hr_rate * (0.8 + Math.random()*0.4));
    
                    let so_rate = 0.15 + (stats.power*0.0015) - (stats.contact*0.001);
                    if(so_rate < 0.05) so_rate = 0.05;
                    let so = Math.floor(pa * so_rate);
    
                    let sb = Math.floor(games * (stats.speed > 60 ? (stats.speed-50)*0.02 : 0) * Math.random());
                    let rbi = Math.floor(h*0.15 + hr*2.8 + Math.random()*10);
    
                    let obp = pa>0 ? (h+bb)/pa : 0;
                    let slg = ab>0 ? (h + hr*3)/ab : 0; 
                    let ops = obp + slg;
                    
                    let defScore = (stats.defense*2 + stats.arm + stats.catch)/4;
                    let uzr = (defScore - 50) * 0.5; 
                    let posVal = {'ss':1, '2b':0.8, 'cf':0.5, '3b':0, 'rf':-0.5, 'lf':-0.8, '1b':-1, 'dh':-1.5, 'c':1.2}[pos] || 0;
                    let effectiveUzr = uzr * (games/143);
    
                    let wRAA = ((ops - 0.730) / 1.2) * pa * 0.1; 
                    let rep = 20 * (pa/600);
                    let posAdj = posVal * 10 * (games/143);
                    war = (wRAA + effectiveUzr + posAdj + rep) / 10;
                    if(war > 12) war = 12;
    
                    let opsStr = ops.toFixed(3);
                    if(ops < 1.0) opsStr = opsStr.replace(/^0/, ''); 
    
                    season = { g:games, avg: avg.toFixed(3).replace(/^0/,''), hr, rbi, sb, bb, so, ops: opsStr, uzr: effectiveUzr.toFixed(1) };
                    
                    career.g += games; career.pa += pa; career.ab += ab; career.h += h; 
                    career.hr += hr; career.rbi += rbi; career.sb += sb; career.bb += bb; career.so += so;
                } else {
                    let isStarter = pos === 'sp';
                    let games = isStarter ? Math.floor(Math.min(28, abilityScore/2.2)) : Math.floor(Math.min(70, abilityScore/1.1));
                    
                    let ipPerG = isStarter ? (4 + stats.stamina*0.05) : (0.5 + stats.stamina*0.01);
                    let totalIp = games * ipPerG;
                    let outs = Math.floor(totalIp * 3);
                    
                    let pitSkill = (stats.velocity-100)*1.5 + stats.control + stats.breaking*10;
                    let baseEra = 6.00 - (pitSkill * 0.03); 
                    let era = Math.max(0.80, baseEra + (Math.random()*1.5 - 0.75));
                    
                    // --- 奪三振ロジック修正 ---
                    // Velocity 130-170, Breaking 0-20
                    // K/9 = 4.0 (基準) + 球速分 + 変化球分
                    // 球速: 150km基準で ±10kmで±1.5程度変動
                    let k9_velo = (stats.velocity - 130) * 0.15; 
                    let k9_break = stats.breaking * 0.35;
                    let k9 = 3.5 + k9_velo + k9_break;
                    
                    // 上限キャップ (K/9 が 16.0 を超えないように)
                    if(k9 > 16.0) k9 = 16.0;
    
                    let so = Math.floor(totalIp * k9 / 9);
    
                    // 物理制限: 奪三振数はアウトの総数を超えない
                    if(so > outs) so = outs - 1; 
    
                    let bb9 = 5.0 - (stats.control * 0.04); 
                    if(bb9<1) bb9=1;
                    let bb = Math.floor(totalIp * bb9 / 9);
    
                    let whip = 1.30 + (era - 3.50)*0.1; 
    
                    let w=0, l=0, sv=0, hld=0;
                    if(isStarter) {
                        let winPct = 0.5 - (era - 3.50)*0.15;
                        let dec = games * 0.9;
                        w = Math.max(0, Math.floor(dec * winPct));
                        l = Math.max(0, Math.floor(dec * (1-winPct)));
                    } else {
                        w = Math.floor(games * 0.1);
                        l = Math.floor(games * 0.1);
                        if (stats.velocity >= 150 || stats.breaking >= 10) {
                            sv = Math.floor(games * 0.6);
                        } else {
                            hld = Math.floor(games * 0.5);
                        }
                    }
    
                    let fip = era; 
                    let raa = (4.50 - fip) * (totalIp/9);
                    let rep = 20 * (totalIp/200);
                    war = (raa + rep) / 10;
    
                    let ipDisplay = Math.floor(outs/3) + (outs%3 === 0 ? "" : "." + (outs%3));
    
                    season = { g:games, w, l, sv, hld, era: era.toFixed(2), so, whip: whip.toFixed(2), ip: ipDisplay };
                    
                    career.g += games; career.ip_outs += outs; career.w += w; career.l += l; 
                    career.sv += sv; career.hld += hld; career.so += so; career.bb += bb; 
                    career.er += (era * (outs/3) / 9);
                }
            }
            
            career.war += war;
            history.push({ age, ...season, war: war.toFixed(1) });
    
            if (war > peakWar) {
                peakWar = war;
                window.tempPeakStats = isBat ? {
                    name: `${name} (${age}歳)`,
                    pa: Math.floor(season.g*4), ab: Math.floor(season.g*4)-season.bb, 
                    h: Math.floor((season.g*4-season.bb) * parseFloat(season.avg)), 
                    hr: season.hr, sb: season.sb, bb: season.bb, so: season.so,
                    stadium: 'avg', pos: pos
                } : {
                    name: `${name} (${age}歳)`,
                    ip: parseFloat(season.ip), 
                    er: Math.floor(parseFloat(season.ip)*parseFloat(season.era)/9),
                    so: season.so, bb: Math.floor(season.so/3), 
                    h: Math.floor(season.so*0.8), hr: Math.floor(season.so/10),
                    role: pos, stadium: 'avg'
                };
            }
    
            age++;
            if (age >= 45) active = false;
            if (age > 30 && war < 0 && Math.random() < 0.5) active = false;
        }
    
        const resultPanel = document.getElementById('career-result-panel');
        
        let bigStats = '';
        if (isBat) {
            let careerAvg = career.ab ? (career.h / career.ab).toFixed(3).replace(/^0/,'') : '.---';
            bigStats = `
                <div class="c-big-stat"><div class="c-big-val">${career.h}</div><div class="c-big-lbl">安打</div></div>
                <div class="c-big-stat"><div class="c-big-val">${career.hr}</div><div class="c-big-lbl">本塁打</div></div>
                <div class="c-big-stat"><div class="c-big-val">${careerAvg}</div><div class="c-big-lbl">打率</div></div>
                <div class="c-big-stat"><div class="c-big-val">${career.sb}</div><div class="c-big-lbl">盗塁</div></div>
                <div class="c-big-stat"><div class="c-big-val" style="color:#d97706;">${career.war.toFixed(1)}</div><div class="c-big-lbl">通算WAR</div></div>
            `;
        } else {
            let careerIp = Math.floor(career.ip_outs/3) + (career.ip_outs%3===0 ? "" : "." + (career.ip_outs%3));
            bigStats = `
                <div class="c-big-stat"><div class="c-big-val">${career.w}</div><div class="c-big-lbl">勝利</div></div>
                <div class="c-big-stat"><div class="c-big-val">${career.sv}</div><div class="c-big-lbl">セーブ</div></div>
                <div class="c-big-stat"><div class="c-big-val">${career.so}</div><div class="c-big-lbl">奪三振</div></div>
                <div class="c-big-stat"><div class="c-big-val">${careerIp}</div><div class="c-big-lbl">投球回</div></div>
                <div class="c-big-stat"><div class="c-big-val" style="color:#d97706;">${career.war.toFixed(1)}</div><div class="c-big-lbl">通算WAR</div></div>
            `;
        }
    
        const th = isBat 
            ? `<th>年齢</th><th>試合</th><th>打率</th><th>HR</th><th>打点</th><th>盗塁</th><th>四球</th><th>三振</th><th>OPS</th><th>UZR</th><th>WAR</th>`
            : `<th>年齢</th><th>登板</th><th>勝</th><th>敗</th><th>S</th><th>H</th><th>回</th><th>防率</th><th>奪三振</th><th>WHIP</th><th>WAR</th>`;
    
        const rows = history.map(h => {
            const w = parseFloat(h.war);
            const style = w >= 5.0 ? 'background:#fff7ed;' : '';
            const warClass = w >= 8.0 ? 'val-outstanding' : (w >= 5.0 ? 'val-great' : (w >= 2.0 ? 'val-good' : ''));
            
            if (isBat) {
                return `<tr style="${style}">
                    <td>${h.age}</td><td>${h.g}</td><td>${h.avg}</td><td>${h.hr}</td><td>${h.rbi}</td><td>${h.sb}</td>
                    <td>${h.bb}</td><td>${h.so}</td><td>${h.ops}</td><td>${h.uzr}</td>
                    <td class="${warClass}">${h.war}</td>
                </tr>`;
            } else {
                return `<tr style="${style}">
                    <td>${h.age}</td><td>${h.g}</td><td>${h.w}</td><td>${h.l}</td><td>${h.sv}</td><td>${h.hld}</td>
                    <td>${h.ip}</td><td>${h.era}</td><td>${h.so}</td><td>${h.whip}</td>
                    <td class="${warClass}">${h.war}</td>
                </tr>`;
            }
        }).join('');
    
        resultPanel.innerHTML = `
            <div style="width:100%;">
                <div class="career-title" style="justify-content:center; border:none; font-size:1.5rem;">
                    ${name} <span style="font-size:0.9rem; font-weight:normal; margin-left:10px; color:#64748b;">${pos.toUpperCase()} / ${history.length}年</span>
                </div>
                
                <div class="c-result-header">
                    ${bigStats}
                </div>
                
                <div class="c-history-wrap">
                    <table class="c-table">
                        <thead><tr>${th}</tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
    
                <div style="margin-top:20px; text-align:center;">
                    <button class="calc-btn" style="background:#3b82f6; width:auto; padding:10px 30px;" onclick="savePeakStats()">
                        全盛期データを保存
                    </button>
                </div>
            </div>
        `;
    }

    // Initial Render
    render();

</script>

<style>
    /* --- Settings & Variables --- */
    :root {
        --g-node-size: 85px;
        --g-focus-size: 320px; /* フォーカスサイズ */
        --g-font-size: 0.85rem;
    }
    @media (max-width: 768px) {
        :root {
            --g-node-size: 65px;
            --g-focus-size: 280px;
            --g-font-size: 0.75rem;
        }
        /* モバイル軽量化: 影とブラーを削除 */
        .g-node {
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            background: rgba(30, 41, 59, 0.98) !important;
            border: 1px solid rgba(255,255,255,0.3) !important;
        }
        .g-node.is-focused {
            box-shadow: 0 0 40px rgba(0,0,0,0.5) !important;
        }
    }

    /* --- Space Environment --- */
    #galaxy-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: radial-gradient(ellipse at center, #1e293b 0%, #020617 100%);
        z-index: 9999;
        visibility: hidden; opacity: 0;
        transform: scale(1.1);
        transition: opacity 0.5s, transform 0.5s, visibility 0.5s;
        overflow: hidden;
        cursor: grab;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        /* フォントレンダリング最適化 */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    #galaxy-overlay.active { visibility: visible; opacity: 1; transform: scale(1); }
    #galaxy-overlay:active { cursor: grabbing; }

    /* Canvas Starfield (Max Performance) */
    #starfield-canvas {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 0;
    }

    /* --- Universe Wrapper --- */
    #galaxy-universe {
        position: absolute; top: 50%; left: 50%; width: 0; height: 0;
        transform-style: preserve-3d;
        /* 通常時は will-change を外して高画質維持 */
    }
    /* 操作中のみGPU合成を強制して滑らかにする */
    #galaxy-universe.is-interacting {
        will-change: transform;
    }

    /* --- Cosmos Container --- */
    #galaxy-cosmos {
        position: absolute; top: 0; left: 0; width: 0; height: 0;
        transform-style: preserve-3d;
    }
    
    /* Launch Animation */
    .launching #galaxy-cosmos {
        animation: galaxyLaunch 1.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    }
    @keyframes galaxyLaunch {
        0% { transform: scale(0) rotate(45deg); opacity: 0; }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    /* --- Nodes --- */
    .g-node {
        position: absolute;
        /* サイズ変更アニメーションを有効化 */
        width: var(--g-node-size); height: var(--g-node-size);
        transform: translate(-50%, -50%) scale(0);
        border-radius: 50%;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        text-align: center; cursor: pointer;
        
        /* width/heightの遷移を追加してクッキリ拡大を実現 */
        transition: 
            width 0.4s cubic-bezier(0.19, 1, 0.22, 1),
            height 0.4s cubic-bezier(0.19, 1, 0.22, 1),
            transform 0.4s cubic-bezier(0.19, 1, 0.22, 1),
            opacity 0.3s, filter 0.3s;
            
        box-shadow: 0 0 15px rgba(0,0,0,0.3), inset 0 0 10px rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.2);
        z-index: 10;
        background: rgba(30, 41, 59, 0.85);
        color: #94a3b8;
        font-weight: 700;
        font-size: var(--g-font-size);
        touch-action: none;
        animation: nodePop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        animation-play-state: paused;
        
        /* テキストの滲みを防止 */
        transform-style: flat; 
    }
    @keyframes nodePop {
        from { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    @media (hover: hover) {
        .g-node:hover {
            z-index: 50;
            border-color: white; color: white;
            box-shadow: 0 0 25px rgba(255,255,255,0.25);
            /* ホバー時はScaleで拡大（一時的なのでOK） */
            transform: translate(-50%, -50%) scale(1.15);
        }
    }

    .g-node.is-dimmed {
        opacity: 0.1 !important;
        transform: translate(-50%, -50%) scale(0.8) !important;
        pointer-events: none;
        filter: grayscale(100%);
    }
    
    .g-node.is-related {
        opacity: 1 !important;
        border-color: rgba(255,255,255,0.9);
        z-index: 40;
    }
    @media (min-width: 769px) { .g-node.is-related { box-shadow: 0 0 20px rgba(255,255,255,0.2); } }

    /* Focused State - High Resolution Mode */
    .g-node.is-focused {
        /* ScaleではなくWidth/Heightで拡大することで再描画を促し高画質化 */
        width: var(--g-focus-size); height: var(--g-focus-size);
        z-index: 100;
        background: rgba(15, 23, 42, 0.98) !important;
        border: 2px solid rgba(255,255,255,0.6) !important;
        transform: translate(-50%, -50%) scale(1) !important; /* Scaleは1に戻す */
        cursor: default;
        box-shadow: 0 0 60px rgba(0,0,0,0.6) !important;
    }
    
    .g-content-normal { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; transition: opacity 0.2s; }
    .g-node.is-focused .g-content-normal { display: none; opacity: 0; }

    .g-content-focus {
        display: none; opacity: 0; width: 100%; height: 100%;
        flex-direction: column; align-items: center; justify-content: center;
        padding: 25px; box-sizing: border-box;
    }
    .g-node.is-focused .g-content-focus { display: flex; opacity: 1; animation: fadeIn 0.4s ease 0.1s forwards; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* Focus Content - Optimized Sizes */
    .gf-icon svg { width: 48px; height: 48px; margin-bottom: 10px; opacity: 1; }
    .gf-title { font-size: 1.8rem; font-weight: 900; line-height: 1.1; margin-bottom: 5px; color: white; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
    .gf-full { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; opacity: 0.8; margin-bottom: 12px; color: #cbd5e1; }
    .gf-desc { font-size: 0.85rem; line-height: 1.5; color: #e2e8f0; margin-bottom: 15px; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; white-space: normal; }
    .gf-btn { 
        padding: 10px 24px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.4); 
        background: rgba(255,255,255,0.15); color: white; cursor: pointer; 
        font-size: 0.9rem; font-weight: bold; pointer-events: auto; z-index: 200; position: relative;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .gf-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.3); }
    
    @media (max-width: 768px) { 
        .gf-title { font-size: 1.5rem; } 
        .gf-desc { font-size: 0.8rem; -webkit-line-clamp: 4; } 
        .gf-icon svg { width: 36px; height: 36px; }
    }
    .g-node .icon-normal svg { width: 28px; height: 28px; margin-bottom: 4px; opacity: 0.8; }
    
    /* Lines */
    #galaxy-lines { position: absolute; top: -5000px; left: -5000px; width: 10000px; height: 10000px; pointer-events: none; z-index: 1; }
    .g-line { stroke: rgba(255,255,255,0.15); stroke-width: 1.5; transition: opacity 0.3s; opacity: 0; shape-rendering: geometricPrecision; }
    .active .g-line { animation: lineFadeIn 1s 0.5s forwards; }
    @keyframes lineFadeIn { to { opacity: 1; } }
    .g-line.is-dimmed { opacity: 0.02 !important; }
    .g-line.is-related { stroke: rgba(255,255,255,0.6); stroke-width: 2.0; opacity: 1 !important; }

    /* Category Colors */
    .g-cat-bat { border-color: rgba(14, 165, 233, 0.4); } .g-cat-bat.is-focused { border-color: #0ea5e9; } .g-cat-bat .icon-normal { color: #0ea5e9; }
    .g-cat-pit { border-color: rgba(244, 63, 94, 0.4); } .g-cat-pit.is-focused { border-color: #f43f5e; } .g-cat-pit .icon-normal { color: #f43f5e; }
    .g-cat-fld { border-color: rgba(217, 119, 6, 0.4); } .g-cat-fld.is-focused { border-color: #d97706; } .g-cat-fld .icon-normal { color: #d97706; }
    .g-cat-tot { border-color: rgba(16, 185, 129, 0.4); } .g-cat-tot.is-focused { border-color: #10b981; } .g-cat-tot .icon-normal { color: #10b981; }

    /* Controls */
    .galaxy-controls {
        /* アニメーションとの競合を避けるため、marginによる中央寄せに変更 */
        position: absolute; 
        bottom: 30px; 
        left: 0; 
        right: 0; 
        margin: 0 auto; 
        width: max-content; /* コンテンツ幅に合わせる */
        
        display: flex; gap: 12px; z-index: 1000;
        padding: 8px 16px; border-radius: 40px;
        background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.15);
        opacity: 0; animation: fadeIn 1s 0.5s forwards;
    }
    .g-btn {
        background: transparent; border: none; color: rgba(255,255,255,0.8); padding: 0; border-radius: 50%; cursor: pointer;
        width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;
    }
    .g-btn svg { width: 22px; height: 22px; stroke-width: 2; }
    .g-btn.close { color: #f43f5e; }
    @media (max-width: 768px) {
        .galaxy-controls {
            /* === 配置の修正 === */
            top: auto !important;           /* 上固定を解除 */
            bottom: 30px !important;        /* 下から30pxの位置に */
            right: auto !important;         /* 右寄せを解除 */
            
            /* 【重要】左端を画面中央(50%)に置いた後、自身の幅の半分(-50%)だけ左に戻す */
            left: 50% !important;
            transform: translateX(-50%) !important;
            
            /* === 見た目の調整 === */
            padding: 8px 16px;              /* タップしやすいよう少し広めに */
            border-radius: 30px;            /* 丸みを強める */
            width: max-content;             /* 内容幅に合わせる */
            max-width: 90%;                 /* 画面からはみ出さないように */
        }
    }
</style>

<div id="galaxy-overlay">
    <div id="galaxy-universe">
        <div id="galaxy-cosmos">
            <svg id="galaxy-lines"></svg>
            <div id="galaxy-nodes"></div>
        </div>
    </div>
    <div class="galaxy-controls">
        <button class="g-btn" onclick="zoomIn()" title="拡大"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="16"/><line x1="8" x2="16" y1="12" y2="12"/></svg></button>
        <button class="g-btn" onclick="zoomOut()" title="縮小"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="8" x2="16" y1="12" y2="12"/></svg></button>
        <button class="g-btn" onclick="fitToScreen()" title="リセット"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M16 3h3a2 2 0 0 1 2 2v3"/><path d="M8 21H5a2 2 0 0 1-2-2v-3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg></button>
        <div style="width:1px; height:24px; background:rgba(255,255,255,0.2); margin:auto 5px;"></div>
        <button class="g-btn close" onclick="closeMindMap()" title="閉じる"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></button>
    </div>
</div>

<div id="career-overlay">
    <div class="career-header">
        <div class="career-brand">MY CAREER <span>SIMULATION</span></div>
        <button class="g-btn close" onclick="closeCareerSim()" title="閉じる">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
        </button>
    </div>
    <div class="career-content" id="career-content">
        </div>
</div>

<script>
    const gOverlay = document.getElementById('galaxy-overlay');
    const gUniverse = document.getElementById('galaxy-universe');
    const gNodesContainer = document.getElementById('galaxy-nodes');
    const gLines = document.getElementById('galaxy-lines');

    let isInitialized = false;
    let nodesData = [];
    let viewState = { 
        scale: 0.35, panX: 0, panY: 0, 
        isDragging: false, lastX: 0, lastY: 0, 
        isPinching: false, pinchStartDist: 0, pinchStartScale: 1,
        suppressClick: false
    };
    const MAX_SCALE = 1.2; const MIN_SCALE = 0.35;

    const CATEGORY_CENTERS = { 'tot': { x: 0, y: 0 }, 'std': { x: 0, y: -450 }, 'bat': { x: 800, y: 0 }, 'pit': { x: -800, y: 0 }, 'fld': { x: 0, y: 650 } };
    const extraRelations = {
        'avg': ['obp', 'slg', 'ops', 'babip', 'woba'], 'obp': ['avg', 'slg', 'ops', 'bb_pct', 'isod', 'woba'], 'slg': ['avg', 'obp', 'ops', 'iso', 'hr_ab', 'woba'],
        'ops': ['avg', 'obp', 'slg', 'woba', 'wrc_plus'], 'woba': ['ops', 'wrc_plus', 'wrc', 'wraa', 'xwoba'], 'wrc_plus': ['woba', 'wraa', 'war'],
        'war': ['wraa', 'uzr', 'wsb', 'bsr', 'fip', 'pit_war'], 'bb_pct': ['k_pct', 'bb_k', 'isod'], 'k_pct': ['bb_pct', 'bb_k'],
        'era': ['fip', 'xfip', 'siera', 'ra9'], 'fip': ['era', 'xfip', 'siera', 'k_pct_pit'], 'xfip': ['fip', 'siera', 'gb_pct'], 'siera': ['fip', 'xfip'],
        'uzr': ['drs', 'oaa', 'rngr'], 'drs': ['uzr', 'oaa'], 'oaa': ['uzr', 'drs']
    };
    const gIcons = {
        bat: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M2 17 17 2"/><path d="m2 2 20 20"/><path d="m19 2 2 2"/><path d="m2 19 2 2"/><path d="m10 2 2 2"/><path d="m2 10 2 2"/></svg>`,
        pit: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="m16 12-4-4-4 4"/><path d="M12 16V8"/></svg>`,
        fld: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/></svg>`,
        tot: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>`,
        std: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="2" y2="22"/><line x1="2" x2="22" y1="12" y2="12"/></svg>`
    };

    function initGalaxy() {
        if (isInitialized) return;
        terms.forEach(t => {
            if(!t.related) t.related = [];
            if(extraRelations[t.id]) extraRelations[t.id].forEach(rid => { if(!t.related.includes(rid)) t.related.push(rid); });
        });
        terms.forEach(t => {
            t.related.forEach(rid => {
                const target = terms.find(x => x.id === rid);
                if(target && (!target.related || !target.related.includes(t.id))) {
                    if(!target.related) target.related = []; target.related.push(t.id);
                }
            });
        });

        nodesData = terms.map(t => {
            const center = CATEGORY_CENTERS[t.category] || {x:0, y:0};
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 320;
            return { ...t, x: center.x + Math.cos(angle)*dist, y: center.y + Math.sin(angle)*dist, links: t.related||[] };
        });

        const NODE_RADIUS = 140;
        for(let k=0; k<50; k++){
            for(let i=0; i<nodesData.length; i++){
                for(let j=i+1; j<nodesData.length; j++){
                    const n1 = nodesData[i], n2 = nodesData[j];
                    const dx = n1.x - n2.x, dy = n1.y - n2.y;
                    const d = Math.sqrt(dx*dx+dy*dy);
                    if(d < NODE_RADIUS){
                        const f = (NODE_RADIUS - d)/(d||1)*0.5;
                        const mx = dx*f, my = dy*f;
                        n1.x+=mx; n1.y+=my; n2.x-=mx; n2.y-=my;
                    }
                }
            }
        }

        renderLines();
        nodesData.forEach(node => createNodeElement(node));
        isInitialized = true;
    }

    function renderLines() {
        const pairs = new Set(); let html = '';
        nodesData.forEach(source => {
            if(!source.links) return;
            source.links.forEach(targetId => {
                const target = nodesData.find(n => n.id === targetId);
                if(target){
                    const pairId = [source.id, target.id].sort().join('-');
                    if(!pairs.has(pairId)){
                        const x1=5000+source.x, y1=5000+source.y, x2=5000+target.x, y2=5000+target.y;
                        html += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="g-line" data-src="${source.id}" data-tgt="${target.id}" />`;
                        pairs.add(pairId);
                    }
                }
            });
        });
        gLines.innerHTML = html;
    }

    function createNodeElement(node) {
        const el = document.createElement('div');
        el.className = `g-node g-cat-${node.category}`;
        el.id = `g-node-${node.id}`;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;
        el.style.animationDelay = `${Math.random() * 0.8 + 0.1}s`;

        const iconSvg = gIcons[node.category] || gIcons.std;
        
        el.innerHTML = `
            <div class="g-content-normal"><div class="icon-normal">${iconSvg}</div><div>${node.title}</div></div>
            <div class="g-content-focus">
                <div class="gf-icon">${iconSvg}</div>
                <div class="gf-title">${node.title}</div>
                <div class="gf-full">${node.full}</div>
                <div class="gf-desc">${node.short || '...'}</div>
                <button class="gf-btn" onclick="closeMindMap(); openModal('${node.id}')">詳細・計算</button>
            </div>
        `;

        const handleTap = (e) => {
            if (e.target.closest('.gf-btn')) return; 
            if(viewState.isDragging || viewState.suppressClick) return;
            e.stopPropagation();
            if(e.type === 'touchend') e.preventDefault();
            activateNode(node);
        };
        el.onclick = handleTap;
        el.ontouchend = handleTap;
        gNodesContainer.appendChild(el);
    }

    function activateNode(node) {
        resetFocus();
        const currentId = node.id;
        const relatedIds = node.links || [];
        
        document.querySelectorAll('.g-node').forEach(el => {
            const elId = el.id.replace('g-node-', '');
            if(elId === currentId) el.classList.add('is-focused');
            else if(relatedIds.includes(elId)) el.classList.add('is-related');
            else el.classList.add('is-dimmed');
        });

        document.querySelectorAll('.g-line').forEach(line => {
            const src = line.getAttribute('data-src'), tgt = line.getAttribute('data-tgt');
            if((src===currentId && relatedIds.includes(tgt)) || (tgt===currentId && relatedIds.includes(src))) line.classList.add('is-related');
            else line.classList.add('is-dimmed');
        });

        // 拡大表示時はズームを最大にして視認性を高める
        animateView(-node.x, -node.y, MAX_SCALE);
    }

    function resetFocus() {
        document.querySelectorAll('.g-node').forEach(el => el.classList.remove('is-focused', 'is-related', 'is-dimmed'));
        document.querySelectorAll('.g-line').forEach(el => el.classList.remove('is-related', 'is-dimmed'));
    }

    gOverlay.addEventListener('click', (e) => {
        if(viewState.isDragging || viewState.suppressClick) return;
        if(e.target.closest('.g-node') || e.target.closest('.galaxy-controls')) return;
        resetFocus();
    });

    function animateView(targetX, targetY, targetScale) {
        gUniverse.classList.add('is-interacting'); // アニメーション中のみ軽量化
        gUniverse.style.transition = 'transform 0.6s cubic-bezier(0.19, 1, 0.22, 1)';
        viewState.panX = targetX; viewState.panY = targetY; viewState.scale = targetScale;
        updateTransform();
        setTimeout(() => { 
            gUniverse.style.transition = 'none'; 
            gUniverse.classList.remove('is-interacting'); // アニメ終了後に高画質化
        }, 600);
    }

    function openMindMap() {
        initGalaxy();
        gOverlay.classList.add('active');
        gOverlay.classList.add('launching');
        document.querySelectorAll('.g-node').forEach(el => { el.style.animationPlayState = 'running'; });
        fitToScreen();
        setTimeout(() => { gOverlay.classList.remove('launching'); }, 1500);
    }

    function closeMindMap() { gOverlay.classList.remove('active'); resetFocus(); }
    
    function updateTransform() { gUniverse.style.transform = `translate(${viewState.panX}px, ${viewState.panY}px) scale(${viewState.scale})`; }
    
    function fitToScreen() {
        viewState.panX = 0; viewState.panY = 0;
        const minDim = Math.min(window.innerWidth, window.innerHeight);
        viewState.scale = Math.max(minDim / 1500, MIN_SCALE);
        gUniverse.style.transition = 'transform 0.6s ease';
        updateTransform();
        setTimeout(() => { gUniverse.style.transition = 'none'; }, 600);
        resetFocus();
    }
    function zoomIn() { viewState.scale = Math.min(viewState.scale * 1.3, MAX_SCALE); animateView(viewState.panX, viewState.panY, viewState.scale); }
    function zoomOut() { viewState.scale = Math.max(viewState.scale / 1.3, MIN_SCALE); animateView(viewState.panX, viewState.panY, viewState.scale); }

    /* Performance Control & Interaction */
    const startInteraction = () => { gUniverse.style.transition = 'none'; gUniverse.classList.add('is-interacting'); };
    const endInteraction = () => { setTimeout(() => { gUniverse.classList.remove('is-interacting'); }, 100); };

    function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX, dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx*dx + dy*dy);
    }
    gOverlay.addEventListener('wheel', (e) => { 
        e.preventDefault(); startInteraction();
        const delta = e.deltaY * -0.001; 
        viewState.scale = Math.min(Math.max(MIN_SCALE, viewState.scale+delta), MAX_SCALE); 
        updateTransform();
        clearTimeout(window.wheelTimer); window.wheelTimer = setTimeout(endInteraction, 150);
    }, {passive:false});

    const handleStart = (x, y) => { if(viewState.isPinching)return; viewState.isDragging = false; viewState.lastX = x; viewState.lastY = y; startInteraction(); };
    const handleMove = (x, y) => {
        if(viewState.isPinching)return;
        const dx = x - viewState.lastX, dy = y - viewState.lastY;
        if(Math.abs(dx)>3 || Math.abs(dy)>3) viewState.isDragging = true;
        if(viewState.isDragging){ viewState.panX += dx; viewState.panY += dy; updateTransform(); }
        viewState.lastX = x; viewState.lastY = y;
    };

    gOverlay.addEventListener('mousedown', (e) => { if(e.target.closest('.galaxy-controls'))return; handleStart(e.clientX, e.clientY); gOverlay.style.cursor = 'grabbing'; });
    window.addEventListener('mousemove', (e) => { if(gOverlay.style.cursor === 'grabbing') handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', () => { gOverlay.style.cursor = 'grab'; endInteraction(); setTimeout(()=>viewState.isDragging=false, 50); });

    gOverlay.addEventListener('touchstart', (e) => {
        if(e.target.closest('.galaxy-controls'))return;
        if(e.touches.length===2){ viewState.isPinching=true; viewState.pinchStartDist=getDistance(e.touches); viewState.pinchStartScale=viewState.scale; startInteraction(); }
        else if(e.touches.length===1){ viewState.isPinching=false; handleStart(e.touches[0].clientX, e.touches[0].clientY); }
    }, {passive:false});
    window.addEventListener('touchmove', (e) => {
        if(e.touches.length===2 && viewState.isPinching){
            const dist = getDistance(e.touches); const scaleChange = dist/viewState.pinchStartDist;
            viewState.scale = Math.min(Math.max(MIN_SCALE, viewState.pinchStartScale*scaleChange), MAX_SCALE);
            updateTransform(); e.preventDefault();
        } else if(e.touches.length===1 && !viewState.isPinching) handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive:false});
    window.addEventListener('touchend', (e) => {
        if(e.touches.length<2) { if(viewState.isPinching) { viewState.suppressClick = true; setTimeout(() => { viewState.suppressClick = false; }, 300); } viewState.isPinching=false; }
        endInteraction(); setTimeout(()=>viewState.isDragging=false, 50);
    });

    function drawStars() {
        const cvs = document.getElementById('starfield-canvas'), ctx = cvs.getContext('2d');
        const setSize = () => { cvs.width = window.innerWidth; cvs.height = window.innerHeight; render(); };
        window.addEventListener('resize', setSize);
        const stars = []; const numStars = window.innerWidth < 768 ? 60 : 150;
        for(let i=0; i<numStars; i++) stars.push({ x: Math.random()*window.innerWidth, y: Math.random()*window.innerHeight, r: Math.random()*1.5, a: Math.random() });
        setSize();
        function render() {
            ctx.clearRect(0,0,cvs.width,cvs.height); ctx.fillStyle = "white";
            stars.forEach(s => { ctx.globalAlpha = s.a; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); });
        }
    }
</script>

<script>
    // PWA Service Worker 登録スクリプト
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('ServiceWorker registration successful:', registration.scope);
                    
                    // 更新が見つかったら即座に反映を促す
                    registration.onupdatefound = () => {
                        const installingWorker = registration.installing;
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'installed') {
                                if (navigator.serviceWorker.controller) {
                                    console.log('New content is available; please refresh.');
                                } else {
                                    console.log('Content is cached for offline use.');
                                }
                            }
                        };
                    };
                })
                .catch(err => {
                    console.log('ServiceWorker registration failed:', err);
                });
        });
        
        // 更新時にページをリロードする処理
        let refreshing;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            refreshing = true;
            window.location.reload();
        });
    }
</script>

</body>
</html>
